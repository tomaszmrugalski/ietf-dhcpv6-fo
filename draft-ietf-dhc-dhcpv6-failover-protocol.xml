<?xml version='1.0' ?>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>

<?rfc compact="yes"?> <?rfc subcompact="no"?>

<?rfc symrefs="yes"?>

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' [
]>
<rfc ipr="trust200902" category="std"
     docName="draft-ietf-dhc-dhcpv6-failover-protocol-02">
  <front>
    <title abbrev="DHCPv6 Failover Protocol">DHCPv6 Failover Protocol</title>

    <author fullname="Tomasz Mrugalski" initials="T." surname="Mrugalski">
      <organization abbrev="ISC">Internet Systems Consortium, Inc.
      </organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <phone>+1 650 423 1345</phone>
        <email>tomasz.mrugalski@gmail.com</email>
      </address>
    </author>
    <author fullname="Kim Kinnear" initials="K." surname="Kinnear">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1414 Massachusetts Avenue</street>
          <city>Boxborough</city>
          <region>Massachusetts</region>
          <code>01719</code>
          <country>USA</country>
        </postal>
        <phone>+1 (978) 936-0000</phone>
        <email>kkinnear@cisco.com</email>
      </address>
    </author>

    <date />

    <area>Internet</area>
    <workgroup>Dynamic Host Configuration (DHC)</workgroup>
    <keyword>DHCPv6</keyword>
    <keyword>Failover</keyword>

    <abstract>
      <t>DHCPv6 as defined in "Dynamic Host Configuration Protocol
      for IPv6 (DHCPv6)" (RFC3315) does not offer server redundancy.
      This document defines a protocol implementation to
      provide DHCPv6 failover, a mechanism for running two
      servers on the same network with the capability for either
      server to take over clients' leases in case of server failure
      or network partition.  It meets the requirements for DHCPv6
      failover detailed in "DHCPv6 Failover Requirements" (RFC7031).
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The failover protocol provides a means for cooperating
      DHCP servers to work together to provide a DHCP service
      with availability that is increased beyond that which could
      be provided by a single DHCP server operating alone.  It
      is designed to protect DHCP clients against server unreachability,
      including server failure and network partition. It is possible
      to deploy exactly two servers that are able to continue
      providing a lease for an IPv6 address <xref target="RFC3315"/>
      or on an IPv6 prefix <xref target="RFC3633"/>
      without the DHCP client experiencing lease expiration or a
      reassignment of a lease to a different IPv6 address or prefix 
      in the event of failure by one or the other of the two servers.</t>

      <t>This protocol defines an active-passive mode, sometimes
      also called a hot standby model. This means that during normal
      operation one server is active (i.e. actively responds to
      clients' requests) while the second is passive (i.e. it
      receives clients' requests, but responds only to those specifically
      directed to it).  The secondary maintains a copy of the binding
      database and is ready to take over all incoming queries in case
      of primary server failure.  </t>

      <t>The failover protocol is designed to provide lease stability
      for leases with valid lifetimes beyond a short period. 
      The DHCPv6 Failover protocol MUST NOT be used for leases shorter 
      than 30 seconds.</t>

      <t>This protocol fulfills all DHCPv6 failover requirements
      defined in <xref target="RFC7031"/>. 
      </t>

    </section> 

    <section title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Glossary">
      <t>This is a supplemental glossary that should be combined with
      definitions in Section 3 of
      <xref target="RFC7031">RFC 7031</xref>.

      <list style="symbols">

        <t>Absolute Time
        <vspace blankLines="1" />
        The time in seconds since midnight January 1, 2000 UTC,
        modulo 2^32).
        </t>

        <t>Address Lease
        <vspace blankLines="1" />
        A lease involving an IPv6 address.  Typically used when
        it is necessary to distinguish the lease for an IPv6 address
        from a lease for a DHCP prefix.  See "delegated prefix" and
        "prefix lease". 
        </t>
 
        <t>auto-partner-down
        <vspace blankLines="1" />
        A capability where a failover server will move from
        COMMUNICATIONS-INTERRUPTED state to PARTNER-DOWN state
        automatically, without operator intervention.
        </t>

        <t>Available (Lease or Prefix)
        <vspace blankLines="1" />
        A lease or delegable prefix is available if it could be
        allocated for use by a DHCP client.  It is available on
        the main server when it is in FREE state and available on
        the secondary server when it is in the FREE-BACKUP state.
        Sometimes the term "available" is used when it would be
        awkward to say "FREE on the primary server and FREE-BACKUP on
        the secondary server".
        </t>

        <t>Binding-Status
        <vspace blankLines="1" />
        A lease can hold a variety of states (see
        <xref target="option_f_binding_status"/> for a list)
        and these are also referred to as the binding-status of
        the lease.
        </t>

        <t>Delegable Prefix
        <vspace blankLines="1" />
        A prefix from which other prefixes may be delegated, as 
        described in <xref target="RFC3633"/>.  A prefix which
        has been delegated is known as a "delegated prefix" 
        or a "prefix lease".
        </t>

        <t>Delegated Prefix
        <vspace blankLines="1" />
        A prefix which has been deletegated to a DHCP client as
        described in <xref target="RFC3633"/>.  Depending on the
        context, a delegated prefix may also be described as a
        "prefix lease", when it is necessary to distinguish it from
        an "address lease".
        </t>

        <t>Failover endpoint
        <vspace blankLines="1" />
        The failover protocol allows for there to be a unique
        failover 'endpoint' for each failover relationship in which
        a failover server participates.  The failover relationship
        is defined by a relationship name, and includes the failover
        partner IP address, the role this server takes with respect
        to that partner (primary or secondary), and the prefixes
        from which addresses can be leased as well as prefixes from which
        other prefixes can be delegated (delegable prefixes),
        associated with that relationship.  The failover endpoint
        can take actions and hold unique states.  Typically, there
        is one failover endpoint per partner (server), although
        there may be more.
        </t>

        <t>Failover communication
        <vspace blankLines="1" />
        All messages exchanged between
        partners.
        </t>

        <t>Independent Allocation
        <vspace blankLines="1" />
        An allocation algorithm
        that splits the available pool of address leases between the primary
        and secondary servers.  
        It is used for IPv6 address allocations.  
        See <xref target="alloc-independent"/>.
        </t>

        <t>Lease
        <vspace blankLines="1" />
        An association of a DHCP client with an IPv6
        address or delegated prefix.  This might refer to either an existing 
        association or a potential association.  
        </t>

        <t>MCLT
        <vspace blankLines="1" />
        Maximum Client Lead Time.  The fundamental relationship on
        which much of the correctness of this protocol depends is
        that the lease expiration time known to a DHCP client
        MUST NOT be greater by more than the MCLT beyond the later
        of the  partner lifetime time acknowledged by that server's
        failover partner or the current time (i.e., now).  See <xref
        target="mclt"/>.
        </t>

        <t>Partner
        <vspace blankLines="1" />
        The other DHCP server that participates in a failover
        relationship. When the role (primary or secondary) is not
        important, the other server is referred to as a "failover
        partner" or sometimes simply "partner".  
        </t>

        <t>Prefix Lease
        <vspace blankLines="1" />
        A lease involving a prefix that is or could be delegated, as
        opposed to a lease for a single IPv6 address.  A prefix lease
        can also be described as a "delegated prefix".
        </t>

        <t>Primary Server
        <vspace blankLines="1" />
        First out of two DHCP servers that participate
        in a failover relationship. When both servers are operating this 
        server handles most of the client traffic. Its failover partner
        is referred to as secondary server. 
        </t>

        <t>Proportional Allocation
        <vspace blankLines="1" />
        An allocation algorithm that splits the delegable prefixes
        between the primary and secondary servers and maintains a
        more or less fixed proportion of the delegable prefixes
        between both servers. 
        <xref target="alloc-prop"/>.  
        </t>

        <t>Renew Responsive
        <vspace blankLines="1" />
        A server that is renew responsive will respond to DHCP client requests
        that are directed to it by having an OPTION_SERVERID option in the
        message which contains the DUID of the renew responsive
        server.  See <xref target="RFC3315"/>.
        </t>

        <t>Responsive
        <vspace blankLines="1" />
        A server that is responsive will respond to all DHCP client requests.
        </t>

        <t>Secondary Server
        <vspace blankLines="1" />
        Second of two DHCP servers that participate in a failover
        relationship. Its failover partner is referred to as the
        primary server. When both servers are operating this server (the
        secondary) typically does not handle client traffic and
        acts as a backup to the primary server.  It will respond, however,
        to RENEW requests directed specifically to it.
        </t>

        <t>Server
        <vspace blankLines="1" />
         A DHCP server that implements DHCPv6 failover.
        'Server' and 'failover endpoint' are synonymous only if the
        server participates in only one failover relationship. 
        </t>

        <t>State
        <vspace blankLines="1" />
        The term state is used in two ways in this document.
        A failover endpoint is always in some state, and there are
        a series of states that a failover endpoint can move through.
        See <xref target="states"/> for details of the failover
        endpoint states.  A lease also has a state, and this is
        sometimes referred to as a binding-status.  See 
        <xref target="option_f_binding_status"/> for a list of
        the states a lease can hold.
        </t>

        <t>Time Context
        <vspace blankLines="1" />
         Each failover server has a clock and a definite idea of the
         current universal time.  Each server's idea of the current time
         is considered its time context.
        </t>

        <t>Unresponsive
        <vspace blankLines="1" />
        A server that is unresponsive will not
        respond to DHCP client requests.
        </t>

      </list>
      </t>
    </section>


<section title="Failover Concepts and Mechanisms">


    <section anchor="configuration" title="Required Server Configuration">

      <t>Servers frequently have several kinds of leases available
      on a particular network segment.  The failover protocol assumes
      that both primary and secondary servers are configured identically
      with regard to the prefixes and links involved in DHCP.
      For delegated prefixes (involved in proportional allocation)
      the primary server is responsible for allocating to the secondary
      server the correct proportion of the available delegated prefixes.
      IPv6 addresses (involved in independent allocation) are allocated
      to the primary and secondary servers algorithmically, and do not
      require an explicit message transfer to be distributed.
      </t>

    </section>

    <section title="IPv6 Address and Delegable Prefix Allocation">

      <t>Currently there are two allocation algorithms defined, one
      for address leases and one for prefix leases.
      </t>

      <section anchor="alloc-independent" title="Independent Allocation">

        <t>In this allocation scheme, used for allocating individual
        IPv6 addresses, available IPv6 addresses are permanently
        (until server configuration changes) split between servers.
        Available IPv6 addresses are split between the primary and
        secondary servers as part of initial connection establishment.
        Once IPv6 addresses are allocated to each server, there is
        no need to reassign them.  The IPv6 address allocation is
        algorithmic in nature, and does not require a message
        exchange for each server to know which IPv6 addresses it
        has been allocated.  This algorithm is simpler than
        proportional allocation since it does not require a rebalancing
        mechanism. It also assumes that the pool assigned to each
        server will never deplete.  </t>

        <t>Once each server is assigned a pool of IPv6 addresses
        during initial connection establishment, it may allocate
        its assigned IPv6 addresses to clients. Once a client
        releases a lease or its lease on an IPv6 address expires,
        the returned IPv6 address returns to the pool for the server
        that leased it.  A lease on an IPv6 address can be renewed
        by a responsive server or by a renew responsive server.
        When an IPv6 address goes PENDING-FREE
        (see <xref target="info-model"/>)
        it is owned by whichever server it is allocated to by
        the independent allocation algorithm.</t>

        <t>IPv6 addresses (which use the independent allocation
        approach) are ignored when a server processes a POOLREQ
        message.</t>

	<t>During COMMUNICATION-INTERRUPTED events, a partner MAY
	continue extending existing address leases as requested by
	clients.  An operational partner MUST NOT lease IPv6 addresses
	that were assigned to its downed partner and later expired
	or were released or declined by a client.  When it is in
	PARTNER-DOWN state, a server MUST allocate new leases from
	its own pool.  It MUST NOT use its partner's pool to allocate
	new leases.</t>

        <section anchor="independent-algorithm" title="Independent Allocation Algorithm">

        <t>
        For each address that can be allocated,
        the primary server MUST allocate only IPv6 addresses
        when the low-order bit (i.e., bit 127) is equal to 1, and
        the secondary server MUST allocate only the IPv6 addresses
        when the low-order bit (i.e., bit 127) is equal to 0.
        </t>

        </section>

        </section>

      <section anchor="alloc-prop" title="Proportional Allocation">

        <t>In this allocation scheme, each server has its own pool
        of prefixes available for delegation, known as "delegable
        prefixes".  These delegable prefixes may be prefixes from
        which other prefixes can be delegated or they may be prefixes
        which are the correct size for delegation but are not, at
        present, delegated to a particular client.  Remaining
        delegable prefixes are split between the primary and
        secondary servers in a configured proportion.  Note that a
        delegated prefix (also known as a prefix lease) is not
        "owned" by a particular server.  Only a delegable prefix
        which is available is "owned" by a particular server --
        once it has been delegated (leased) to a client it becomes
        a prefix lease and is not owned by either failover partner.
        When it finally becomes available again, it will be owned
        initially by the primary server, and it may or may not be
        allocated to the secondary server by the primary server.</t>

        <t>The flow of a delegable prefix is as follows: initially
        the delegable prefix is part of a larger delegable prefix,
        all of which are initially owned by the primary server.
        A delegable prefix may be allocated to the secondary
        server and then it is owned by the secondary server.  Either
        server can allocate and delegate prefixes out of the delegable
        prefixes which they own.  Once these prefixes are delegated
        (leased) to clients, the servers cease to own them and
        they are owned by the clients to which they have been
        delegated (leased).  When the client releases the delegated
        prefix or the lease on it expires, it will again become
        available and will then be a delegable prefix and be owned
        by the primary.</t>

        <t>A server delegates prefixes only from its own pool of
        delegable prefixes in all states except for PARTNER-DOWN.
        In PARTNER-DOWN state the operational partner can delegate
        prefixes from either pool (both its own, and its partner's
        after some time constraints have elapsed).  The operational
        partner SHOULD allocate from its own pool before using its
        partner's pool.  The allocation and maintenance of these
        pools of delegable prefixes is important, since the goal
        is to maintain a more or less constant ratio of delegable
        prefixes between the two servers.</t>

        <t>The initial allocation of delegable prefixes from the
        primary to the secondary when the servers first integrate
        is triggered by the POOLREQ message from the secondary to
        the primary.  This is followed (at some point) by the
        POOLRESP message where the primary tells the secondary that
        it received and processed the POOLREQ message.  The primary
        sends the allocated delegable prefixes to the secondary as
        prefix leases via BNDUPD messages.  The POOLRESP message
        may be sent before, during, or at the completion of the
        BNDUPD message exchanges that were triggered by the POOLREQ
        message.  The POOLREQ/POOLRESP message exchange is a trigger
        to the primary to perform a scan of its database and to
        ensure that the secondary has enough delegable prefixes
        (based on some configured ratio).</t>

        <t>The delegable prefixes are sent to the secondary as
        prefix leases using the BNDUPD message containing an
        OPTION_IAPREFIX with a state of FREE-BACKUP, which indicates
        the prefix lease is now available for allocation by the
        secondary.  Once the message is sent, the primary MUST NOT
        use these prefixes for allocation to DHCP clients (except
        when the server is in PARTNER-DOWN state).</t>

        <t>The POOLREQ/POOLRESP message exchange initiated by the
        secondary is valid at any time both partners remain in
        contact, and the primary server SHOULD, whenever it receives
        the POOLREQ message, scan its database of delegable prefixes
        and determine if the secondary needs more delegable prefixes
        from any of the delegable prefixes which it currently owns.
        </t>

        <t>In order to support a reasonably dynamic balance of the
        leases between the failover partners, the primary server
        needs to do additional work to ensure that the secondary
        server has as many delegable prefixes as it needs (but
        that it doesn't have more than it needs).</t>

        <t>The primary server SHOULD examine the balance of delegable
        prefixes between the primary and secondary for a particular
        prefix whenever the number of possibly delegable prefixes
        for either the primary or secondary changes by more than a
        predetermined amount.  Typically this comparison would not
        involve actually comparing the count of existing instances
        of delegable prefixes, but would instead involve determining
        the number prefixes that could be delegated given the address
        ranges of the delegable prefixes allocated to each server.
        The primary server SHOULD adjust the delegable prefix balance
        as required to ensure the configured delegable prefix
        balance, excepting that the primary server SHOULD employ
        some threshold mechanism to such a balance adjustment in
        order to minimize the overhead of maintaining this balance.</t>

        <t>The primary server can, at any time, send an available
        delegable prefix to the secondary using a BNDUPD with the
        state FREE-BACKUP.  The primary server can attempt to take
        an available delegable prefix away from the secondary by
        sending a BNDUPD with the state FREE.  If the secondary
        accepts the BNDUPD, then the lease is now available to
        the primary and not available to the secondary.  Of course,
        the secondary MUST reject that BNDUPD if it has already
        allocated that lease to a DHCP client.</t>

        <section anchor="reallocation" title="Re-allocating Leases">

          <t>When in PARTNER-DOWN state there is a waiting period
          after which a delegated prefix can be re-allocated to
          another client.  For delegable prefixes which are "available"
          when the server enters PARTNER-DOWN state, the period is
          the MCLT from the entry into PARTNER-DOWN state.  For
          delegated prefixes which are not available when the server
          enters PARTNER-DOWN state, the period is the MCLT after
          the later of the following times: the acked-partner-lifetime,
          the partner-lifetime (if any), the expiration-time, and
          the entry to PARTNER-DOWN time plus the MCLT.</t>

          <!-- I don't think we want to discuss these paragraphs from the
           v4 draft.  Experience shows that nobody wants to live with MCLT
           restrictions in PARTNER-DOWN state.

          Two options exist for lease times given out while in PARTNER-DOWN
          state, with different ramifications flowing from each.

          If the server wishes the Failover protocol to protect it from loss of
          stable storage in PARTNER-DOWN state, then it should ensure that the
          MCLT based lease time restrictions in section 5.1 are maintained,
          even in PARTNER-DOWN state.

          If the server wishes to forego the protection of the Failover proto-
          col in the event of loss of stable storage, then it need recognize no
          restrictions on actual client lease times while in PARTNER-DOWN
          state.

          -->

          <t>In any other state, a server cannot reallocate a
          delegated prefix from one client to another without first
          notifying its partner (through a BNDUPD message) and
          receiving acknowledgement (through a BNDREPLY message) that
          its partner is aware that the first client is not using
          the lease.</t>

          <t>Specifically, an "available" delegable prefix on a
          server may be allocated to any client.  A prefix which
          was delegated (leased) to a client and which expired or
          was released by that client would take on a new state,
          EXPIRED or RELEASED respectively.  The partner server
          would then be notified that this delegated prefix was
          EXPIRED or RELEASED through a BNDUPD.  When the sending
          server received the BNDREPLY for that delegated prefix
          showing it was FREE, it would move the lease from
          EXPIRED or RELEASED to FREE, and it would be available
          for allocation by the primary server to any clients.</t>

          <t>A server MAY reallocate a delegated prefix in the
          EXPIRED or RELEASED state to the same client with no
          restrictions provided it has not sent a BNDUPD message
          regarding the delegated prefix to its partner.  This
          situation would exist if the prefix lease expired or was
          released after the transition into PARTNER-DOWN state,
          for instance.</t>

        </section>

      </section>

    </section> <!-- address allocation -->

    <section anchor="lazy-updates" title="Lazy Updates">

      <t>The DHCPv6 Failover Requirements document includes the
      requirement that failover must not introduce significant
      performance impact on server response times (see Sections 7
      and 5.2.2 of <xref target="RFC7031"/> ).  In order to realize
      this requirement a server implementing the failover protocol
      must be able respond to a DHCP client without waiting to
      update its failover partner whenever the binding database
      changes.  The lazy update mechanism allows a server to allocate
      a new lease or extend an existing lease, respond to the DHCP
      client, and then update its failover partner as time permits.
      </t>

      <t>Although the lazy update mechanism does not introduce
      additional delays in server response times, it introduces
      other difficulties.  The key problem with lazy update is that
      when a server fails after updating a DHCP client with a
      particular valid lifetime and before updating its failover partner,
      the failover partner will eventually believe that the client's
      lease has expired -- even though the DHCP client still
      retains a valid lease on that address or prefix.  It is also
      possible that the failover partner will have no record at all
      of the lease being assigned to the DHCP client.  Both of these
      issues are dealt with by use of the MCLT when allocating or
      extending leases (see <xref target="mclt"/>).
     </t>

    </section>

    <section anchor="mclt" title="Maximum Client Lead Time (MCLT)">
      <t>In order to handle problems introduced by lazy updates (see
      <xref target="lazy-updates"/>), a period of time known as the
      "Maximum Client Lead Time" (MCLT) is defined and must be known
      to both the primary and secondary servers.  Proper use of this
      time interval places an upper bound on the difference allowed
      between the valid lifetime provided to a DHCP client by a server and
      the valid lifetime known by that server's failover partner.
      </t>

      <t>The MCLT is typically much less than the valid lifetime that
      a server has been configured to offer a client, and so some
      strategy must exist to allow a server to offer the configured
      valid lifetime to a client.  During a lazy update the updating
      server updates its failover partner with a partner lifetime 
      which is longer than the valid lifetime previously given to the
      DHCP client and which is longer than the valid lifetime that the server
      has been configured to give a client.  This allows the server
      to give the configured valid lifetime to the client the next time
      the client renews its lease, since the time that it will give
      to the client will not be longer than the MCLT beyond the
      partner lifetime acknowledged by its partner or the current
      time.</t>

      <t>The fundamental relationship on which this protocol depends
      is: the lease expiration time known to a DHCP client MUST
      NOT be greater by more than the MCLT beyond the later of the
      partner lifetime acknowledged by that server's failover partner
      and the current time.</t>

      <t>The remainder of this section makes the above fundamental
      relationship more explicit.</t>

      <t>This protocol requires a DHCP server to deal with several
      different lease intervals and places specific restrictions on
      their relationships. The purpose of these restrictions is to
      allow the partner to be able to make certain
      assumptions in the absence of an ability to communicate between
      servers.</t>

      <t>
      In the following explanation, all of the lifetimes are "valid"
      lifetimes, in the context of <xref target="RFC3315"/>.
      </t>

      <t>The different times are:
      <list style="hanging">
        <t hangText="desired lifetime:">
          <vspace/>
          The desired lifetime is the lease interval that a
          DHCP server would like to give to a DHCP client in
          the absence of any restrictions imposed by the failover
          protocol.  Its determination is outside of the scope of
          this protocol. Typically this is the result of external
          configuration of a DHCP server.
        </t>

        <t hangText="actual lifetime:">
          <vspace/>
          The actual lifetime is the lease interval that a
          DHCP server gives out to a DHCP client.  It may be
          shorter than the desired lifetime (as explained
          below).
        </t>

        <t hangText="partner lifetime:">
          <vspace/>
          The partner lifetime is the lease
          expiration interval the local server tells to its partner
          in a BNDUPD message.
        </t>

        <t hangText="acknowledged partner lifetime:">
          <vspace/>
          The acknowledged partner lifetime is the partner 
          lifetime the partner server has most recently
          acknowledged in a BNDREPLY message.
        </t>

      </list>
      </t>

   <section title="MCLT example">
     <t>The following example demonstrates the MCLT concept in practice. The
     values used are arbitrarily chosen and are not a recommendation for
     actual values. The MCLT in this case is 1 hour.  The desired 
     lifetime is 3 days, and its renewal time is half the lifetime.</t>

     <t>When a server makes an offer for a new lease on an IPv6 address to a
     DHCP client, it determines the desired lifetime (in this
     case, 3 days).  It then examines the acknowledged partner 
     lifetime (which in this case is zero) and determines the remainder
     of the time left to run, which is also zero.  It adds the
     MCLT to this value.  Since the actual lifetime cannot be allowed to exceed
     the remainder of the current acknowledged partner lifetime
     plus the MCLT, the offer made to the client is for the remainder
     of the current acknowledged partner lifetime (i.e. zero)
     plus the MCLT.  Thus, the actual lifetime is 1 hour (the MCLT).</t>

     <t>Once the server has sent the REPLY to the DHCP client, it
     will update its failover partner with the lease information using
     a BNDUPD message.
     However, the desired partner lifetime will be composed of one
     half of the current actual lifetime added to the desired
     lifetime. Thus, the failover partner is updated with a
     BNDUPD with a partner lifetime of 1/2 hour + 3 days.</t>

     <t>When the primary server receives a BNDREPLY to its update of
     the secondary server's (partner's) partner lifetime,
     it records that as the acknowledged partner lifetime.
     A server MUST NOT send a BNDREPLY in response to a BNDUPD message
     until it is sure that the information in the BNDUPD message
     has been updated in its lease database.  See <xref
     target="acknowledging-reception"/>.  Thus, the primary server
     in this case can be sure that the secondary server has recorded
     the partner lease interval in its stable storage when the
     primary server receives a BNDREPLY message from the secondary
     server.</t>

     <t>When the DHCP client attempts to renew at T1 (approximately one
     half an hour from the start of the lease), the primary server
     again determines the desired lifetime, which is still 3
     days.  It then compares this with the original acknowledged
     partner lifetime (1/2 hour + 3 days) and adjusts for the
     time passed since the secondary was last updated (1/2 hour).  Thus
     the time remaining of the acknowledged partner interval is
     3 days.  Adding the MCLT to this yields 3 days plus 1 hour, which
     is more than the desired lifetime of 3 days.  So the client
     may have its lease renewed for the desired lifetime -- 3 days.</t>

     <t>When the primary DHCP server updates the secondary DHCP server
     after the DHCP client's renewal REPLY is complete, it will calculate
     the desired partner lifetime as the T1 fraction of the
     actual client lifetime (1/2 of 3 days this time = 1.5 days).
     To this it will add the desired client lifetime of 3 days,
     yielding a total desired partner lifetime of 4.5
     days.  In this way, the primary attempts to have the secondary
     always "lead" the client in its understanding of the client's
     lifetime so as to be able to always offer the client the
     desired client lifetime.</t>

     <t>Once the initial actual client lifetime of the MCLT is past,
     the protocol operates effectively like the DHCP protocol does
     today in its behavior concerning lifetimes. However, the
     guarantee that the actual client lifetime will never exceed
     the remaining acknowledged partner server partner lifetime by more
     than the MCLT allows full recovery from a variety of DHCP server failures.</t>
   </section>
   </section>

 </section>


<section title="Message and Option Definitions">

  <section anchor="msg-framing" title="Message Framing for TCP">

    <t> Failover communication is conducted over a TCP connection
    established between the partners. The protocol uses the framing
    format specified in Section 5.1 of <xref target="RFC5460">DHCPv6
    Bulk Leasequery</xref>, but uses different message types with
    a different message format, described in <xref target="msg-format"/>.
    The TCP connection between failover servers is made to a specific
    port, the dhcp-failover port, port 647.
    All information is sent over the connection as typical DHCP
    messages that convey DHCP options, following the format defined
    in Section 22.1 of <xref target="RFC3315"/>. 
    </t>

  </section>

  <section anchor="msg-format" title="Failover Message Format">

   <t>
   All Failover messages defined below share a common format with a
   fixed size header and a variable format area for options.  All
   values in the message header and in any included options are in 
   network byte order.
   </t>

   <t>
   The following diagram illustrates the format of DHCP messages exchanged
   between failover partners (which is compatible with the format described
   in Section 6 of <xref target="RFC3315"/>):
   </t>

   <figure>
   <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    msg-type   |               transaction-id                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           sent-time                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
   |                                                               . 
   .                            options                            .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   msg-type             Identifies the DHCP message type; the
                        available message types are listed below.
                        Note that since the TCP connection for
                        failover is made to a unique port, the
                        msg-type codes are allocated from a registry
                        distinct from the Dynamic Host Configuration
                        Protocol for IPv6 (DHCPv6) Message Types
                        registry.  

   transaction-id       The transaction ID for this message exchange.

   sent-time            The time the message was transmitted (set
                        as close to transmission as practical), 
                        in seconds since midnight (UTC), 
                        January 1, 2000, modulo 2^32.  Used to 
                        determine the time skew of the failover
                        partners.

   options              Options carried in this message.  These
                        options are all defined in the Dynamic Host
                        Configuration Protocol for IPv6 (DHCPv6)
                        Option Codes registry.  A number of existing
                        DHCPv6 options are used and several more
                        are defined in this document.
   </artwork> </figure>


  </section>

  <section anchor="msg-list" title="Messages">

    <t>
    The following list contains the new message types created for failover
    communication.
    </t>

    <section anchor="msg-bndupd" title="BNDUPD">
      <t> The binding update message BNDUPD (TBD1) is used to send
      the binding lease changes to the partner.  At most one
      OPTION_CLIENT_DATA option may appear in a BNDUPD message.
      Note that not all data in a BNDUPD is sent in an OPTION_CLIENT_DATA
      option. Information about delegable prefixes not currently
      allocated to a particular client is sent in BNDUPD messages
      but not within OPTION_CLIENT_DATA options.  The partner is
      expected to respond with a BNDREPLY message.</t>
    </section>

    <section anchor="msg-bndreply" title="BNDREPLY">
      <t> The binding acknowledgement message BNDREPLY (TBD2) is used
      for confirmation of the received BNDUPD message. It may contain
      a positive or negative response (e.g. due to detected lease
      conflict).  </t>
    </section>
      
    <section anchor="msg-poolreq" title="POOLREQ">
      <t>The Pool Request message POOLREQ (TBD3) is used by the
      secondary server to request allocation of delegable prefixes
      from the primary server. The primary responds
      with POOLRESP.</t>
    </section>

    <section anchor="msg-poolresp" title="POOLRESP">
      <t>The Pool Response POOLRESP (TBD4) message is used by the
      primary server to indicate that it has received the
      secondary's servers request to ensure that delegable prefixes
      are balanced between the primary and secondary servers.
      It does not indicate that all of the BNDUPDs that might be
      created from any rebalancing have been sent or responded
      to, it only indicates reception and acceptance of the
      task of ensuring the balance is examined and corrected
      as necessary.</t>
    </section>

    <section anchor="msg-updreq" title="UPDREQ">
      <t>The update request message UPDREQ (TBD5) is used by one
      server to request that its partner send all binding database
      changes that have not yet been confirmed. The partner is
      expected to respond with zero or more BNDUPD messages, followed
      by an UPDDONE message that signals that all of the BNDUPD
      messages have been sent and a corresponding BNDREPLY message
      has been received for each of them.</t>
    </section>

    <section anchor="msg-updreqall" title="UPDREQALL">
      <t>The update request all UPDREQALL (TBD6) is used by one
      server to request that all binding database information present
      in the other server be sent to the requesting server, in order
      to recover from a total loss of its binding database by the
      requesting server. A server receiving this request responds
      with zero or more BNDUPD messages, followed by an UPDDONE that
      signals that all of the BNDUPD messages have been sent and
      a corresponding BNDREPLY message has been received for each 
      of them.</t>
    </section>

    <section anchor="msg-upddone" title="UPDDONE">
      <t>The update done message UPDDONE (TBD7) is used by the server
      responding to an UPDREQ or UPDREQALL to indicate that all
      requested updates have been sent by the responding server and
      acked by the requesting server.</t>
    </section>

    <section anchor="msg-connect" title="CONNECT">
      <t>The connect message CONNECT (TBD8) is used by the primary
      server to establish a failover connection with the secondary
      server, and to transmit several important configuration attributes
      items between the servers. The partner is expected to confirm
      by responding with CONNECTREPLY message.</t>
    </section>

    <section anchor="msg-connectreply" title="CONNECTREPLY">
      <t>The connect acknowledgement message CONNECTREPLY (TBD9) is used by the
      secondary server to respond to a CONNECT message from the primary
      server.</t>
    </section>
      
    <section anchor="msg-disconnect" title="DISCONNECT">
      <t>The disconnect message DISCONNECT (TBD10) is used by either server when
      closing a connection and shutting down. No response is required for this
      message. The DISCONNECT message SHOULD contain an OPTION_STATUS_CODE option
      with an appropriate status. Often this will be ServerShuttingDown.  
      See <xref target="status-list"/>.  A server SHOULD include a descriptive
      message as to the reasons causing the disconnect message.</t>
    </section>
      
    <section anchor="msg-state" title="STATE">
      <t>The state message STATE (TBD11) is used by either server to inform its
      partner about a change of failover state. In some cases it may be used
      to also inform the partner about the current state, e.g. after connection
      is established in COMMUNICATIONS-INTERRUPTED or PARTNER-DOWN states.</t>
    </section>

    <section anchor="msg-contact" title="CONTACT">
      <t>
      The contact message CONTACT (TBD12) is used by either server
      to ensure that its partner continues to see the connection
      as operational.  It MUST be transmitted periodically over
      every established connection if other message traffic is not
      flowing, and it MAY be sent at any time. See <xref target="connection-parameters"/>.
      </t>

    </section>

  </section>

  <section anchor="transaction-id" title="Transaction Id">

    <t>
    The initiator of a message exchange MUST set the transaction-id.
    This means that all of the messages above except BNDREPLY, POOLRESP,
    UPDDONE, and CONNECTREPLY must set the tranasction-id.  The
    transaction-id MUST be unique among all currently outstanding
    messages sent to the failover partner.  A straightforward way
    to ensure this is to simply use an incrementing value, with one
    caveat.  The UPDREQ and UPDREQALL messages may be separated by
    a considerable time prior to the receipt of an UPDDONE message.
    While the usual pattern of message exchange would have the
    partner doing the vast majority of message initiation, it is
    remotely possible that the partner which initiated the UPDREQ
    or UPDREQALL messages might also send enough messages to wrap
    the 24-bit transaction-id and duplicate the transaction-id of the
    outstanding UPDREQ or UPDREQALL.  Thus, it is important
    to ensure that the transaction-id of a currently outstanding
    UPDREQ or UPDREQALL is not replicated in any message initiated
    prior to the receipt of the corresponding UPDDONE.
    </t>

  </section>

  <section anchor="option-list" title="Options">

    <t>
    The following new options are defined.
    </t>

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_binding_status"
             title="OPTION_F_BINDING_STATUS">
  
    <t>The binding-status represents an implementation independent representation
       of the status (or the state) of a lease on an IPv6 address or prefix.
   </t>
  
   <t>
   This is an unsigned byte.
   </t>
  
   <t>
   The code for this option is TBD13.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    OPTION_F_BINDING_STATUS    |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | binding-status|
   +-+-+-+-+-+-+-+-+
  
   option-code       OPTION_F_BINDING_STATUS (TBD13).
   option-len        1.
   binding-status    The binding-status.  See below.
   </artwork>
   </figure>

    <figure>
    <artwork>
   Value   binding-status
   -----   --------------
   0       reserved
   1       ACTIVE 
   2       EXPIRED 
   3       RELEASED
   4       PENDING-FREE
   5       FREE
   6       FREE-BACKUP
   7       ABANDONED
   8       RESET
    </artwork>
    </figure>

   <t>The binding-status values are discussed in <xref target="info-model"/></t>

   </section>


   <!-- ============================================================= -->
  
   <section anchor="option_f_connect_flags"
             title="OPTION_F_CONNECT_FLAGS">
  
   <t>
   Flags which indicate attributes of the connecting server.
   </t>
  
   <t>
   This consists of an unsigned 16 bit value in network byte order.
   </t>
  
   <t>
   The code for this option is TBD14.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    OPTION_F_CONNECT_FLAGS     |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             flags             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_CONNECT_FLAGS (TBD14).
   option-len        2.
   flags             flag bits, see below:
   </artwork>
   </figure>

   <figure>
   <artwork>
    0                   1          
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           MBZ               |F|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The bits (numbered from the least-significant bit in network
   byte-order) are used as follows:
 
   0-14:   MBZ
           Must be zero
   15 (F): FIXED_PD_LENGTH
           Set to 1 to indicate that all prefixes delegated from a
           given delegable prefix have the same prefix length (size).
           If this is not set, the prefixes delegated from one
           delegable prefix may have different sizes.
   </artwork>
   </figure>

   <t>If the FIXED_PD_LENGTH bit is not set, it indicates that 
   prefixes of a range of sizes can
   be delegated from a given delegable prefix.  Note that
   if the FIXED_PD_LENGTH bit is set, each delegable prefix may have
   its own fixed size -- this flag does not
   imply that all prefixes delegated will be the same size, rather
   that all prefixes delegated from the same delegable prefix will
   be the same size.
   </t>

   <t>If the FIXED_PD_LENGTH bit is set, the length used for each
   prefix is specified independent of this protocol, but must be
   known to both failover partners.  It might be specified in the
   configuration for each delegable prefix or it might be fixed for
   the entire server.  </t>
  
   </section>
 

   <!-- ============================================================= -->
  
   <section anchor="option_f_dns_removal_info"
             title="OPTION_F_DNS_REMOVAL_INFO">
  
   <t>This option contains the information necessary to remove a DNS
   name that was entered by the failover partner.
   </t>
  
   <t>
   The code for this option is TBD15.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_DNS_REMOVAL_INFO   |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      encapsulated-options                     |
   |                           (variable)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_DNS_REMOVAL_INFO (TBD15).
   option-len        variable
   sub-options       Three possible encapsulated options:
                     OPTION_F_DNS_HOST_NAME
                     OPTION_F_DNS_ZONE_NAME
                     OPTION_F_DNS_FLAGS
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_dns_host_name"
             title="OPTION_F_DNS_HOST_NAME">
  
   <t>
   Contains the host name that was entered into DNS by the failover partner.
   </t>
  
   <t>
      This is a DNS name encoded in <xref target="RFC1035"/> format
      as specified in Section 8 of
      <xref target="RFC3315"/>. 
   </t>
  
   <t>
   The code for this option is TBD16.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_DNS_HOST_NAME    |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               .
   .                                                               .
   .                           host-name                           .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_DNS_HOST_NAME (TBD16).
   option-len        length of host-name.
   host-name         RFC 1035 encoded host-name.
   </artwork>
   </figure>
  
   </section>
 
   <!-- ============================================================= -->
  
   <section anchor="option_f_dns_zone_name"
             title="OPTION_F_DNS_ZONE_NAME">
  
   <t>
   Contains the zone name that was entered into DNS by the failover partner.
   </t>
  
   <t>
      This is a DNS name encoded in <xref target="RFC1035"/> format
      as specified in Section 8 of
      <xref target="RFC3315"/>.
   </t>
  
   <t>
   The code for this option is TBD17.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_DNS_ZONE_NAME    |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               .
   .                                                               .
   .                           zone-name                           .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_DNS_ZONE_NAME (TBD17).
   option-len        length of zone-name.
   zone-name         RFC 1035 encoded zone name.
   </artwork>
   </figure>
  
   </section>
 

   <!-- ============================================================= -->
  
   <section anchor="option_f_dns_flags"
             title="OPTION_F_DNS_FLAGS">
  
   <t>
   Flags which indicate what needs to be done to remove this DNS name.  
   </t>
  
   <t>
   This consists of an unsigned 16 bit value in network byte order.
   </t>
  
   <t>
   The code for this option is TBD18.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       OPTION_F_DNS_FLAGS      |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             flags             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_DNS_FLAGS (TBD18).
   option-len        2.
   flags             flag bits, see below:
   </artwork>
   </figure>

   <figure>
   <artwork>
    0                   1          
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           MBZ         |U|S|R|F|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The bits (numbered from the least-significant bit in network
   byte-order) are used as follows:
 
   0-11:   MBZ
           Must be zero
   12 (U): USING_REQUESTED_FQDN
           Set to 1 to indicate that name used came from the 
           FQDN that was received from the client.
   13 (S): SYNTHESIZED_NAME
           Set to 1 to indicate that the name was synthesized
           based on some algorithm.
   14 (R): REV_UPTODATE
           Set to 1 to indicate that the reverse zone is up to date.
   15 (F): FWD_UPTODATE
           Set to 1 to indicate that the forward zone is up to date.
   </artwork>
   </figure>

   <t>If both the U and S bits are unset, then the name must have been
   provided from some alternative configuration, such as client registration
   in some database accessible to the DHCP server.
   </t>
  
   </section>
 

   <!-- ============================================================= -->
  
   <section anchor="option_f_expiration_time"
             title="OPTION_F_EXPIRATION_TIME">
  
    <t>The greatest lifetime that this server has ever acked to its
    partner in a BNDREPLY for a particular lease or prefix.
    This MUST be an absolute time (i.e. seconds since midnight 
    January 1, 2000 UTC, modulo 2^32). 
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD19.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_EXPIRATION_TIME    |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        expiration-time                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_EXPIRATION_TIME (TBD19).
   option-len        4.
   expiration-time   The expiration time. This MUST be an 
                     absolute time (i.e. seconds since midnight 
                     January 1, 2000 UTC, modulo 2^32). 

   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_max_unacked_bndupd"
             title="OPTION_F_MAX_UNACKED_BNDUPD">
  
   <t>
   The maximum number of BNDUPD messages that this server is prepared to
   accept over the TCP connection without causing the TCP connection to
   block.
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD20.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  OPTION_F_MAX_UNACKED_BNDUPD  |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       max-unacked-bndupd                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code        OPTION_F_MAX_UNACKED_BNDUPD (TBD20).
   option-len         4.
   max-unacked-bndupd Maximum number of unacked BNDUPD message 
                      allowed.
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_mclt"
             title="OPTION_F_MCLT">
  
   <t>The maximum-client-lead-time (MCLT) is the upper
   bound on the difference allowed between the valid lifetime provided to a
   DHCP client by a server and the valid lifetime known by that server's
   failover partner.  It is an interval, measured in seconds.
   See <xref target="mclt"/>.
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD21.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         OPTION_F_MCLT         |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              mclt                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_MCLT (TBD21).
   option-len        4.
   mclt              The maximum-client-lease-time, in seconds.
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_partner_lifetime"
             title="OPTION_F_PARTNER_LIFETIME">
  
   <t>
    The time after which the partner can consider an IPv6 address
    expired and is able to re-use the IPv6 address.  This MUST be an
    absolute time (i.e. seconds since midnight January 1, 2000 UTC,
    modulo 2^32).
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD22.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_PARTNER_LIFETIME   |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        partner-lifetime                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_PARTER_LIFETIME (TBD22).
   option-len        4.
   partner-lifetime  The partner-lifetime. This MUST be an 
                     absolute time (i.e. seconds since midnight 
                     January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_partner_lifetime_sent"
             title="OPTION_F_PARTNER_LIFETIME_SENT">
  
   <t>
    The time that was received in an OPTION_F_PARTNER_LIFETIME <xref
    target="option_f_partner_lifetime"/> option.  This is an exact
    duplicate (echo) of the time received in the OPTION_F_PARTNER_LIFETIME
    option, uncorrected and unadjusted in any way.  This MUST be
    an absolute time (i.e. seconds since midnight January 1, 2000
    UTC, modulo 2^32).
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD23.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |OPTION_F_PARTNER_LIFETIME_SENT |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      partner-lifetime-sent                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code            OPTION_F_PARTNER_LIFETIME_SENT (TBD23).
   option-len             4.
   partner-lifetime-sent  The partner-lifetime received in an
                          OPTION_F_PARTNER_LIFETIME option.
                          This MUST be an absolute time
                          (i.e. seconds since midnight 
                          January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_partner_down_time"
             title="OPTION_F_PARTNER_DOWN_TIME">
  
   <t>
    The time that the partner most recently lost communications
    with its failover partner.  This MUST be an absolute time (i.e.
    seconds since midnight January 1, 2000 UTC, modulo 2^32).
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD24.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_PARTNER_DOWN_TIME  |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       partner-down-time                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_PARTNER_DOWN_TIME (TBD24).
   option-len        4.
   partner-down-time Contains the partner-down-time. This MUST be an 
                     absolute time (i.e. seconds since midnight 
                     January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_partner_raw_clt_time"
             title="OPTION_F_PARTNER_RAW_CLT_TIME">
  
   <t>
    The time when the partner most recently interacted with the
    DHCP client associated with this IPv6 address or prefix.  This
    MUST be an absolute time (i.e. seconds since midnight January
    1, 2000 UTC, modulo 2^32).
   <!-- This time is uncorrected for clock skew,
    and remains in the time context of the partner server.-->
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD25.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | OPTION_F_PARTNER_RAW_CLT_TIME |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      partner-raw-clt-time                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code          OPTION_F_PARTNER_RAW_CLT_TIME (TBD25).
   option-len           4.
   partner-raw-clt-time Contains the partner-raw-clt-time. This MUST 
                        be an absolute time (i.e. seconds since 
                        midnight January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_protocol_version"
             title="OPTION_F_PROTOCOL_VERSION">
  
   <t>
   The protocol version allows one failover partner to determine
   the version of the protocol being used by the other partner, to allow
   for changes and upgrades in the future.  Two components are provided,
   to allow for large and small changes to be represented in one 32-bit
   number.  The intent is that large changes would result in an increment
   of the major-version, while small changes would result in an increment
   of the minor-version. As subsequent updates and extensions of this
   document can define changes to these values in any way deemed appropriate
   no attempt is made to further define large and small in this document.
   </t>
  
   <t>
   This consists of two unsigned 16-bit integers, in network byte order.
   </t>
  
   <t>
   The code for this option is TBD26.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_PROTOCOL_VERSION   |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
   |        major-version          |        minor-version          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_PROTOCOL_VERSION (TBD26).
   option-len        4.
   major-version     The major version of the protocol.  Initially 1.
   minor-version     The minor version of the protocol.  Initially 0.
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_keepalive_time"
             title="OPTION_F_KEEPALIVE_TIME">
  
   <t>
   The number of seconds (an interval) within which the server must
   receive a message from its partner, or it will assume that 
   communications from the partner is not ok.
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD27.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    OPTION_F_KEEPALIVE_TIME    |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         keepalive-time                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_KEEPALIVE_TIME (TBD27).
   option-len        4.
   receive-time      The keepalive-time.  An interval of seconds.
   </artwork>
   </figure>
  
   </section>

   <!-- ============================================================= -->
  
   <section anchor="option_f_reconfigure_data"
             title="OPTION_F_RECONFIGURE_DATA">
  
   <t>Contains the information necessary for one failover partner to
   use the reconfigure-key created on the other failover partner.</t>

   <t>
   The code for this option is TBD28.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_RECONFIGURE_DATA   |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        reconfigure-time                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               .
   .                                                               .
   .                        reconfigure-key                        .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_RECONFIGURE_DATA (TBD28).
   option-len        4 + length of reconfigure-key.
   reconfigure-time  Time at which reconfigure-key was created.
                     This MUST be an absolute time (i.e. seconds 
                     since midnight 
                     January 1, 2000 UTC, modulo 2^32). 
   reconfigure-key   The reconfigure-key.
   </artwork>
   </figure>
  
   </section>
 
 
   <!-- ============================================================= -->
  
   <section anchor="option_f_relationship_name"
             title="OPTION_F_RELATIONSHIP_NAME">
  
   <t>
   A name for this failover relationship.  Used to distinguish between
   relationships when there are multiple failover relationships between
   two failover servers.
   </t>
  
   <t>
   A UTF-8 encoded text string suitable for
   display to an end user, which MUST NOT be null-terminated.
   </t>
  
   <t>
   The code for this option is TBD29.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_RELATIONSHIP_NAME  |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               .
   .                                                               .
   .                       relationship-name                       .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_RELATIONSHIP_NAME (TBD29).
   option-len        length of relationship-name.
   relationship-name A UTF-8 encoded text string suitable for
                     display to an end user, which MUST NOT be
                     null-terminated.
   </artwork>
   </figure>
  
   </section>
 

   <!-- ============================================================= -->
  
   <section anchor="option_f_server_flags"
             title="OPTION_F_SERVER_FLAGS">
  
   <t>
   The OPTION_F_SERVER_FLAGS option specifies information
   associated with the failover endpoint sending the option.
   </t>

   <t>
   This is an unsigned byte.
   </t>
  
   <t>
   The code for this option is TBD30.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_SERVER_FLAGS     |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  server-flags |
   +-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_SERVER_FLAGS (TBD30).
   option-len        1.
   server-flags      The server flags, see below:
   </artwork>
   </figure>

   <figure>
   <artwork>
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |   MBZ   |A|S|C|
   +-+-+-+-+-+-+-+-+

   The bits (numbered from the least-significant bit in network
   byte-order) are used as follows:
 
   5 (A): ACK_STARTUP
          Set to 1 to indicate that the OPTION_F_SERVER_FLAGS most
          recently received contained the STARTUP bit set.
   6 (S): STARTUP,
          MUST be set to 1 whenever the server is in STARTUP state.
   7 (C): COMMUNICATED
          Set to 1 to indicate that the sending server has
          communicated with its partner. 
   0-3  : MBZ
          Must be zero
   </artwork>
   </figure>

  
   </section>
 
 
   <!-- ============================================================= -->
  
   <section anchor="option_f_server_state"
             title="OPTION_F_SERVER_STATE">
  
   <t>
   The OPTION_F_SERVER_STATE option specifies the endpoint state of
   the server sending the option.
   </t>

   <t>
   This is an unsigned byte.
   </t>
  
   <t>
   The code for this option is TBD31.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_SERVER_STATE     |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  server-state |
   +-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_SERVER_STATE (TBD31).
   option-len        1.
   server-state      Failover endpoint state.
   </artwork>
   </figure>

    <figure>
    <artwork>
   Value   Server State
   -----   ----------------------------------------------------------
   0       reserved
   1       STARTUP                Startup state (1)
   2       NORMAL                 Normal state
   3       COMMUNICATIONS-INTERRUPTED Communication interrupted 
   4       PARTNER-DOWN           Partner down 
   5       POTENTIAL-CONFLICT     Synchronizing
   6       RECOVER                Recovering bindings from partner
   7       SHUTDOWN               Shutting down for a long period.
   8       RECOVER-DONE           Interlock state prior to NORMAL
   9       RESOLUTION-INTERRUPTED Comm. failed during resolution
   10      CONFLICT-DONE          Primary resolved its conflicts
    </artwork>
    </figure>

    <t>
    These states are discussed in detail in <xref target="states"/>.
    </t>

    <t>
    (1) The STARTUP state is never sent to the partner server, it is
    indicated by the STARTUP bit in the server-flags options (see 
    <xref target="state-startup"/>).
    </t>

   </section>
 
 
   <!-- ============================================================= -->
  
   <section anchor="option_f_start_time_of_state"
             title="OPTION_F_START_TIME_OF_STATE">
  
    <t>The time at which the associated state began to hold its
       current value.  When this option appears in a STATE message,
       the state to which it refers is the server endpoint state.
       When it appears in an IA_NA-options, IA_TA-options, or
       IA_PD-options field , the state to which it refers is the
       binding-status value in the OPTION_IA_NA, OPTION_IA_TA, or
       OPTION_IA_PD option, respectively.  This MUST be an absolute
       time (i.e.  seconds since midnight January 1, 2000 UTC,
       modulo 2^32).
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD32.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  OPTION_F_START_TIME_OF_STATE |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      start-time-of-state                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code          OPTION_F_START_TIME_OF_STATE (TBD32).
   option-len           4.
   start-time-of-state  The start-time-of-state. This MUST be an 
                        absolute time (i.e. seconds since midnight 
                        January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_state_expiration_time"
             title="OPTION_F_STATE_EXPIRATION_TIME">
  
   <t>
    The state-expiration-time is the time at which the current state
    of this lease will expire. 
    This MUST be an absolute time (i.e. seconds since midnight 
    January 1, 2000 UTC, modulo 2^32). 
   </t>

   <t>Note that states other than ACTIVE may have a time associated with
   them.  In particular, EXPIRED might have a time associated with it, in the
   event that some sort of "grace period" existed where the lease would not
   be reused for a period after the lease expired.  The ABANDONED state might
   have a time associated with it, in the event that the servers participating
   in failover had a time after which an ABANDONED lease might be placed back
   into a pool for allocation to a client.  In general, if there is an
   OPTION_STATE_EXPIRATION_TIME associated with a particular state, that indicates
   the associated state will expire and move to a different state at that time.
   </t>
  
   <t>
   This is an unsigned 32-bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD33.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | OPTION_F_STATE_EXPIRATION_TIME|           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     state-expiration-time                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code            OPTION_F_STATE_EXPIRATION_TIME (TBD33).
   option-len             4.
   state-expiration-time  The state-expiration-time.  This MUST be an
                          absolute time (i.e. seconds since midnight 
                          January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>

   </section>

  <section anchor="status-list" title="Status Codes">


   <t>
      The following new status codes are defined, to be used in the
      OPTION_STATUS_CODE option.
   <list style="hanging">
   <!--
        <t hangText="OneClientDifferentLeases (TBD30)"> <vspace/>
           The client on one server has resources that conflict with the 
           resources that this client has on the other server.</t>
    -->
        <t hangText="AddressInUse (TBD34)"> <vspace/>
           One client on one server has leases that are in
           conflict with the leases that the client has on another
           server. Alternatively, the address could be associated with
           a different IAID on each server.</t>
        <t hangText="ConfigurationConflict (TBD35)"> <vspace/>
           The configuration implied by the information in a BNDUPD
           (e.g. the IPV6 address or prefix address)
           is in direct conflict with the information known to the
           receiving server.</t>
        <t hangText="MissingBindingInformation (TBD36)"> <vspace/>
           There is insufficient information in a BNDUPD to effectively
           process it.</t>
        <t hangText="OutdatedBindingInformation (TBD37)"> <vspace/>
           Returned when the information in a server's binding
           database conflicts with the information found in an incoming
           BNDUPD, and the server believes that the information in
           its binding database more accurately reflects reality.</t>
        <t hangText="ServerShuttingDown (TBD38)"> <vspace/>
           Returned when the server is undergoing an operator directed
           or otherwise planned shutdown.</t>
        <t hangText="DNSUpdateNotSupported (TBD39)"> <vspace/>
           Returned when a server receives a BNDUPD with DNS update
           information included, and the server doesn't support DNS
           update.</t>
   </list>
   </t>


  </section>


</section>



<section title="Connection Management">
  <section anchor="create-connections" title="Creating Connections">

    <t>Every primary server implementing the failover protocol MUST
    periodically attempt to create a TCP connection to the dhcp-failover
    port (647) of all of its configured partners, where the period
    is implementation dependent and SHOULD be configurable.  In the
    event that a connection has been rejected by a CONNECTREPLY message
    with a reject-reason option contained in it or a DISCONNECT
    message, a server SHOULD reduce the frequency with which it
    attempts to connect to that server but it MUST continue to
    attempt to connect periodically.</t>

    <t>Every secondary server implementing the failover protocol
    MUST listen for TCP connection attempts on the dhcp-failover
    port (647) from a primary server.</t>

    <t>After a primary server successfully establishes a TCP
    connection to a secondary server, it MUST continue the connection
    process as described in Section 8.2 of <xref target="RFC7653"/>.
    In the language of that section, the primary failover server
    operates as the "requestor" and the secondary failover server
    operates as the "DHCP server". The message that is sent over
    the newly established connection is a CONNECT message, instead
    of an ACTIVELEASEQUERY message.</t>

    <t>When a connection attempt is received by a secondary server,
    the only information that the secondary server has is the IP
    address of the partner initiating a connection.  If it has any
    relationships with the connecting server for which it is a
    secondary server, it should operate as described in Section 9.1
    of <xref target="RFC7653"/>, with the exception that instead
    of waiting for an Active Leasequery message it will wait for a
    CONNECT message.  Once it has received the CONNECT message, it
    will use the information in that message to determine which
    relationship this connection is to service.</t>
    
    <t>If it has no secondary relationships with the connecting
    server, it MUST drop the connection.  
    </t>

    <t>To summarize -- a primary server MUST use a connection that
    it has initiated in order to send a CONNECT message.  Every
    server that is a secondary server in a relationship MUST listen
    for CONNECT messages from the primary server.</t>

    <t>When the CONNECT and CONNECTREPLY exchange successfully produces
    a working failover connection, the next message sent over a new
    connection is a STATE message. See <xref target="send-state"/>.
    Upon the receipt of the STATE message, the receiver can consider
    communications ok.</t>


    <section anchor="send-connect" title="Sending a CONNECT message">

        <t>
          The CONNECT message is sent with information about the
          failover configuration on the primary server.  The
          message MUST contain at least the following information
          in the options area:
        <list style="symbols">
           <t>OPTION_F_PROTOCOL_VERSION containing the protocol version.</t>
           <t>OPTION_F_MCLT containing the configured MCLT.</t>
           <t>OPTION_F_KEEPALIVE_TIME containing the number of seconds 
              (an interval) within which the server must receive a
              message from its partner, or it will assume that
              communications from the partner is not ok.</t>
           <t>OPTION_F_UNACKED_BNDUPD containing the maximum number of 
              BNDUPD messages that this server is prepared to accept over 
              the failover connection without causing the
              connection to block.</t>
           <t>OPTION_F_RELATIONSHIP_NAME containing name of the failover
              relationship to which this connection applies.  If there
              is no OPTION_F_RELATIONSHIP_NAME in the CONNECT message,
              it indicates that there is only a single relationship
              between this pair of primary and secondary servers.</t>
	   <t>OPTION_F_CONNECT_FLAGS containing information about
	      certain attributes of the connecting servers.</t>
        </list>

      </t>

    </section>

    <section anchor="receive-connect" title="Receiving a CONNECT message">

    <t>
      A server receiving a CONNECT message must process the information in
      the message and decide whether or not to accept the connection.  The
      processing is performed as follows:
        <list style="symbols">
	   <t>OPTION_F_PROTOCOL_VERSION - The secondary server
	      decides if the protocol version of the primary server
	      is supported by the secondary server.  If it is not,
	      return NotSupported in the OPTION_STATUS_CODE to
	      reject the CONNECT message.</t>
           <t>OPTION_F_MCLT - Use this MCLT supplied by the primary
	      server.  Remember this MCLT and use it until a different
	      MCLT is supplied by some subsequent CONNECT message.</t>
	   <t>OPTION_F_KEEPALIVE_TIME - Remember the keepalive-time as
	      the FO_KEEPALIVE_TIME when implementing the Unreachability
	      Detection algorithm described in <xref
	      target="reachability"/>.</t>
           <t>OPTION_F_UNACKED_BNDUPD - Ensure that the maximum amount of
              unacked BNDUPD messages queued to the primary server never exceeds
              the value in the OPTION_F_UNACKED_BNDUPD option.</t>
	   <t>OPTION_F_CONNECT_FLAGS - Ensure that the secondary can process
	      information from the primary as specified in the flags.  For
	      example, if the secondary server cannot process prefix delegation
	      with variable sized prefixes delegated from the same delegable 
	      prefix, and the primary server says that it can, the secondary
	      should reject the connection.</t>
        </list>
        </t>

        <t>
        A CONNECT message SHOULD always be followed by a CONNECTREPLY
        message, either to accept the connection or to reject the
        connection by including an OPTION_STATUS_CODE option with
        an error reject.  In order to reject the connection attempt,
        simply send a CONNECTREPLY message with the OPTION_STATUS_CODE
        with the correct status.  If accepting the connection
        attempt, then send a CONNECTREPLY message with the following
        information:
        <list style="symbols">
	   <t>OPTION_F_PROTOCOL_VERSION containing the protocol
	      version being used by the secondary server.</t>
	   <t>OPTION_F_MCLT containing the MCLT currently in use
	      on the secondary server.  This MUST equal the MCLT
	      that was in the OPTION_F_MCLT option in the CONNECT.</t>
           <t>OPTION_F_KEEPALIVE_TIME containing the number of seconds 
              (an interval) within which the server must receive a
              message from its partner, or it will assume that
              communications from the partner is not ok.</t>
           <t>OPTION_F_UNACKED_BNDUPD containing the maximum number of 
              BNDUPD messages that this server is prepared to accept over 
              the failover connection without causing the
              connection to block.</t>
	   <t>OPTION_F_CONNECT_FLAGS - Place information into this
	      option to describe the attributes of the secondary server that the
	      primary needs to know about.</t>
        </list>
        After sending a CONNECTREPLY message to accept the primary server's
        CONNECT message, the secondary server MUST send a STATE message 
        (see <xref target="send-state"/>).
        </t>

    </section>

    <section anchor="receive-connectreply" 
             title="Receiving a CONNECTREPLY message">

      <t>
	A server receiving a CONNECTREPLY message must process the
	information in the message and decide whether or not to
	continue to employ the connection.  The processing is
	performed as follows:
        <list style="symbols">
           <t>OPTION_F_PROTOCOL_VERSION - The primary server decides if 
              the protocol version in use by the secondary server is supported 
              by the primary server.  If it
              is not, send a DISCONNECT message and drop the connection.  If it
              is supported, continue processing.</t>
           <t>OPTION_F_MCLT - Compare the MCLT received with the configured
              MCLT, and if they are different send a DISCONNECT message and drop
              the connection.</t>
	   <t>OPTION_F_KEEPALIVE_TIME - Remember the keepalive-time as
	      the FO_KEEPALIVE_TIME when implementing the Unreachability
	      Detection algorithm described in <xref
	      target="reachability"/>.</t>
           <t>OPTION_F_UNACKED_BNDUPD - Ensure that the maximum amount of
	      unacked BNDUPD messages queued to the secondary server
	      never exceeds the value in the OPTION_F_UNACKED_BNDUPD
	      option.</t>
	   <t>OPTION_F_CONNECT_FLAGS - Ensure that the primary can
	      process information from the secondary as specified
	      in the flags.  For example, if the primary server
	      cannot process prefix delegation with variable sized
	      prefixes delegated from the same delegable prefix,
	      and the secondary server says that it can, the primary
	      should drop the connection.</t>
	</list> After receiving a CONNECTREPLY message that accepted
	the primary server's CONNECT message, the primary server
	MUST send a STATE message (see <xref target="send-state"/>).
	</t>

    </section>

  </section>

  <section title="Endpoint Identification">

     <t>A failover endpoint is always associated with a set
    of DHCP prefixes that are configured on the DHCP server where
    the endpoint appears.  A DHCP prefix MUST NOT be associated with
    more than one failover endpoint.</t>

    <t>The failover protocol SHOULD be configured with one failover
    relationship between each pair of failover servers. In this
    case there is one failover endpoint for that relationship on
    each failover partner.  This failover relationship MUST have a
    unique name.</t>

    <t>Any failover endpoint can take actions and hold unique states.</t>

    <t>This document frequently describes the behavior of the protocol in
    terms of primary and secondary servers, not primary and secondary
    failover endpoints.  However, it is important to remember that every
    'server' described in this document is in reality a failover endpoint
    that resides in a particular process, and that several failover
    end-points may reside in the same server process.</t>

    <t>It is not the case that there is a unique failover endpoint
    for each prefix that participates in a failover relationship.
    On one server, there is (typically) one failover endpoint per
    partner, regardless of how many prefixes are managed by that
    combination of partner and role.  On a particular server, any
    given prefix that participates in failover will be associated
    with exactly one failover endpoint.</t>

    <t>When a connection is received from the partner, the unique failover
    endpoint to which the message is directed is determined solely by
    the IPv6 address of the partner, the relationship-name, and the role
    of the receiving server.</t>

  </section>

  <section title="Sending a STATE message" anchor="send-state">
    <t>
    A server MUST send a STATE message to its failover partner whenever
    the state of the failover endpoint changes.  Sending the occasional
    duplicate STATE message will cause no problems, and not updating
    the failover partner with information about a failover endpoint
    state change can, in many cases, cause the entire failover protocol
    to be inoperative.
    </t>

    <t>
      The STATE message is sent with information about the
      endpoint state of the failover relationship.  The STATE
      message MUST contain at least the following information
      in the options area:
    <list style="symbols">
       <t>OPTION_F_SERVER_STATE containing the state of this failover endpoint.</t>
       <t>OPTION_F_SERVER_FLAGS containing the flag values associated with this
          failover endpoint.</t>
       <t>OPTION_F_START_TIME_OF_STATE containing the time when this
          became the state of this failover endpoint.</t>
       <t>OPTION_F_PARTNER_DOWN_TIME containing time that this failover endpoint
          went into PARTNER-DOWN state if this server is in PARTNER-DOWN
          state.  If this server isn't in PARTNER-DOWN state, do not 
          include this option.</t>
    </list>
    The server sending a STATE message SHOULD ensure that this information is
    written to stable storage prior to enqueuing it to its failover partner.
    </t>

  </section>

  <section anchor="receive-state" title="Receiving a STATE message">

    <t>
      A server receiving a STATE message must process the information in
      the message and decide how to react to the information.  The 
      processing is performed as follows:
    <list style="symbols">
       <t>OPTION_F_SERVER_STATE - If this represents a change in state for
          the failover partner, react according to the direction in
          <xref target="state-machine-operation"/>.  If the state
          is not PARTNER-DOWN, clear any memory of the partner-down-time.</t>
       <t>OPTION_F_SERVER_FLAGS - Remember these flags in an appropriate
          data area so they can be referenced by code implementing
          other parts of this document.</t>
       <t>OPTION_F_START_TIME_OF_STATE - Remember this information
          in an appropriate data area.</t>
       <t>OPTION_F_PARTNER_DOWN_TIME - Remember this information in an
          appropriate data area if the value of the OPTION_F_SERVER_STATE
          is PARTNER-DOWN.</t>
    </list>
    A server receiving a STATE message SHOULD ensure that this information is
    written to stable storage.
    </t>

  </section>

 <section anchor="connection-parameters" title="Connection Maintenance Parameters">

    <t>
    The following parameters and timers are used to ensure the integrity
    of the connections between two failover servers.
    </t>

    <figure>
    <artwork>
   Parameter         Default   Description
   ------------------------------------------
   FO_KEEPALIVE_TIMER timer  counts down to time connection
                             assumed dead due to lack of messages

   FO_KEEPALIVE_TIME  60     maximum time server will consider
                             connection still up with no messages

   FO_CONTACT_PER_KEEPALIVE_TIME number of CONTACT messages to send 
                      4      during partner's FO_KEEPALIVE_TIME 
                             period

   FO_SEND_TIMER      timer  counts down to time to send next 
                             CONTACT message

   FO_SEND_TIME       15     maximum time to wait between sending
                             CONTACT messages if no other traffic
                             Created from partner's FO_KEEPALIVE_TIME
                             divided by FO_CONTACT_PER_KEEPALIVE_TIME
    </artwork>
    </figure>

 </section>

 <section anchor="reachability" title="Unreachability detection">
 
   <t>Each partner MUST maintain an FO_SEND_TIMER for each failover
   connection. The FO_SEND_TIMER for a particular connection is
   reset to FO_SEND_TIME every time any message is transmitted on
   that connection, and counts down once per second.  If the timer
   reaches zero, a CONTACT message is transmitted on that connection
   and the timer for that connection is reset to FO_SEND_TIME.  The
   CONTACT message may be transmitted at any time. An implementation
   MAY use additional mechanisms to detect partner unreachability.</t>

   <t> The FO_SEND_TIME is initialized from the configured
   FO_KEEPALIVE_TIME divided by FO_CONTACT_PER_KEEPALIVE_TIME.  When a
   CONNECT or CONNECTREPLY message is received on a connection, the
   received OPTION_F_KEEPALIVE_TIME option is checked, and the value
   in that option is used to calculate the FO_SEND_TIME for that
   connection by dividing the value received by the configured
   FO_CONTACT_PER_KEEPALIVE_TIME.  </t>

   <t> Each partner MUST maintain an FO_KEEPALIVE_TIMER for each
   failover connection.  This timer is initialized to FO_KEEPALIVE_TIME
   and counts down once per second.  It is reset to FO_KEEPALIVE_TIME
   whenever a message is received on that connection. If it ever
   reaches zero, that connection is considered dead.  In addition,
   the FO_KEEPALIVE_TIME for that connection MUST be sent to the
   failover partner on every CONNECT or CONNECTREPLY messages, in the
   OPTION_F_KEEPALIVE_TIME option.  </t>

 </section>


</section>



<section title="Binding Updates and Acks" anchor="bndupd">

  <section anchor="time-skew" title="Time Skew">

    <t>Partners exchange information about known lease states. To
    reliably compare a known lease state with an update received
    from a partner, servers must be able to reliably compare the
    times stored in the known lease state with the times received
    in the update.  The failover protocol adopts the simple approach 
    of requiring that the failover partners use some mechanism
    to synchronize the clocks on the two servers to within an 
    accuracy of roughly 5 seconds.</t>

    <t>
    A mechanism to measure and track relative time
    differences between servers is necessary to ensure this synchronization. 
    To do so, each message
    contains the time of the transmission in the time context of
    the transmitter in the sent-time field of the message (see
    <xref target="msg-format"/>).  The transmitting server MUST set this
    as close to the actual transmission as possible.  The receiving
    partner MUST store its own timestamp of reception as close to
    the actual reception as possible. The received timestamp
    information is then compared with local timestamp.  </t>

  </section>

  <section title="Information model" anchor="info-model">

  <t>In most DHCP servers a lease on an IPv6 address or a prefix can
  take on several different binding-status values, sometimes also
  called lease states.  While no two DHCP server implementations will have
  exactly the same possible binding-status values, <xref target="RFC3315"/>
  enforces some commonality among the general semantics of the
  binding-status values used by various DHCP server implementations.</t>

  <t> In order to transmit binding database updates between one
  server and another using the failover protocol, some common
  binding-status values must be defined.  It is not expected that
  these values correspond with any actual implementation of the
  DHCPv6 protocol in a DHCP server, but rather that the binding-status
  values defined in this document should be convertible back and
  forth between those defined below and those in use by many DHCP
  server implementations.  
  </t>

  <t>The lease binding-status values defined for the failover
  protocol are listed below. Unless otherwise noted below, there
  MAY be client information associated with each of these binding-status
  value.</t>

  <t>
  <list style="hanging">

    <t hangText="ACTIVE"> -- The lease is assigned to a client. Client
    identification data MUST appear.</t>

    <t hangText="EXPIRED"> -- indicates that a client's binding on a
    given lease has expired. When the partner acks the BNDUPD of an
    expired lease, the server sets its internal state to PENDING-FREE. Client
    identification SHOULD appear.</t>

    <t hangText="RELEASED"> -- indicates that a client sent a RELEASE
    message. When the partner acks the BNDUPD of a released lease,
    the server sets its internal state to PENDING-FREE. Client identification
    SHOULD appear.</t>

    <t hangText="PENDING-FREE"> -- Once a lease is expired or released, its
    state becomes PENDING-FREE. Depending on which algorithm and which pool
    was used to allocate a given lease, PENDING-FREE may either mean FREE or
    FREE-BACKUP. Implementations do not have to implement this PENDING-FREE
    state, but may choose to switch to the destination state directly.
    For clarity of representation, this transitional PENDING-FREE state is
    treated as a separate state. </t>

    <t hangText="FREE"> -- Is used when a DHCP server needs to
    communicate that a lease is unused by any client, but it
    was not just released, expired or reset by a network administrator.
    When the partner acks the BNDUPD of a FREE lease, the server
    marks the lease as available for assignment by the primary server.
    Note that on a secondary server running in PARTNER-DOWN state, after
    waiting the MCLT, the lease MAY be allocated to a client by the
    secondary server. Client identification MAY appear and indicates
    the last client to have used this lease as a hint.</t>

    <t hangText="FREE-BACKUP"> -- indicates that this lease can
    be allocated by the secondary server to a client at any time. Note
    that on the primary server running in PARTNER-DOWN state, after waiting
    the MCLT, the lease MAY be allocated to a client by the primary
    server if proportional algorithm was used. Client identification
    MAY appear and indicates the last client to have used this lease 
    as a hint.</t>

    <t hangText="ABANDONED"> -- indicates that a lease is considered
    unusable by the DHCP system. The primary reason for entering
    such state is reception of DECLINE message for the lease. Client 
    identification MAY appear.</t>

    <t hangText="RESET"> -- indicates that this lease was made
    available by operator command. This is a distinct state so that
    the reason that the lease became FREE can be determined.
    Client identification MAY appear.</t>

  </list>
  </t>

    <t>Which binding-status values are associated with a timeout
    is implementation dependent. Some binding-status values
    such as ACTIVE will have a timeout value in all implementations,
    while others such as ABANDONDED will have a timeout value in
    some implementations and not in others. In some implementations
    a binding-status value may be associated with a timeout in some
    circumstances and not in other circumstances.  The receipt of
    a BNDUPD with a particular binding-status value and an
    OPTION_F_STATE_EXPIRATION_TIME indicates that this particular
    binding-status value is associated with a timeout.  </t>


  <t>The lease state machine is presented in <xref
  target="lease-state-machine"/>. Most states are stationary, i.e. the lease
  stays in a given state until external event triggers transition to another
  state. The only transitive state is PENDING-FREE. Once it is reached, the state
  machine immediately transitions to either FREE or FREE-BACKUP state.</t>

  <figure anchor="lease-state-machine" title="Lease State Machine" align="center">
    <artwork><![CDATA[
                +---------+
 /------------->|  ACTIVE |<--------------\
 |              +---------+               |
 |                |  |  |                 |
 |       /--(8)--/  (3)  \--(9)-\         |
 |      |            |           |        |
 |      V            V           V        |
 |  +-------+   +--------+   +---------+  |
 |  |EXPIRED|   |RELEASED|   |ABANDONED|  |
 |  +-------+   +--------+   +---------+  |
 |      |            |            |       |
 |      |            |           (10)     |
 |      |            |            V       |
 |      |            |       +---------+  |
 |      |            |       |  RESET  |  |
 |      |            |       +---------+  |
 |      |            |            |       |
 |       \--(4)--\  (4)  /--(4)--/        |
 |                |  |  |                 |
(1)               V  V  V                (2)
 |              /---------\               |
 |              | PENDING |               |
 |              |  FREE   |               |
 |              \---------/               |
 |                 |   |                  |
 |         /-(5)--/     \-(6)-\           |
 |        |                    |          |
 |        V                    V          |
 |    +-------+         +-----------+     |
 \----|  FREE |<--(7)-->|FREE-BACKUP|-----/
      +-------+         +-----------+]]>
</artwork><postamble>PENDING-FREE transition</postamble></figure>

    <t>Transitions between states are results of the following events:

    <list style="empty">
      <t>1. Primary server allocates a lease.</t>

      <t>2. Secondary server allocates a lease.</t>

      <t>3. Client sends RELEASE and the lease is released.</t>

      <t>4. Partner acknowledges state change. This transition MAY also occur if the
      server is in PARTNER-DOWN state and the MCLT has passed since the entry into
      RELEASED, EXPIRED, or RESET states.</t>

      <t>5. The lease belongs to a pool that is governed by the proportional
      allocation, or independent allocation is used and this lease belongs to primary
      server pool.</t>

      <t>6. The lease belongs to a pool that is governed by the independent
      allocation and the lease belongs to the secondary server.</t>

      <t>7. Pool rebalance event occurs (POOLREQ/POOLRESP messages are
      exchanged). Delegable prefixes belonging to the primary
      server can be assigned to the secondary server pool (transition
      from FREE to FREE-BACKUP) or vice versa.  </t>

      <t>8. The lease has expired.</t>

      <t>9. DECLINE message is received or a lease is deemed
       unusable for other reasons.</t>

      <t>10. An administrative action is taken to recover an abandoned lease back to
      usable state. This transition MAY occur due to an implementation specific
      handling on ABANDONED lease. One possible example of such use is a
      Neighbor Discovery or ICMPv6 Echo check if the address is still in use.</t>
    </list>
    </t>

      <t>The lease that is no longer in use (due to expiration or release),
      becomes PENDING-FREE. Depending on what allocation algorithm is used, the lease  
      that is no longer is use, returns to the primary (FREE) or secondary pool
      (FREE-BACKUP). The conditions for specific transitions are depicted in
      <xref target="free-transition"/>.</t>

  <figure anchor="free-transition" title="PENDING-FREE State Transitions" align="center">
    <artwork><![CDATA[
+----------------+---------+-----------+
| \   Lease owner|         |           |
|  \----------\  | Primary | Secondary |
|Algorithm     \ |         |           |
+----------------+---------+-----------+
| Proportional   | FREE    |FREE-BACKUP| 
| Independent    | FREE    |    FREE   |
+----------------+---------+-----------+]]>
</artwork></figure>


  </section>


  <section anchor="time-bndupd" title="Times Required for Exchanging Binding Updates">
    <!-- tomek: here's the table from v4-failover-12, section 7.1:

                                        binding-status            BACKUP
                                                                  RESET
                                                                  ABANDONED
   Option                        ACTIVE     EXPIRED    RELEASED   FREE
   ======                        ======     =======    ========   ====
   assigned-IP-address (3)       MUST       MUST       MUST       MUST
   IP-flags                      MUST(4)    MUST(4)    MUST(4)    MUST(4)
   binding-status                MUST       MUST       MUST       MUST
   client-identifier             MAY        MAY        MAY        MAY(2)
   client-hardware-address       MUST       MUST       MUST       MAY(2)
   lease-expiration-time         MUST       MUST NOT   MUST NOT   MUST NOT
   potential-expiration-time     MUST       MUST NOT   MUST NOT   MUST NOT
   start-time-of-state           SHOULD     SHOULD     SHOULD     SHOULD
   client-last-trans.-time       MUST       SHOULD     MUST       MAY
   DDNS(1)                       SHOULD     SHOULD     SHOULD     SHOULD
   client-request-/soptions        SHOULD     SHOULD NOT SHOULD     SHOULD NOT
   client-reply-options          SHOULD     SHOULD NOT SHOULD NOT SHOULD NOT

   (1) MUST if server is performing dynamic DNS for this IP address, else
       MUST NOT.
   (2) MUST NOT if binding-status is ABANDONED.
   (3) assigned-IP-address MUST be the first option for an IP address
   (4) IP-flags option MUST appear if any flags are non-zero, else it
       MAY appear. -->


    <t>Each server must keep track of the following specific times beyond those
    required by the base DHCP protocol <xref target="RFC3315" />.  
    <list style="hanging">
        <t hangText="expiration-time"> <vspace/>
           The greatest lifetime that this server has ever acked
           to its failover partner in a BNDREPLY.</t>
        <t hangText="acked-partner-lifetime"> <vspace/>
           The greatest lifetime that the failover partner has ever
           acked to this server in a BNDREPLY.</t>
        <t hangText="partner-lifetime"> <vspace/>
           The time that we will send (or have sent) the partner,
           which will be the time after which the partner can
           consider the lease expired.  When we receive a BNDUPD this
           value can be updated from the received OPTION_F_EXPIRATION_TIME.</t>
        <t hangText="client-last-transaction-time"> <vspace/>
           The time when this server most recently interacted
           with the client associated with this lease.</t>
        <t hangText="partner-raw-clt-time"> <vspace/>
           The time when the partner most recently interacted with
           the client associated with this lease.  This time
           remains exactly as it was received by this server, and
           MUST NOT be adjusted to be in the time context of this
           server.</t>
        <t hangText="start-time-of-state"> <vspace/>
           The time when the binding-status of this lease was changed
           to its current value.</t>
        <t hangText="state-expiration-time"> <vspace/>
           The time when the current state of this lease will
           expire.</t>
    </list> </t>

  </section>

  <section anchor="send-bndupd" title="Sending Binding Updates">

    <t> Every BNDUPD message contains information about either a
    single client binding in an OPTION_CLIENT_DATA option that
    include IAADDR or IAPREFIX options associated with that client,
    or a single prefix lease in an OPTION_IAPREFIX option for
    prefixes that are currently not associated with any clients.
    </t>

    <t>All information about a particular client binding MUST be contained
       in a single OPTION_CLIENT_DATA option (see Section 4.1.2.2
       of <xref target="RFC5007"/>).  The OPTION_CLIENT_DATA option
       contains at least the data shown below in its client-options
       section:
    <list style="symbols">
       <t>OPTION_CLIENTID containing the DUID of the client most 
          recently associated with this lease MUST appear;</t>
       <t>OPTION_LQ_BASE_TIME containing the absolute time that the information
          was placed into this OPTION_CLIENT_DATA option
          (see Section 6.3.1 of <xref target="RFC7653"/>) MUST appear;
          </t>
       <t>OPTION_VSS (see Section 3.4 of <xref target="RFC6607"/>) This option
	  MUST NOT appear if the information in this OPTION_CLIENT_DATA
	  option is associated with the global, default VPN.  This
	  option MUST appear if the information in this OPTION_CLIENT_DATA
	  option is associated with a VPN other than the global,
	  default VPN.  Support of <xref target="RFC6607"/> is not
	  required, and OPTION_VSS is only used if a VPN other than
	  the global, default VPN is used, which requires support
	  of <xref target="RFC6607"/>;</t>
       <t>OPTION_F_RECONFIGURE_DATA
          containing the time and reconfigure key, if any;</t>
       <t>OPTION_LQ_RELAY_DATA containing information described 
          in Section 4.1.2.4 of <xref target="RFC5007" />, if any exists;</t>
       <t>OPTION_IA_NA or OPTION_IA_TA for an IPv6 Address or
          OPTION_IA_PD for an IPv6 Prefix. More
          than one of either of these options MAY appear if there
          are more than one associated with this client. At least one
	  MUST appear;
         <list style="symbols">
            <t>IAID - Identity Association used by the client, while obtaining 
            a given lease. (Note1: one client may use many IAIDs
            simultaneously. Note2: IAID for IA, TA and PD are orthogonal
            number spaces.);</t>
            <t>T1 time sent to client;</t>
            <t>T2 time sent to client;</t>
            <t>Inside of the IA_NA-options, IA_TA-options, or IA_PD-option sections:
            <list style="symbols">
               <t>
               OPTION_IAADDR for an IPv6 address or an OPTION_IAPREFIX for a IPv6 prefix MUST appear;
               <list style="symbols">
                  <t>IPv6 Address or IPv6 Prefix (with length);</t>
                  <t>preferred lifetime sent to client;</t>
                  <t>valid lifetime sent to client;</t>
                  <t>Inside of the IAaddr-options or IAprefix-options:
                  <list style="symbols">
                     <t>OPTION_F_BINDING_STATUS containing the binding-status
		        MUST appear;</t>
                     <t>OPTION_F_START_TIME_OF_STATE containing the 
                        start-time-of-state MUST appear;</t>
                     <t>OPTION_F_STATE_EXPIRATION_TIME (absolute) containing the 
                        state-expiration-time*;</t>
                     <t>OPTION_CLT_TIME (relative) containing the 
                        client-last-transaction-time.  See <xref target="RFC5007" /> 
                        for this option;</t> 
                     <t>OPTION_F_PARTNER_LIFETIME (absolute) containing 
                        partner-lifetime*;</t>
                     <t>OPTION_F_PARTNER_RAW_CLT_TIME (absolute) 
                        containing the partner-raw-clt-time;</t>
                     <t>OPTION_F_EXPIRATION_TIME (absolute) 
                        containing the expiration-time*;</t>
                     <t>DHCP_O_CLIENT_FQDN 
                        containing the FQDN information associated with
                        this lease and client, if any;</t>
                  </list></t>
               </list></t>
            </list></t>
         </list></t>
    </list></t>

    <t>Information about a prefix lease is contained in a single
       OPTION_IAPREFIX option.  Only a single OPTION_IAPREFIX 
       option may appear in a BNDUPD message outside of an OPTION_CLIENT_DATA 
       option.  In detail:
        <list style="symbols">
           <t>
           OPTION_IAPREFIX for a prefix lease;
           <list style="symbols">
              <t>IPv6 Prefix (with length);</t>
              <t>Inside of the IAprefix-options section:
              <list style="symbols">
		 <t>OPTION_VSS (see Section 3.4 of <xref target="RFC6607"/>) 
		    This option MUST NOT appear if the information
		    in this OPTION_IAPREFIX option is associated
		    with the global, default VPN.  This option MUST
		    appear if the information in this OPTION_IAPREFIX
		    option is associated with a VPN other than the
		    global, default VPN.  Support of <xref
		    target="RFC6607"/> is not required, and OPTION_VSS
		    is only used if a VPN other than the global,
		    default VPN is used, which requires support of
		    <xref target="RFC6607"/>;</t>
                 <t>OPTION_LQ_BASE_TIME containing the absolute time that this information
                    was placed into this OPTIONS_IAPREFIX option
                    (see Section 6.3.1 of <xref target="RFC7653"/>)
		    MUST appear;</t>
                 <t>OPTION_F_BINDING_STATUS containing the binding-status
		    MUST appear;</t>
                 <t>OPTION_F_START_TIME_OF_STATE containing the 
                    start-time-of-state MUST appear;</t>
                 <t>OPTION_F_STATE_EXPIRATION_TIME (absolute) containing the 
                    state-expiration-time*;</t>
                 <t>OPTION_F_PARTNER_LIFETIME (absolute) containing 
                    partner-lifetime*;</t>
                 <t>OPTION_F_EXPIRATION_TIME (absolute) 
                    containing the expiration-time*;</t>
              </list></t>
           </list></t>
        </list></t>



<!--    Note that additonal data MAY be included beyond that listed above.  The
    IAaddr_options or IAprefix-options area are the places where additional information
    should be included.
    </t>
-->

    <t>Items marked with a single asterisk (*) MUST appear only
    if the value in the OPTION_F_BINDING_STATUS is associated with
    a timeout, otherwise it MUST NOT appear. See <xref target="info-model"/>
    for details.</t>

   <t>The OPTION_CLT_TIME MUST, if it appears, be the time that the
   server last interacted with the DHCP client.  It MUST NOT be,
   for instance, the time that the lease expired if there has been
   no interaction with the DHCP client in question.</t>

    <t> A server SHOULD be prepared to clean up DNS information
    once the lease expires or is released. See <xref target="dns-update"/>
    for a detailed discussion about DNS update. Another reason the
    partner may be interested in keeping additional data is to
    enable better support for Leasequery <xref target="RFC5007"/>,
    Bulk Leasequery <xref target="RFC5460"/> or Active Leasequery
    <xref target="RFC7653"/>, some of which feature queries based
    on Relay-ID, by link address and by Remote-ID.</t>

  </section> <!-- sending binnding updates -->

  <section title="Receiving Binding Updates">

  <section anchor="monitoring-time-skew" title="Monitoring Time Skew">

      <t>The sent-time from the Failover message is compared with the
         current time of the receiving server as recorded when it received
         the message.  The difference is noted,
         and if it is greater than 5 seconds the receiving server SHOULD
         drop the connection.</t>

       <t>Any time can be
          before, after, or essentially the same as another time.  Any time
          which ends up being +/- 5 seconds of another time SHOULD be considered
          to be representing the same time when performing a comparison between
          two times.</t>

 </section>

    <section anchor="acknowledging-reception" title="Acknowledging Reception">

      <t>Upon acceptance of a binding update, the server MUST notify
      its partner that it has processed the binding update (and
      updated its lease state database if necessary) by sending a
      BNDREPLY. A server MUST NOT send the BNDREPLY before its binding
      database is updated. </t>

    </section>


  <section anchor="processing-binding-updates" title="Processing Binding Updates">

      <t>When a BNDUPD is received it MUST contain either a single
      OPTION_CLIENT_DATA option or a single OPTION_IAPREFIX option.</t>

      <t>When analyzing an BNDUPD message option from a partner
      server, if there is insufficient information in the BNDUPD
      message to process it, then it is rejected with an
      OPTION_STATUS_CODE of "MissingBindingInformation".</t>

      <t>The server receiving a BNDUPD update from its partner must
      evaluate the received information in each OPTION_CLIENT_DATA
      or IAPREFIX option to see if it is consistent with the server's
      already known state, and if it is not, decide which information
      - that previously known or that just received - is "better".
      If the information in the BNDUPD is "better", the receiving
      server will accept the information in the BNDUPD.  If the
      information in the server's binding database is "better", the
      server will reject the information in the BNDUPD.</t>

      <t> A server receiving a BNDUPD message MUST respond to the
      sender of that message with a BNDREPLY message which contains
      the same transaction-id as the BNDUPD message.  This BNDREPLY
      message MUST contain either a single OPTION_CLIENT_DATA option
      or a single OPTION_IAPREFIX option, corresponding to whatever
      was received in the BNDUPD message.</t>

     <t>An OPTION_CLIENT_DATA option or an OPTION_IAPREFIX option
     in the BNDREPLY which is accepted SHOULD NOT contain an
     OPTION_STATUS_CODE unless a status message needs to be sent
     to the failover partner, in which case it SHOULD include an
     OPTION_STATUS_CODE option with a status code indicating success
     and whatever message is needed.</t>

     <t>To indicate rejection of the information in an OPTION_CLIENT_DATA
     option, or an OPTION_IAPREFIX option, an OPTION_STATUS_CODE
     SHOULD be included with a status code indicating an error in
     the OPTION_CLIENT_DATA option or OPTION_IAPREFIX option in the
     BNDREPLY message.</t>

 </section>

  <section anchor="accept-or-reject" title="Accept or Reject?">

      <t>The first task in processing the information in an
      OPTION_CLIENT_DATA option or OPTION_IAPREFIX option is extract
      the client information (if any) and lease information out of
      the option, and to access the address lease or prefix lease
      information in the server's binding database.</t>

      <t>If an OPTION_VSS option is specified in the OPTION_CLIENT_DATA
      option or OPTION_IAPREFIX option, if the VPN specified in the
      OPTION_VSS option does not appear in the configuration of the
      receiving server, reject the entire OPTION_CLIENT_DATA option
      or OPTION_IAPREFIX option with the reject-reason
      "ConfigurationConflict".</t>

      <t>If the lease specified in the OPTION_CLIENT_DATA option
      or OPTION_IAPREFIX option is not a lease associated with the
      failover endpoint which received the OPTION_CLIENT_DATA option,
      then reject it with reject-reason "ConfigurationConflict".</t>

      <t>In general, acceptance or rejection is based around the
      comparison of two different time values, one from the
      OPTION_CLIENT_DATA option or OPTION_IAPREFIX option in the
      BNDUPD message, and one from the receiving server's binding
      database associated with the address or prefix lease found
      in the BNDUPD message.  The time for the BNDUPD message where
      the OPTION_F_BINDING_STATUS is ACTIVE, EXPIRED, or RELEASED
      is the OPTION_CLT_TIME if one appears, and the
      OPTION_F_START_TIME_OF_STATE if one does not.  For other
      binding-status values, the time for the BNDUPD message is the
      later of the OPTION_CLT_TIME if one appears, and the
      OPTION_F_START_TIME_OF_STATE.  The time for the lease in the
      server's binding database is the client-last-transaction-time,
      if one appears, and the start-time-of-state if one does
      not.</t>

      <t>The basic approach is to compare these times, and if the
      one from the BNDUPD message is clearly later, then accept the
      information in the OPTION_CLIENT_DATA option or OPTION_IAPREFIX
      option.  If the one from the server's binding database is
      clearly later, then reject the information in the BNDUPD
      message.  The challenge comes when they are essentially the
      same (i.e., +/- 5 seconds).  In this case they are considered
      identical, despite the minor differences.  The table below (<xref
      target="tbl-conflict-resolution"/>) contains the rules for
      dealing with all of these situations.
   </t>

  <figure anchor="tbl-conflict-resolution" title="Conflict Resolution">
    <artwork><![CDATA[
                       binding-status in received OPTION_CLIENT_DATA
                                                  or OPTION_IAPREFIX
binding-status in
receiving server's                                 FREE        RESET
lease state DB   ACTIVE   EXPIRED   RELEASED   FREE-BACKUP  ABANDONED

ACTIVE           accept(3) time(1)   accept     time(1)      accept
EXPIRED          accept    accept    accept     accept       accept
RELEASED         accept    accept    accept     accept       accept
FREE/FREE-BACKUP accept    accept    accept     accept       accept
RESET            time(2)   accept    accept     accept       accept
ABANDONED        accept    accept    accept     accept       accept
]]></artwork></figure>

    <t>accept: If the time value in the OPTION_CLIENT_DATA option
    or OPTION_IAPREFIX option is later than the time value in the
    server's binding database, accept it, else reject it.</t>

    <t>time(1): If the current time is later than the receiving server's
    state-expiration-time, accept it, else reject it.</t>

    <t>time(2): If the OPTION_CLT_TIME value (if it appears) in the
    OPTION_CLIENT_DATA is later than the start-time-of-state in the
    receiving server's binding, accept it, else reject it.</t>

    <t>accept,time(1),time(2): If rejecting, use reject reason
    "OutdatedBindingInformation".</t>

    <t>accept(3): If the client in an OPTION_CLIENT_DATA option and in a
    receiving server's binding differ, then if time(2) or the
    receiving server is a secondary accept it, else reject it with
    a reject reason of "AddressInUse". If the clients match,
    accept the update.</t>

      <t>The lease update may be accepted or rejected.  If a lease
      is rejected with "OutdatedBindingInformation", then the flag
      in the lease that indicates the partner should be updated
      about the information in this lease SHOULD be set, otherwise
      it SHOULD NOT be changed.  If this flag was previously not
      set, then an update MAY be transmitted immediately to the
      partner (though the BNDREPLY to this BNDUPD SHOULD be sent
      first). If this flag was previously set an update SHOULD NOT
      be transmitted immediately to the partner.  In this case, an
      update will be sent during the next periodic scan, but not
      immediately, thus preventing a possible update storm should
      the servers be unable to agree.  Ultimately, the server with
      the most recent binding information should have its update
      accepted by its partner.</t>
      
    <!-- <t>Discussion: There will definitely be different types of update
      rejections. For example, this will allow a server to treat differently a
      case when receiving a new lease that it previously haven't seen than a
      case when partner sents old version of a lease for which a newer state is
      known.</t>-->
    </section>

    <section anchor="accepting-updates" title="Accepting Updates">

       <t>When the information in an OPTION_CLIENT_DATA option or
          OPTION_IAPREFIX option has been accepted, some of that
          information is stored in the receiving server's binding
          database, and corresponding a OPTION_CLIENT_DATA option
          or OPTION_IAPREFIX option is entered into a BNDREPLY.  The
          information to enter into the OPTION_CLIENT_DATA option
          or OPTION_IAPREFIX option in the BNDREPLY is described in
          <xref target="send-bndreply"/>.</t>

       <t>The information contained in an accepted OPTION_CLIENT_DATA option
       is stored in the receiving server's binding database as follows:
       <list style="numbers">
          <t>The OPTION_CLIENTID is used to find the client.</t>
          <t>The other data contained in the top level of the OPTION_CLIENT_DATA
             option is stored with the client as appropriate.</t>
          <t>For each of the OPTION_IA_NA, OPTION_IA_TA, or
             OPTION_IA_PD option in the OPTION_CLIENT_DATA option
             and for each of the OPTION_IAADDR or OPTION_IAPREFIX
             options in the IA_* options:
             <list style="numbers">
                <t>OPTION_F_BINDING_STATUS is stored as the binding-status</t>
                <t>OPTION_F_PARTNER_LIFETIME is stored in the 
                   expiration-time</t>
                <t>OPTION_F_STATE_EXPIRATION_TIME is stored in the
                   state-expiration-time</t>
                <t>OPTION_F_CLT_TIME (which MUST NOT be converted with the
                   corrected-base-time, but MUST be converted with the raw
                   value from the OPTION_LQ_BASE_TIME) is stored
                   in the partner-raw-clt-time</t>
                <t>OPTION_F_PARTNER_RAW_CLT_TIME (which MUST NOT be corrected with
                   the time-correction)
                   replaces the client-last-transaction-time if it is later
                   than the current client-last-transaction-time.</t>
                <t>OPTION_F_EXPIRATION_TIME replaces the partner-lifetime
                   if it is later than the current partner-lifetime.</t>
          </list></t>
       </list></t>

       <t>The information contained in an accepted top level
       OPTION_IAPREFIX option is stored in the receiving server's
       binding database as follows:
       <list style="numbers">
          <t>The IPv6 Prefix is used to find the prefix.</t>
          <t>Inside of the IAprefix-options section:
             <list style="numbers">
                <t>OPTION_F_BINDING_STATUS is stored as the binding-status</t>
                <t>OPTION_F_PARTNER_LIFETIME (if any) is stored in the 
                   expiration-time</t>
                <t>OPTION_F_STATE_EXPIRATION_TIME (if any) is stored in the
                   state-expiration-time</t>
                <t>OPTION_F_EXPIRATION_TIME (if any) replaces the partner-lifetime
                   if it is later than the current partner-lifetime.</t>
          </list></t>
       </list></t>

    </section>

  </section>

  <section anchor="send-bndreply" title="Sending Binding Replies">

     <t>A server MUST respond to every BNDUPD message with a BNDREPLY
        message.  The BNDREPLY message MUST contain an OPTION_CLIENT_DATA
        option if the BNDUPD message contained an OPTION_CLIENT_DATA
        option, or it MUST contain an OPTION_IAPREFIX option if
        the BNDUPD message contained an OPTION_IAPREFIX option. The
        BNDREPLY message MUST have the same transaction-id as the
        BNDUPD message to which it is a response.</t>
        
     <t>Acceptance or rejection of all or a particular part of the
	BNDUPD message is signaled with a OPTION_STATUS_CODE option.
	An OPTION_STATUS_CODE option containing a status-code
	representing an error is significant, while an OPTION_STATUS_CODE
	option whose status-code contains success is considered
	informational but does not affect the processing of the
	BNDREPLY message when it is received by the server that sent
	the BNDUPD message.</t>

     <t>Rejection of all or part of the information in a BNDUPD message
        is signaled in a BNDREPLY message by use of the OPTION_STATUS_CODE
        message with an error in the status-code field.  This rejection
        can take place at either of two levels -- the top level of
	the option hierarchy, or the bottom level of the option hierarchy:
        <list style="number">

	  <t>Entire BNDUPD: The OPTION_STATUS_CODE containing an
	  error is present in the outermost option of the BNDREPLY
	  -- either the single OPTION_CLIENT_DATA option or the
	  single OPTION_IAPREFIX option.  An example of this sort
	  of error might be that a VSS option was present and
	  specified a VPN that might not exist in the receiving
	  server.</t>

	  <t>Single address or prefix: The OPTION_STATUS_CODE
	  containing an error is present in a single IAADDR or
	  IAPREFIX option which is itself contained in an OPTION_IA_NA,
	  OPTION_IA_TA, or OPTION_IA_PD option.  An example of this
	  sort of error might be that a particular IPv6 address was
	  specified in an IAADDR option that doesn't appear in the
	  receiving server's configuration.</t>

        </list>
	Rejection present at either of these levels indicates
	rejection of all of the information contained in the option
	(including any other options contained in that option) where
	the OPTION_STATUS_CODE option containing an error appears.
	The converse is not true -- an OPTION_STATUS_CODE option
	containing success does not signify that all of the contained
	information has been accepted.</t>

     <t>If the BNDREPLY message contains an OPTION_CLIENT_DATA option, then
        the OPTION_CLIENT_DATA option MUST contain at least the
        data shown below in its client-options section:
    <list style="symbols">
       <t>OPTION_CLIENTID containing the DUID of the client most 
          recently associated with this IPv6 address*;</t>
       <t>OPTION_VSS from the BNDUPD, if any.</t>
       <t>OPTION_IA_NA or OPTION_IA_TA for an IPv6 Address or
          OPTION_IA_PD for an IPv6 Prefix. More
          than one of either of these options MAY appear if there
          are more than one associated with this client;
         <list style="symbols">
            <t>Inside of the IA_NA-options, IA_TA-options, or IA_PD-option sections:
            <list style="symbols">
               <t>
               OPTION_IAADDR for an IPv6 address or an OPTION_IAPREFIX for a IPv6 prefix;
               <list style="symbols">
                  <t>IPv6 Address or IPv6 Prefix (with length);</t>
                  <t>Inside of the IAaddr-options or IAprefix-options:
                  <list style="symbols">
                     <t>OPTION_STATUS_CODE containing an error code, or
                        containing a success code if a message is required.
			An OPTION_STATUS_CODE option SHOULD NOT appear with
			a success code unless a message associated with
			the success code needs to be included.  The lack
			of an OPTION_STATUS_CODE option is an indication
			of success.</t>
                     <t>OPTION_F_BINDING_STATUS containing the binding-status received
                        in the BNDUPD;</t>
                     <t>OPTION_F_STATE_EXPIRATION_TIME (absolute) containing the 
                        state-expiration-time received in the BNDUPD;</t>
                     <t>OPTION_F_PARTNER_LIFETIME_SENT (absolute) containing 
                        a duplicate of the OPTION_F_PARTNER_LIFETIME received
                        in the BNDUPD;</t>
                  </list></t>
               </list></t>
            </list></t>
         </list></t>
    </list></t>

     <t>If the BNDREPLY message contains a top level OPTION_IAPREFIX option, then
        the OPTION_IAPREFIX option MUST contain at least the
        data shown below:
       <list style="symbols">
          <t>IPv6 Prefix (with length);</t>
          <t>IAprefix-options:
          <list style="symbols">
	     <t>OPTION_VSS from the BNDUPD, if any.</t>
             <t>OPTION_STATUS_CODE containing an error code, or
                containing a success code if a message is required.
                If the information in the corresponding OPTION_IAPREFIX
                in the BNDUPD was accepted, and no status message was
                required (which is the usual case), no OPTION_STATUS_CODE 
                option appears.</t>
             <t>OPTION_F_BINDING_STATUS containing the binding-status received
                in the BNDREPLY;</t>
             <t>OPTION_F_STATE_EXPIRATION_TIME (absolute) containing the 
                state-expiration-time received in the BNDREPLY;</t>
             <t>OPTION_F_PARTNER_LIFETIME_SENT (absolute) containing 
                a duplicate of the OPTION_F_PARTNER_LIFETIME received
                in the BNDREPLY;</t>
          </list></t>
       </list></t>

  </section>

  <section anchor="receive-bndreply" title="Receiving Binding Acks">


     <t>When a BNDREPLY is received the overall OPTION_CLIENT_DATA
        option or the overall OPTION_IAPREFIX option may contain
        an OPTION_STATUS_CODE containing an error, representing a
        rejection of the entire BNDUPD. An enclosed OPTION_IA_NA,
        OPTION_IA_TA, or OPTION_IA_PD option may also contain an
        OPTION_STATUS_CODE containing an error which indicates that
        everything in containing option has been rejected.  Or an individual
        IAADDR or IAPREFIX option may contain an OPTION_STATUS_CODE
        option containing an error, indicating that the IAADDR or
        IAPREFIX option has been rejected.  An OPTION_STATUS_CODE
        containing a success code has no bearing on the acceptance
        status of the BNDREPLY at any level.</t>
     
     <t>Receipt of a rejection (or a part of a BNDREPLY that has been
        rejected) requires no processing other than remembering 
	that it has been encountered.
     </t>

     <t>The information contained in the BNDREPLY in an OPTION_CLIENT_DATA
        that represents an acceptance is stored with the appropriate client
        and lease, as follows:
       <list style="numbers">
          <t>The OPTION_CLIENTID is used to find the client.</t>
          <t>For each of the OPTION_IA_NA, OPTION_IA_TA, or OPTION_IA_PD 
             option in the OPTION_CLIENT_DATA option and for each of the 
             OPTION_IAADDR or OPTION_IAPREFIX options they contain:
             <list style="numbers">
                <t>OPTION_F_PARTNER_LIFETIME_SENT is stored in the 
                   acked-partner-lifetime</t>
                <t>The time partner-lifetime is set to 0, to indicate that
                   nothing additional needs to be sent to the partner.</t>
          </list></t>
       </list></t>

       <t>Alternatively, the BNDREPLY may contain a top level
       OPTION_IAPREFIX option, representing information concerning
       a single prefix lease.  If the IAprefix-options section of
       the OPTION_IAPREFIX option contains an OPTION_STATUS_CODE
       representing an error, then it is considered a rejection of
       the corresponding BNDUPD message.  If the OPTION_IAPREFIX
       option does not contain an OPTION_STATUS_CODE option or if
       the OPTION_STATUS_CODE option contains a success status,
       then the three items in the following list are stored in the
       lease state database, in the section associated with the
       prefix lease represented by the OPTION_IAPREFIX option.
      <list style="numbers">
         <t>OPTION_F_BINDING_STATUS containing the binding-status received
            in the BNDREPLY;</t>
         <t>OPTION_F_STATE_EXPIRATION_TIME (absolute) containing the 
            state-expiration-time received in the BNDREPLY;</t>
         <t>OPTION_F_PARTNER_LIFETIME_SENT (absolute) containing 
            a duplicate of the OPTION_F_PARTNER_LIFETIME received
            in the BNDREPLY;</t>
      </list></t>

  </section>



    <section anchor="bndupd-data" title="BNDUPD/BNDREPLY Data Flow">

    <t>
      The following diagram shows the relationship of the times
      described in <xref target="time-bndupd"/> with the options
      used to transmit them.  It also relates the times on one
      failover partner to the other failover partner.
    </t>


  <figure anchor="bndupd-time-diagram" title="BNDUPD and BNDREPLY Time Handling" align="center">
    <artwork><![CDATA[
----------------------- BNDUPD ------------------------------

  Source on            OPTION_F in            Storage on
 Sending Server  ->   BNDUPD message   ->   Receiving Server


                                  [ always update ]

partner-lifetime      PARTNER_LIFETIME      expiration-time      

client-last-transaction-time  CLT_TIME      (uncorrected)    
                                            partner-raw-clt-time
start-time-of-state   START_TIME_OF_STATE   start-time-of-state
state-expiration-time STATE_EXPIRATION_TIME state-expiration-time

                           [update only if received > current]

expiration-time       EXPIRATION_TIME       partner-lifetime 
partner-raw-clt-time  PARTNER_RAW_CLT_TIME  
                                       client-last-transaction-time

----------------------- BNDREPLY ------------------------------

  Storage on            OPTION_F in           Storage on
 Receiving Server <-   BNDUPD message   <-   Sending Server

        [ always update ]

acked-partner-lifetime PARTNER_LIFETIME_SENT duplicate of received
                                               PARTNER_LIFETIME
(nothing to update)    STATE_EXPIRATION_TIME state-expiration-time

-------------------------------------------------------------
]]>
</artwork></figure>

    </section>

</section>



<section anchor="states" title="Endpoint States">
    <section anchor="state-machine-operation" title="State Machine Operation">

      <t>Each server (or, more accurately, failover endpoint) can take
      on a variety of failover states.  These states play a crucial role
      in determining the actions that a server will perform when
      processing a request from a DHCP client as well as dealing with
      changing external conditions (e.g., loss of connection to a failover
      partner).</t>

      <t> The failover state in which a server is running controls the following
      behaviors: </t>
        <t><list style="symbols">

          <t>Responsiveness -- the server is either responsive to DHCP
          client requests, it is renew responsive,  or it is unresponsive.</t>

          <t>Allocation Pool -- which pool of addresses (or prefixes) can be
          used for advertisement on receipt of a SOLICIT or allocation on receipt
          of a REQUEST, RENEW or REBIND message.</t>

          <t>MCLT -- ensure that valid lifetimes are not beyond what the partner
          has acked plus the MCLT (or not).</t>

        </list></t>

      <t>A server will transition from one failover state to another based
      on the specific values held by the following state variables:</t>

        <t><list style="symbols">

          <t>Current failover state.</t>

          <t>Communications status (OK or not OK).</t>

          <t>Partner's failover state (if known).</t>

        </list></t>

      <t>Whenever any of the above state variables change state,
      the state machine is invoked, which may then trigger a change
      in the current failover state.  Thus, whenever the communications
      status changes, the state machine processing is invoked.  This
      may or may not result in a change in the current failover
      state.</t>

      <t>Whenever a server transitions to a new failover state, the
      new state MUST be communicated to its failover partner in a
      STATE message if the communications status is OK.  In addition,
      whenever a server makes a transition into a new state, it
      MUST record the new state, its current understanding of its
      partner's state, and the time at which it entered the new
      state in stable storage.</t>

      <t>The following state transition diagram gives a condensed view of the
      state machine.  If there is a difference between the words describing a
      particular state and the diagram below, the words should be considered
      authoritative.</t>

      <t>In the diagram below, the word (responsive) (r-responsive) or 
      (unresponsive) appears in the states, and refers to whether the 
      server in this state is allowed to responsive, renew responsive, or
      unresponsive respectively.</t>

      <t>In the state transition diagram below, the "+", "-", or "*" in the upper
      right corner of each state is a notation about whether communication is
      ongoing with the other server, with "+" meaning that communications are
      ok, "-" meaning communications are interrupted, and "*" meaning that communications
      may be ok or interrupted.

      <!-- that's an ugly hack: add couple extra lines here, so the diagram
      ends on a new page -->
      <vspace blankLines="8"/>
      </t>

    <figure anchor="endpoint-state-machine" title="Failover Endpoint State Machine">
    <artwork>
    <![CDATA[
    +---------------+  V  +--------------+
    |    RECOVER  * |  |  |   STARTUP  - |
    |(unresponsive) |  +->+(unresponsive)|
    +------+--------+     +--------------+
    +-Comm. OK             +-----------------+
    |     Other State:     |  PARTNER DOWN - +<---------------------+
    |    RESOLUTION-INTER. | (responsive)    |                      ^
   All     POTENTIAL-      +----+------------+                      |
  Others   CONFLICT------------ | --------+                         |
    |      CONFLICT-DONE     Comm. OK     |     +--------------+    |
 UPDREQ or                 Other State:   |  +--+ RESOLUTION - |    |
 UPDREQALL                  |       |     |  |  | INTERRUPTED  |    |
 Rcv UPDDONE             RECOVER    All   |  |  | (responsive) |    |
    |  +---------------+    |      Others |  |  +------+-----+-+    |
    +->+RECOVER-WAIT * | RECOVER    |     |  |         ^     |      |
       |(unresponsive) |  WAIT or   |     |  Comm.     |    Ext.    |
       +-----------+---+  DONE      |     |  OK     Comm.   Cmd---->+
Comm.---+     Wait MCLT     |       V     V  V     Failed           |
Changed |          V    +---+   +---+-----+--+-+       |            |
 |  +---+----------++   |       |  POTENTIAL + +-------+            |
 |  |RECOVER-DONE * |  Wait     |  CONFLICT    +------+             |
 +->+(unresponsive) |  for      |(unresponsive)|   Primary          |
    +------+--------+  Other  +>+----+--------++   resolve    Comm. |
     Comm. OK          State: |      |        ^    conflict  Changed|
+---Other State:-+   RECOVER  |   Secondary   |       V       V   | |
|    |           |     DONE   |    resolve    |  +----+-------+--++ |
| All Others:  POTENT.  |     |   conflict    |  |CONFLICT-DONE * |
| Wait for    CONFLICT--|-----+      |        |  | (responsive)   | |
| Other State:          V            V        |  +-------+--------+ |
| NORMAL or RECOVER    ++------------+---+    | Other State: NORMAL |
|    |       DONE      |     NORMAL    + +<--------------+          |
|    +--+----------+-->+ pri: responsive +-------External Command-->+
|       ^          ^   |sec: r-responsive|                          |
|       |          |   +--------+--------+                          |
|       |          |            |             |                     |
|   Wait for   Comm. OK  Comm. Failed         |             External
|    Other      Other           |             |             Command
|    State:     State:     Start Auto         |                or
| RECOVER-DONE  NORMAL    Partner Down     Comm. OK           Auto 
|       |     COMM. INT.      Timer       Other State:       Partner
|    Comm. OK.     |            V          All Others         Down
|   Other State:   |  +---------+--------+    |            expiration
|     RECOVER      +--+ COMMUNICATIONS - +----+                     |
|       +-------------+   INTERRUPTED    |                          |
RECOVER               |  (responsive)    +------------------------->+
RECOVER-WAIT--------->+------------------+
]]></artwork></figure>

    </section> <!-- state-machine-operation -->

    <section anchor="state-init" title="State Machine Initialization">

      <t>The state machine is characterized by storage (in stable storage) of at least the
      following information:</t>

        <t><list style="symbols">

          <t>Current failover state.</t>

          <t>Previous failover state.</t>

          <t>Start time of current failover state.</t>

          <t>Partner's failover state.</t>

          <t>Start time of partner's failover state.</t>

          <t>Time most recent message received from partner.</t>

        </list></t>

      <t>The state machine is initialized by reading these data items
      from stable storage and restoring their values from the information
      saved.  If there is no information in stable storage concerning these
      items, then they should be initialized as follows:</t>

        <t><list style="symbols">

          <t>Current failover state:  Primary: PARTNER-DOWN, Secondary: RECOVER</t>

          <t>Previous failover state:  None.</t>

          <t>Start time of current failover state: Current time.</t>

          <t>Partner's failover state: None until reception of STATE message.</t>

          <t>Start time of partner's failover state: 
          None until reception of STATE message.</t>

          <t>Time most recent message received from partner: 
          None until message received.</t>

        </list></t>

    </section>

    <section anchor="state-startup" title="STARTUP State">

      <t>The STARTUP state affords an opportunity for a server to
      probe its partner server, before starting to service DHCP
      clients.  When in the STARTUP state, a server attempts to
      learn its partner's state and determine (using that information
      if it is available) what state it should enter.</t>

      <t>The STARTUP state is not shown with any specific state
      transitions in the <xref target="endpoint-state-machine">state machine
      diagram</xref> because the processing during the STARTUP state
      can cause the server to transition to any of the other states,
      so that specific state transition arcs would only obscure
      other information.</t>

      <section anchor="operation-in-startup-state" title="Operation in STARTUP State">

        <t>The server MUST NOT be responsive to DHCP clients in STARTUP state.</t>

        <t>Whenever a STATE message is sent to the partner while
        in STARTUP state the STARTUP flag MUST be set in the message
        and the previously recorded failover state MUST be placed
        in the server-state option.</t>

      </section> <!-- operation-in-startup-state -->

      <section anchor="transition-out-of-startup-state" title="Transition Out of STARTUP State">

        <t>The following algorithm is followed every time the
        server initializes itself, and enters STARTUP state.</t>

        <t>The variables PREVIOUS-STATE and CURRENT-STATE are defined
        for use in the algorithm description below. PREVIOUS-STATE
        is simply for storage of a state, while CURRENT-STATE not
        only stores the current state but also changes the current
        state of the failover endpoint to whatever state is set
        into the CURRENT-STATE.</t>

        <t>Step 1:</t>

        <t>If there is any record in stable storage of a previous
        failover state for this server, set PREVIOUS-STATE to the
        last recorded value in stable storage, and go to Step 2.</t>

        <t>If there is no record of any previous failover state in
        stable storage for this server, then set the PREVIOUS-STATE
        to RECOVER and set the TIME-OF-FAILURE to 0.  This will
        allow two servers which already have lease information to
        synchronize themselves prior to operating.</t>

        <t>In some cases, an existing server will be commissioned
        as a failover server and brought back into operation where
        its partner is not yet available.  In this case, the newly
        commissioned failover server will not operate until its
        partner comes online  -- but it has operational responsibilities
        as a DHCP server nonetheless.  To properly handle this
        situation, a server SHOULD be configurable in such a way
        as to move directly into PARTNER-DOWN state after the startup
        period expires if it has been unable to contact its partner
        during the startup period.</t>

        <t>Step 2:</t>

        <t>Implementations will differ in the ways that they deal
        with the state machine for failover endpoint states.  In
        many cases, state transitions will occur when communications
        goes from "OK" to failed, or from failed to "OK", and some
        implementations will implement a portion of their state
        machine processing based on these changes.</t>
        
        <t>In these cases, during startup, if the PREVIOUS-STATE
        is one where communications was "OK", then set the PREVIOUS-STATE
        to the state that is the result of the communications
        failed state transition when in that state (if such transition
        exists -- some states don't have a communication failed
        state transition, since they allow both communications OK
        and failed).</t>

        <t>Step 3:</t>

        <t>Start the STARTUP state timer.  The time that a server
        remains in the STARTUP state (absent any communications
        with its partner) is implementation dependent but SHOULD
        be short.  It SHOULD be long enough for a TCP connection
        to be created to a heavily loaded partner across a slow
        network.</t>

        <t>Step 4:</t>

        <t>If the server is a primary server: attempt to create a 
           TCP connection to the failover partner.  If the server is
           a secondary server, listen on the failover port and wait
           for the primary server to connect.  See 
           <xref target="create-connections"/>.</t>  

        <t>Step 5:</t>

        <t>Wait for "communications OK".</t>

        <t>When and if communications become "OK", clear the STARTUP
        flag, and set the CURRENT-STATE to the PREVIOUS-STATE.</t>

        <t>If the partner is in PARTNER-DOWN state, and if the time
        at which it entered PARTNER-DOWN state (as received in the
        start-time-of-state option in the STATE message) is later
        than the last recorded time of operation of this server,
        then set CURRENT-STATE to RECOVER.  If the time at which
        it entered PARTNER-DOWN state is earlier than the last
        recorded time of operation of this server, then set
        CURRENT-STATE to POTENTIAL-CONFLICT.</t>

        <t>Then, transition to the CURRENT-STATE and take the
        "communications OK" state transition based on the CURRENT-STATE
        of this server and the partner.</t>

        <t>Step 6:</t>

        <t>If the startup time expires prior to communications 
           becoming "OK", the server SHOULD transition
        to the PREVIOUS-STATE.</t>

      </section> <!-- transition-out-of-startup-state -->

    </section> <!-- end of STARTUP state -->

    <section anchor="state-partner-down" title="PARTNER-DOWN State">

    <t>PARTNER-DOWN state is a state either server can enter.  When
    in this state, the server assumes that it is the only server
    operating and serving the client base. If one server is in
    PARTNER-DOWN state, the other server MUST NOT be operating.</t>

    <t>A server can enter PARTNER-DOWN state either as a result of
    operator intervention (when an operator determines that the
    server's partner is, indeed, down), or as a result of an optional
    auto-partner-down capability where PARTNER-DOWN state is entered
    automatically after a server has been in COMMUNICATIONS-INTERRUPTED
    state for a pre-determined period of time.</t>

      <section anchor="operation-in-partner-down-state" title="Operation in PARTNER-DOWN State">

        <t>The server MUST be responsive in PARTNER-DOWN state, regardless
        if it is primary or secondary.</t>

        <t>It will allow renewal of all outstanding leases.</t>

        <t>
        For delegable prefixes it will allocate leases
        from its own pool, and after a fixed period of time (the
        MCLT interval) has elapsed from entry into PARTNER-DOWN
        state, it may allocate delegable prefixes from the set of all
        available pools. Server MUST fully deplete its own pool,
        before starting allocations from its downed partner's pool.</t>

        <t>IPv6 addresses available for independent allocation by
        the other server (at entry to PARTNER-DOWN state) SHOULD
        NOT be allocated to a client.  If one elects to do so anyway,
        they MUST NOT be allocated to a new client until the MCLT
        beyond the entry into PARTNER-DOWN state has elapsed.</t>

        <t>A server in PARTNER-DOWN state MUST NOT allocate a lease
        to a DHCP client different from that to which it was
        allocated at the entrance to PARTNER-DOWN state until the
        MCLT beyond the maximum of the following
        times: client expiration time, most recently transmitted
        partner-lifetime, most recently received ack of the
        partner-time from the partner, and most recently
        acked partner-lifetime to the partner.  <!-- tomek:
        commented out as don't have section about BNDUPD message yet.
        See section 7.1.5 for details. --> If this time would be earlier
        than the current time plus the MCLT, then
        the time the server entered PARTNER-DOWN state plus the
        MCLT is used.</t>

        <t>The server is not restricted by the MCLT when offering
        valid lifetimes while in PARTNER-DOWN state.</t>

        <t>In the unlikely case when there are two servers operating
        in a PARTNER-DOWN state, there is a chance of duplicate
        leases for the same prefix to be assigned. This leads to a
        POTENTIAL-CONFLICT (unresponsive) state when they re-establish
        contact. The duplicate lease issue can be postponed to a
        large extent by the server granting new leases first from
        its own pool. Therefore the server operating in PARTNER-DOWN
        state MUST use its own pool first for new leases before
        assigning any leases from its downed partner pool.  </t>

      </section> <!-- operation-in-partner-down-state -->

      <section anchor="transition-out-of-partner-down-state" title="Transition Out of PARTNER-DOWN State">

        <t>When a server in PARTNER-DOWN state succeeds in establishing
        a connection to its partner, its actions are conditional
        on the state and flags received in the STATE message from
        the other server as part of the process of establishing the
        connection.</t>

        <t>If the STARTUP bit is set in the server-flags option of
        a received STATE message, a server in PARTNER-DOWN state
        MUST NOT take any state transitions based on reestablishing
        communications. If a server is in PARTNER-DOWN
        state, it ignores all STATE messages from its partner that
        have the STARTUP bit set in the server-flags option of the
        STATE message.</t>

        <t>If the STARTUP bit is not set in the server-flags option
        of a STATE message received from its partner, then a server
        in PARTNER-DOWN state takes the following actions based on
        the state of the partner as received in a STATE message
        (either immediately after establishing communications or
        at any time later when a new state is received)</t>

        <t><list style="symbols">

        <t>If the partner is in: [ NORMAL, COMMUNICATIONS-INTERRUPTED, PARTNER-DOWN,
        POTENTIAL-CONFLICT, RESOLUTION-INTERRUPTED, or CONFLICT-DONE ]
        state, then transition to POTENTIAL-CONFLICT state</t>

        <t>If the partner is in: [ RECOVER, RECOVER-WAIT ] state stay in PARTNER-DOWN state</t>

        <t>If the partner is in: [ RECOVER-DONE ] state transition into NORMAL state</t>

        </list></t>

      </section> <!-- transition-out-of-partner-down-state -->

    </section> <!-- end of partner-down state -->

    <section anchor="state-recover" title="RECOVER State">

      <t>This state indicates that the server has no information
      in its stable storage or that it is re-integrating with a
      server in PARTNER-DOWN state after it has been down.  A server
      in this state MUST attempt to refresh its stable storage from
      the other server.</t>

      <section anchor="operation-in-recover-state" title="Operation in RECOVER State">

        <t>The server MUST NOT be responsive in RECOVER state.</t>

        <t>A server in RECOVER state will attempt to reestablish
        communications with the other server.</t>

      </section> <!-- operation-in-recover-state -->

      <section anchor="transition-out-of-recover-state" title="Transition Out of RECOVER State">

        <t>If the other server is in POTENTIAL-CONFLICT,
        RESOLUTION-INTERRUPTED, or CONFLICT-DONE state when
        communications are reestablished, then the server in RECOVER
        state will move to POTENTIAL-CONFLICT state itself.</t>

        <t>If the other server is in any other state, then the
        server in RECOVER state will request an update of missing
        binding information by sending an UPDREQ message.  If the
        server has determined that it has lost its stable storage
        because it has no record of ever having talked to its
        partner, while its partner does have a record of communicating
        with it, it MUST send an UPDREQALL message, otherwise it
        MUST send an UPDREQ message.</t>

        <t>It will wait for an UPDDONE message, and upon receipt
        of that message it will transition to RECOVER-WAIT state.</t>

        <t>If communication fails during the reception of the
        results of the UPDREQ or UPDREQALL message, the server will
        remain in RECOVER state, and will re-issue the UPDREQ or
        UPDREQALL when communications are re-established.</t>

        <t>If an UPDDONE message isn't received within an implementation
        dependent amount of time, and no BNDUPD messages are being
        received, the connection SHOULD be dropped.</t>

        <figure anchor="figure-transition-out-of-recover-state" title="Transition out of RECOVER state">
        <artwork><![CDATA[
                A                                        B
              Server                                  Server

                |                                        |
             RECOVER                               PARTNER-DOWN
                |                                        |
                | >--UPDREQ-------------------->         |
                |                                        |
                |        <---------------------BNDUPD--< |
                | >--BNDREPLY------------------>         |
               ...                                      ...
                |                                        |
                |        <---------------------BNDUPD--< |
                | >--BNDREPLY------------------>         |
                |                                        |
                |        <--------------------UPDDONE--< |
                |                                        |
           RECOVER-WAIT                                  |
                |                                        |
                | >--STATE-(RECOVER-WAIT)------>         |
                |                                        |
                |                                        |
       Wait MCLT from last known                         |
          time of failover operation                     |
                |                                        |
           RECOVER-DONE                                  |
                |                                        |
                | >--STATE-(RECOVER-DONE)------>         |
                |                                     NORMAL
                |        <-------------(NORMAL)-STATE--< |
             NORMAL                                      |
                | >---- State-(NORMAL)--------------->   |
                |                                        |
                |                                        |
        ]]></artwork></figure>


        <t>If at any time while a server is in RECOVER state
        communication fails, the server will stay in RECOVER state.
        When communications are restored, it will restart the process
        of transitioning out of RECOVER state.</t>

      </section> <!-- transition-out-of-recover-state -->

    </section> <!-- end of recover state -->

    <section anchor="state-recover-wait" title="RECOVER-WAIT State">

      <t>This state indicates that the server has sent an UPDREQ
      or UPDREQALL and has received the UPDDONE message indicating
      that it has received all outstanding binding update information.
      In the RECOVER-WAIT state the server will wait for the MCLT
      in order to ensure that any processing that this server might
      have done prior to losing its stable storage will not cause
      future difficulties.</t>

      <section anchor="operation-in-recover-wait-state" title="Operation in RECOVER-WAIT State">

        <t>The server MUST NOT be responsive in RECOVER-WAIT state.</t>

      </section> <!-- operation-in-recover-wait-state -->

      <section anchor="transition-out-of-recover-wait-state" title="Transition Out of RECOVER-WAIT State">

        <t>Upon entry to RECOVER-WAIT state the server MUST start
        a timer whose expiration is set to a time equal to the time
        the server went down (if known) or the time the server
        started (if the down-time is unknown) plus the
        maximum-client-lead-time.  When this timer expires, the
        server will transition into RECOVER-DONE state.</t>

	<t>This is to allow any IPv6 addresses or prefixes that
	were allocated by this server prior to loss of its client
	binding information in stable storage to contact the other
	server or to time out.</t>

        <t>If the server has never before run failover, then there
        is no need to wait in this state and the server MAY transition
        immediately to RECOVER_DONE state. However, to determine
        if this server has run failover it is vital that the
        information provided by the partner be utilized, since the
        stable storage of this server may have been lost.</t>

        <t>If communication fails while a server is in RECOVER-WAIT
        state, it has no effect on the operation of this state.
        The server SHOULD continue to operate its timer, and if the
        timer expires during the period where communications with
        the other server have failed, then the server SHOULD
        transition to RECOVER-DONE state.  This is rare -- failover
        state transitions are not usually made while communications
        are interrupted, but in this case there is no reason to
        inhibit this transition.</t>

      </section> <!-- transition-out-of-recover-wait-state -->

    </section> <!-- recover-wait state -->

    <section anchor="state-recover-done" title="RECOVER-DONE State">

      <t>This state exists to allow an interlocked transition for
      one server from RECOVER state and another server from
      PARTNER-DOWN or COMMUNICATIONS-INTERRUPTED state into NORMAL
      state.</t>

      <section anchor="operation-in-recover-done-state" title="Operation in RECOVER-DONE State">

        <t>A server in RECOVER-DONE state SHOULD be renew responsive, and MAY 
        respond to RENEW requests but MUST only change the state of a lease
        that appears in the RENEW request.  It MUST NOT allocate any additional
        leases when in RECOVER-DONE state and should only respond only to
	RENEW requests where it already has a record of the lease.</t>

      </section> <!-- operation-in-recover-done-state -->

      <section anchor="transition-out-of-recover-done-state"
               title="Transition Out of RECOVER-DONE State">

        <t>When a server in RECOVER-DONE state determines that its
        partner server has entered NORMAL or RECOVER-DONE state,
        then it will transition into NORMAL state.</t>

        <t>If the partner server enters RECOVER or RECOVER-WAIT state,
        this server transitions to COMMUNICATIONS-INTERRUPTED.
        </t>

        <t>If the partner server enters POTENTIAL-CONFLICT state
        then this server enters POTENTIAL-CONFLICT state as well.
        </t>

        <t>If communication fails while in RECOVER-DONE state, a
        server will stay in RECOVER-DONE state.</t>

      </section> <!-- transition-out-of-recover-done-state -->

    </section> <!-- recover-done state -->

    <section anchor="state-normal" title="NORMAL State">
      <t>NORMAL state is the state used by a server when it is communicating
      with the other server, and any required resynchronization has been
      performed. While some binding database synchronization is performed
      in NORMAL state, potential conflicts are resolved prior to entry into
      NORMAL state as is binding database data loss.</t>

      <t>When entering NORMAL state, a server will send to the other server
      all currently unacknowledged binding updates as BNDUPD messages.</t>

      <t>When the above process is complete, if the server entering NORMAL
      state is a secondary server, then it will request delegable prefixes 
      for allocation using the POOLREQ message.</t>

      <section anchor="operation-in-normal-state"
               title="Operation in NORMAL State">

      <t>The primary server is responsive in NORMAL state. The secondary is
      renew responsive in NORMAL state.</t>

        <t>When in NORMAL state a primary server will operate in the following manner:
      <list style="hanging">
        <t hangText="Valid lifetime calculations"> <vspace/>

        As discussed in 
        <xref target="mclt"/>, the
        lease interval given to a DHCP client can never be more than the
        MCLT greater than the most recently acknowledged partner lifetime
        received from the failover partner or the current time,
        whichever is later.
        <vspace blankLines="1"/>
        As long as a server adheres to this constraint, the specifics of
        the lease interval that it gives to a DHCP client or the value
        of the partner lifetime sent to its failover partner
        are implementation dependent.</t>

        <t hangText="Lazy update of partner server"> <vspace/>

        After sending a REPLY that includes a lease update to a client,
        the server servicing a DHCP client request attempts to update
        its partner with the new binding information. See <xref target="lazy-updates"/>.
        </t>

        <t hangText="Reallocation of leases between clients"> <vspace/>

        Whenever a client binding is released or expires, a BNDUPD
        message must be sent to the partner, setting the binding
        state to RELEASED or EXPIRED.  However, until a BNDREPLY is
        received for this message, the lease cannot be allocated
        to another client.  It cannot be allocated to the same client
        again if a BNDUPD was sent, otherwise it can. See <xref
        target="reallocation"/> for details.
        </t>
      </list>
      </t>

      <t>In NORMAL state, each server receives binding updates from
      its partner server in BNDUPD messages (see <xref
      target="accepting-updates"/>).  It records these in its binding
      database in stable storage and then sends a corresponding
      BNDREPLY message to its partner server (see <xref
      target="send-bndreply"/>).</t>

      </section> <!-- operation-in-normal-state -->
      <section anchor="transition-out-of-normal-state"
               title="Transition Out of NORMAL State">
        <t>If an external command is received by a server in NORMAL
        state informing it that its partner is down, then transition
        into PARTNER-DOWN state.  Generally, this would be an unusual
        situation, where some external agency knew the partner server
        was down prior to the failover server discovering it on its
        own.</t>  
        <!-- Does it make sense? That is at least strange - server maintain
        connection with its parner and suddenly operator states that that
        partner is down. -->

        <t>If a server in NORMAL state fails to receive acks to
        messages sent to its partner for an implementation dependent
        period of time, it MAY move into COMMUNICATIONS-INTERRUPTED
        state.  This situation might occur if the partner server
        was capable of maintaining the TCP connection between the
        server and also capable of sending a CONTACT message
        periodically, but was (for some reason) incapable of
        processing BNDUPD messages.</t>

        <t>If the communications is determined to not be "ok" (as
        defined in <xref target="reachability"/>), then transition
        into COMMUNICATIONS-INTERRUPTED state.</t>

        <t>If a server in NORMAL state receives any messages from
        its partner where the partner has changed state from that
        expected by the server in NORMAL state, then the server
        should transition into COMMUNICATIONS-INTERRUPTED state and
        take the appropriate state transition from there.  For
        example, it would be expected for the partner to transition
        from POTENTIAL-CONFLICT into NORMAL state, but not for the
        partner to transition from NORMAL into POTENTIAL-CONFLICT
        state.</t>

        <t> If a server in NORMAL state receives a DISCONNECT message
        from its partner, the server should transition into
        COMMUNICATIONS-INTERRUPTED state.</t>

      </section> <!-- transition-out-of-normal-state -->
    </section> <!-- normal state -->

    <section anchor="state-comm-interrrupted"
             title="COMMUNICATIONS-INTERRUPTED State">
      <t>A server goes into COMMUNICATIONS-INTERRUPTED state whenever it is
      unable to communicate with its partner. Primary and secondary
      servers cycle automatically (without administrative intervention)
      between NORMAL and COMMUNICATIONS-INTERRUPTED state as the network
      connection between them fails and recovers, or as the partner server
      cycles between operational and non-operational.  No duplicate lease 
      allocation can occur while the servers cycle between these
      states.</t>

      <t>When a server enters COMMUNICATIONS-INTERRUPTED state, if it has been
      configured to support an automatic transition out of COMMUNICATIONS-
      INTERRUPTED state and into PARTNER-DOWN state (i.e., auto-partner-down
      has been configured), then a timer is started
      for the length of the configured auto-partner-down period.</t>

      <t>A server transitioning into the COMMUNICATIONS-INTERRUPTED
      state from the NORMAL state SHOULD raise some alarm condition to
      alert administrative staff to a potential problem in the DHCP
      subsystem.</t>

      <section anchor="operation-in-comm-interrupted-state"
               title="Operation in COMMUNICATIONS-INTERRUPTED State">

	<t>In this state a server MUST respond to all DHCP client
	requests.  When allocating new leases, each server allocates
	from its own pool, where the primary MUST allocate only
	FREE delegable prefixes, and the secondary MUST allocate
	only FREE-BACKUP delegable prefixes, and each server allocates
	from its own independent IPv6 address ranges.  When responding
	to RENEW messages, each server will allow continued renewal
	of a DHCP client's current lease regardless of whether that
	lease was given out by the receiving server or not, although
	the renewal period MUST NOT exceed the MCLT beyond the
	latest of: 1) the partner lifetime already acknowledged by
	the other server, or 2) now, or 3) the partner lifetime
	received from the partner server.</t>

        <t>However, since the server cannot communicate with its
        partner in this state, the acknowledged partner lifetime
        will not be updated despite continued RENEW message processing.
        This is likely to eventually cause the actual lifetimes to
        converge to the MCLT (unless this is greater than the
        desired-client-lease-time, which would be unusual).</t>

        <t>The server should continue to try to establish a connection
        with its partner.</t>

      </section> <!-- operation-in-comm-interrrupted-state -->
      <section anchor="transition-out-of-comm-interrrupted-state"
               title="Transition Out of COMMUNICATIONS-INTERRUPTED State">

        <t>If the auto-partner-down timer expires while a server is in the
        COMMUNICATIONS-INTERRUPTED state, it will transition immediately into
        PARTNER-DOWN state.</t>

        <t>If an external command is received by a server in COMMUNICATIONS-
        INTERRUPTED state informing it that its partner is down, it will
        transition immediately into PARTNER-DOWN state.</t>

        <t>If communications is restored with the other server, then the server
        in COMMUNICATIONS-INTERRUPTED state will transition into another
        state based on the state of the partner:

        <list style="symbols">
          <t>NORMAL or COMMUNICATIONS-INTERRUPTED: Transition into the
          NORMAL state.</t>
          <!-- The partner SHOULD NOT be in NORMAL state here, since upon res-
          toration of communications it MUST have created a new TCP con-
          nection which would have forced it into COMMUNICATIONS-
          INTERRUPTED state.  Still, we should account for every state
          just in case. -->

          <t>RECOVER: Stay in COMMUNICATIONS-INTERRUPTED state.</t>

          <t>RECOVER-DONE: Transition into NORMAL state.</t>

          <t>PARTNER-DOWN, POTENTIAL-CONFLICT, CONFLICT-DONE, or
          RESOLUTION-INTERRUPTED: Transition into POTENTIAL-CONFLICT
          state.</t>

        </list></t>

        <t>The following figure illustrates the transition from NORMAL
        to COMMUNICATIONS-INTERRUPTED state and then back to NORMAL
        state again.</t>

        <!-- this title is too long. That should be a caption field -->
        <figure anchor="state-change-example" title="Transition from NORMAL to
         COMMUNICATIONS-INTERRUPTED and back">
          <artwork><![CDATA[
   Primary                                Secondary
    Server                                  Server

    NORMAL                                  NORMAL
      | >--CONTACT------------------->         |
      |        <--------------------CONTACT--< |
      |         [TCP connection broken]        |
 COMMUNICATIONS          :              COMMUNICATIONS
   INTERRUPTED           :                INTERRUPTED
      |      [attempt new TCP connection]      |
      |         [connection succeeds]          |
      |                                        |
      | >--CONNECT------------------->         |
      |        <---------------CONNECTREPLY--< |
      |                                     NORMAL
      |        <-------------------STATE-----< |
    NORMAL                                     |
      | >--STATE--------------------->         |
      |
      | >--BNDUPD-------------------->         |
      |        <-------------------BNDREPLY--< |
      |                                        |
      |        <---------------------BNDUPD--< |
      | >------BNDREPLY-------------->         |
     ...                                      ...
      |                                        |
      |        <--------------------POOLREQ--< |
      | >--POOLRESP------------------>         |
      |                                        |
      | >--BNDUPD-(#1)--------------->         |
      |        <-------------------BNDREPLY--< |
      |                                        |
      | >--BNDUPD-(#2)--------------->         |
      |        <-------------------BNDREPLY--< |
      |                                        |]]></artwork></figure>



      </section> <!-- transition-out-of-comm-interrrupted-state -->
    </section> <!-- comm-interrrupted state -->

    <section anchor="state-potential-conflict" title="POTENTIAL-CONFLICT State">
      <t>This state indicates that the two servers are attempting to
      reintegrate with each other, but at least one of them was
      running in a state that did not guarantee automatic
      reintegration would be possible.  In POTENTIAL-CONFLICT state
      the servers may determine that the same lease has been
      offered and accepted by two different clients.</t>

      <t>It is a goal of this protocol to minimize the possibility that
      POTENTIAL-CONFLICT state is ever entered.</t>

      <t>When a primary server enters POTENTIAL-CONFLICT state it
      should request that the secondary send it all updates which
      the primary server has not yet acknowledged by sending an
      UPDREQ message to the secondary server.</t>

      <t>A secondary server entering POTENTIAL-CONFLICT state will wait for
      the primary to send it an UPDREQ message.</t>

      <section anchor="operation-in-potential-conflict-state"
               title="Operation in POTENTIAL-CONFLICT State">
        <t>Any server in POTENTIAL-CONFLICT state MUST NOT process any
        incoming DHCP requests.</t>
      </section> <!-- operation-in-potential-conflict-state -->
      <section anchor="transition-out-of-potential-conflict-state"
               title="Transition Out of POTENTIAL-CONFLICT State">

        <t>If communication fails with the partner while in
        POTENTIAL-CONFLICT state, then the server will transition to
        RESOLUTION-INTERRUPTED state.</t>

        <t>Whenever either server receives an UPDDONE message from its
        partner while in POTENTIAL-CONFLICT state, it MUST transition
        to a new state.  The primary MUST transition to CONFLICT-DONE
        state, and the secondary MUST transition to NORMAL state.
        This will cause the primary server to leave POTENTIAL-CONFLICT
        state prior to the secondary, since the primary sends an
        UPDREQ message and receives an UPDDONE before the secondary
        sends an UPDREQ message and receives its UPDDONE message.</t>

        <t>When a secondary server receives an indication that the primary
        server has made a transition from POTENTIAL-CONFLICT to CONFLICT-DONE
        state, it SHOULD send an UPDREQ message to the primary server.</t>

<figure anchor="out-of-potential-conflict"
        title="Transition out of POTENTIAL-CONFLICT">
    <artwork><![CDATA[
    Primary                                Secondary
    Server                                  Server

      |                                        |
POTENTIAL-CONFLICT                    POTENTIAL-CONFLICT
      |                                        |
      | >--UPDREQ-------------------->         |
      |                                        |
      |        <---------------------BNDUPD--< |
      | >--BNDREPLY------------------>         |
     ...                                      ...
      |                                        |
      |        <---------------------BNDUPD--< |
      | >--BNDREPLY------------------>         |
      |                                        |
      |        <--------------------UPDDONE--< |
CONFLICT-DONE                                  |
      | >--STATE--(CONFLICT-DONE)---->         |
      |        <---------------------UPDREQ--< |
      |                                        |
      | >--BNDUPD-------------------->         |
      |        <-------------------BNDREPLY--< |
     ...                                      ...
      | >--BNDUPD-------------------->         |
      |        <-------------------BNDREPLY--< |
      |                                        |
      | >--UPDDONE------------------->         |
      |                                     NORMAL
      |        <------------STATE--(NORMAL)--< |
   NORMAL                                      |
      | >--STATE--(NORMAL)----------->         |
      |                                        |
      |        <--------------------POOLREQ--< |
      | >------POOLRESP-------------->         |
      |                                        |]]></artwork></figure>



      </section> <!-- transition-out-of-potential-conflict-state -->
    </section> <!-- potential-conflict state -->

    <section anchor="state-resolution-interrupted" title="RESOLUTION-INTERRUPTED State">
      <t>This state indicates that the two servers were attempting to
      reintegrate with each other in POTENTIAL-CONFLICT state, but
      communication failed prior to completion of re-integration.</t>

      <t>The RESOLUTION-INTERRUPTED state exists because
      servers are not responsive in POTENTIAL-CONFLICT state, and
      if one server drops out of service while both servers
      are in POTENTIAL-CONFLICT state, the server that remains
      in service will not be able to process DHCP client requests and
      there will be no DHCP service available.  The RESOLUTION-INTERRUPTED
      state is the state that a server moves to if its partner
      disappears while it is in POTENTIAL-CONFLICT state.</t>

      <t>When a server enters RESOLUTION-INTERRUPTED state it SHOULD raise an
      alarm condition to alert administrative staff of a problem in the
      DHCP subsystem.</t>

      <section anchor="operation-in-resolution-interrupted-state"
               title="Operation in RESOLUTION-INTERRUPTED State">
        <t>In this state a server MUST respond to all DHCP client
        requests. When allocating new leases, each server SHOULD 
        allocate from its own pool (if
        that can be determined), where the primary SHOULD allocate
        only FREE leases, and the secondary SHOULD allocate only
        FREE-BACKUP leases. When responding to renewal requests, each
        server will allow continued renewal of a DHCP client's current
        lease independent of whether that lease was given out by the
        receiving server or not, although the renewal period MUST NOT
        exceed the maximum client lead time (MCLT) beyond the latest
        of: 1) the partner lifetime already acknowledged by
        the other server or 2) now or 3) partner lifetime 
        received from the partner server.</t>

        <t>However, since the server cannot communicate with its
        partner in this state, the acknowledged partner 
        lifetime will not be updated in any new bindings.</t>
      </section> <!--
        operation-in-resolution-interrupted-state -->
      <section anchor="transition-out-of-resolution-interrupted-state"
               title="Transition Out of RESOLUTION-INTERRUPTED State">

        <t>If an external command is received by a server in
        RESOLUTION-INTERRUPTED state informing it that its partner is
        down, it will transition immediately into PARTNER-DOWN
        state.</t>

        <t>If communications is restored with the other server, then
        the server in RESOLUTION-INTERRUPTED state will transition
        into POTENTIAL-CONFLICT state.</t>

      </section> <!-- transition-out-of-resolution-interrupted-state -->
    </section> <!-- resolution-interrupted state -->

    <section anchor="state-conflict-done" title="CONFLICT-DONE State">
      <t>This state indicates that during the process where the two
      servers are attempting to re-integrate with each other, the
      primary server has received all of the updates from the
      secondary server.  It makes a transition into CONFLICT-DONE state
      in order that it may be totally responsive to the client load.
      There is no operational difference between CONFLICT-DONE and
      NORMAL for primary as in both states it responds to all
      clients' requests. The distinction between CONFLICT-DONE and
      NORMAL states is necessary in the event that a load-balancing
      extension is ever defined.
      <!--,
      as opposed to NORMAL state where it would be in a "balanced"
      responsive state, running the load balancing algorithm.--></t>

      <!-- issue 7  Kim: I believe we discussed this, and decided
      to leave CONFLICT-DONE in the state machine, so that when
      load-balancing is supported we won't have to rev the state
      machine.

      Yes, we did:  Tomek said this in some email on Sept 7, 2012:

        I'd like to comment on some decisions made regarding load
        balancing, before someone raises it again. v4 failover
        standardization failed, because the draft was too large and
        there was nobody willing to review it. That's why we try
        to succeed with v6 failover by splitting it to smaller
        chunks. That's why this failover covers the absolute minimum,
        i.e. active-passive only with load balancing being out of
        scope. You may notice that some of the states (RECOVER-DONE
        and CONFLICT-DONE) are really useful only for load balancing.
        We decided to keep them in to make extension to LB much
        simpler - the state machine will be operating in the same
        manner with and without LB. Obviously, there are many folks
        interested in load balancing. We are, too, but we want it
        to be an extension, defined in separate draft.
      
      Tomek: Ok, I've changed the wording slightly to not explicitly
      say that server does load balancing, as it is not officially
      defined yet. -->

      <section anchor="operation-in-conflict-done-state"
               title="Operation in CONFLICT-DONE State">
        <t>A primary server in CONFLICT-DONE state is fully responsive
        to all DHCP clients (similar to the situation in
        COMMUNICATIONS-INTERRUPTED state).</t>

        <t>If communication fails, remain in CONFLICT-DONE state.  If
        communications becomes OK, remain in CONFLICT-DONE state until
        the conditions for transition out become satisfied.</t>
      </section> <!-- operation-in-conflict-done-state -->
      <section anchor="transition-out-of-conflict-done-state"
               title="Transition Out of CONFLICT-DONE State">
        <t>If communication fails with the partner while in
        CONFLICT-DONE state, then the server will remain in
        CONFLICT-DONE state.</t>

        <t>When a primary server determines that the secondary
        server has made a transition into NORMAL state, the primary
        server will also transition into NORMAL state.</t>
      </section> <!-- transition-out-of-conflict-done-state -->
    </section> <!-- conflict-done state -->

</section> <!-- endpoint states -->


<section anchor="dns-update" title="DNS Update Considerations">

    <t>DHCP servers (and clients) can use DNS Updates as
    described in <xref target="RFC2136">RFC 2136</xref> to maintain
    DNS name-mappings as they maintain DHCP leases.  Many different
    administrative models for DHCP-DNS integration are possible.
    Descriptions of several of these models, and guidelines that
    DHCP servers and clients should follow in carrying them out,
    are laid out in <xref target="RFC4704">RFC 4704</xref>.</t>

    <t>The nature of the failover protocol introduces some issues
    concerning DNS updates that are not part of non-failover
    environments.  This section describes these issues, and defines
    the information which failover partners should exchange in order
    to ensure consistent behavior.  The presence of this section
    should not be interpreted as requiring an implementation of
    the DHCPv6 failover protocol to also support DNS updates.</t>

    <t>The purpose of this discussion is to clarify the areas where
    the failover and DHCP DNS update protocols intersect for the
    benefit of implementations which support both protocols, not
    to introduce a new requirement into the DHCPv6 failover protocol.
    Thus, a DHCP server which implements the failover protocol
    MAY also support DNS updates, but if it does support DNS updates
    it SHOULD utilize the techniques described here in order to
    correctly distribute them between the failover partners.  See
    <xref target="RFC4704">RFC 4704</xref> as well as <xref
    target="RFC4703">RFC 4703</xref> for information on how DHCP
    servers deal with potential conflicts when updating DNS even
    without failover.</t>

    <t>From the standpoint of the failover protocol, there is no
    reason why a server which is utilizing the DNS update protocol
    to update a DNS server should not be a partner with a server
    which is not utilizing the DNS update protocol to update a DNS
    server.  However, a server which is not able to support DNS
    update or is not configured to support DNS update SHOULD output
    a warning message when it receives BNDUPD messages which indicate
    that its failover partner is configured to support the DNS
    update protocol to update a DNS server.  An implementation MAY
    consider this an error and refuse to accept the BNDUPD by
    returning the status DNSUpdateNotSupported in an OPTION_STATUS_CODE
    option in the BNDREPLY message, or it MAY choose to operate anyway,
    having warned the administrator of the problem in some way.</t>

    <section anchor="failover-dns-update"
       title="Relationship between failover and DNS update">

        <t>The failover protocol describes the conditions under
        which each failover server may renew a lease to its current
        DHCP client, and describes the conditions under which it
        may grant a lease to a new DHCP client.  An analogous set
        of conditions determines when a failover server should
        initiate a DNS update, and when it should attempt to remove
        records from the DNS. The failover protocol's conditions
        are based on the desired external behavior: avoiding duplicate
        address and prefix assignments; allowing clients to continue
        using leases which they obtained from one failover partner
        even if they can only communicate with the other partner;
        allowing the secondary DHCP server to grant new leases even
        if it is unable to communicate with the primary server.
        The desired external DNS update behavior for DHCPv6 failover servers
        is similar to that described above for the failover protocol
        itself:</t>

        <t><list style="numbers">
            <t>Allow timely DNS updates from the server which
            grants a lease to a client. Recognize that there is
            often a DNS update lifecycle which parallels the DHCP
            lease lifecycle. This is likely to include the addition
            of records when the lease is granted, and the removal
            of DNS records when the lease is subsequently
            made available for allocation to a different client.</t>

            <t>Communicate enough information between the two
            failover servers to allow one to complete the DNS
            update 'lifecycle' even if the other server originally
            granted the lease.</t>

            <t>Avoid redundant or overlapping DNS updates, where
            both failover servers are attempting to perform DNS
            updates for the same lease-client binding.</t>
            
            <t>Avoid situations where one partner is attempting to
            add RRs related to a lease binding while the other
            partner is attempting to remove RRs related to the same
            lease binding.</t>
        </list></t>

        <t>While DHCPv6 servers configured for DNS update typically perform
        these operations on both the AAAA and the PTR resource records, 
        this is not required.  It is entirely possible that a DHCPv6 server
        could be configured to only update the DNS with PTR records, and 
        the DHCPv6 clients could be responsible for updating the DNS with
        their own AAAA records.  In this case, the discussions here would
        apply only to the PTR records.</t>

    </section>

    <section anchor="useofdnsupdate" 
       title="Exchanging DNS Update Information">

        <t>In order for either server to be able to complete a DNS
        update, or to remove DNS records which were added by its
        partner, both servers need to know the FQDN associated with
        the lease-client binding.  In addition, to properly handle
        DNS updates, additional information is required.  All of
        the following information needs to be transmitted between
        the failover partners:</t>

        <t><list style="numbers">
            <t>The FQDN that the client requested be associated
            with the lease.  If the client doesn't request a
            particular FQDN and one is synthesized by the failover
            server or if the failover server is configured to replace
            a client requested FQDN with a different FQDN, then
            the server generated value would be used. </t>

            <t>The FQDN that was actually placed in the DNS for
            this lease. It may differ from the client requested
            FQDN due to some form of disambiguation or other DHCP
            server configuration (as described above).</t>
            
            <t>The status of and DNS update operations in progress or
            completed.</t>

            <t>Information sufficient to allow the failover partner
            to remove the FQDN from the DNS should that become
            necessary.</t>
        </list></t>

        <t>These data items are the minimum necessary set to reliably
        allow two failover partners to successfully share the
        responsibility to keep the DNS up to date with the leases
        allocated to clients.</t>

        <t>This information would typically be included in BNDUPD
        messages sent from one failover partner to the other.
        Failover servers MAY choose not to include this information
        in BNDUPD messages if there has been no change in the status
        of any DNS update related to the lease.</t>

        <t>The partner server receiving BNDUPD messages containing
        the DNS update information SHOULD compare the status information
        and the FQDN with the current DNS update information it has
        associated with the lease binding, and update its notion
        of the DNS update status accordingly.</t>

        <t>Some implementations will instead choose to send a BNDUPD
        without waiting for the DNS update to complete, and then
        will send a second BNDUPD once the DNS update is complete.
        Other implementations will delay sending the partner a
        BNDUPD until the DNS update has been acknowledged by the
        DNS server, or until some time-limit has elapsed, in order
        to avoid sending a second BNDUPD.</t>

        <t>The FQDN option contains the FQDN that will be associated
        with the AAAA RR (if the server is performing an AAAA RR update
        for the client).  The PTR RR can be generated automatically from
        the IPv6 address or prefix value. The FQDN may be composed
        in any of several ways, depending on server configuration
        and the information provided by the client in its DHCP
        messages. The client may supply a hostname which it would
        like the server to use in forming the FQDN, or it may supply
        the entire FQDN. The server may be configured to attempt
        to use the information the client supplies, it may be
        configured with an FQDN to use for the client, or it may
        be configured to synthesize an FQDN.</t>

        <t>Since the server interacting with the client may not
        have completed the DNS update at the time it sends the
        first BNDUPD about the lease binding, there may be cases
        where the FQDN in later BNDUPD messages does not match the
        FQDN included in earlier messages.  For example, the
        responsive server may be configured to handle situations
        where two or more DHCP client FQDNs are identical by modifying
        the most-specific label in the FQDNs of some of the clients
        in an attempt to generate unique FQDNs for them (a process
        sometimes called "disambiguation").  Alternatively, at sites
        which use some or all of the information which clients
        supply to form the FQDN, it's possible that a client's
        configuration may be changed so that it begins to supply
        new data.  The server interacting with the client may react
        by removing the DNS records which it originally added for
        the client, and replacing them with records that refer to
        the client's new FQDN. In such cases, the server SHOULD
        include the actual FQDN that was used in subsequent DNS update
        options in any BNDUPD messages exchanged between the failover
        partners.  This server SHOULD include relevant information
        in its BNDUPD messages.  This information may be necessary
        in order to allow the non-responsive partner to detect
        client configuration changes that change the hostname or
        FQDN data which the client includes in its DHCPv6 requests.</t>

    </section>

    <section anchor="addingrr" 
       title="Adding RRs to the DNS">

        <t>A failover server which is going to perform DNS updates
        SHOULD initiate the DNS update when it grants a new lease
        to a client. The server which did not grant the lease SHOULD
        NOT initiate a DNS update when it receives the BNDUPD after
        the lease has been granted. The failover protocol ensures
        that only one of the partners will grant a lease to any
        individual client, so it follows that this requirement will
        prevent both partners from initiating updates simultaneously.
        The server initiating the update SHOULD follow the protocol
        in <xref target="RFC4704">RFC 4704</xref>.  The server may
        be configured to perform a AAAA RR update on behalf of its
        clients, or not. Ordinarily, a failover server will not
        initiate DNS updates when it renews leases. In two cases,
        however, a failover server MAY initiate a DNS update when
        it renews a lease to its existing client:</t>

        <t><list style="numbers">
            <t>When the lease was granted before the server was
            configured to perform DNS updates, the server MAY be
            configured to perform updates when it next renews
            existing leases.</t>

            <t>If a server is in PARTNER-DOWN state, it can conclude
            that its partner is no longer attempting to perform an
            update for the existing client. If the remaining server
            has not recorded that an update for the binding has
            been successfully completed, the server MAY initiate a
            DNS update.  It MAY initiate this update immediately
            upon entry to PARTNER-DOWN state, it may perform this
            in the background, or it MAY initiate this update upon
            next hearing from the DHCP client.</t>
        </list></t>

        <t>Note that, regardless of the use of failover, there is
        a use case for updating the DNS on every lease renewal.  If there
        is a concern that the information in the DNS does not match
        the information in the DHCP server, updating the DNS on lease
        renewal is one way to gradually ensure that the DNS has information
        that corresponds correctly the information in the DHCP server.
        </t>

    </section>

    <section anchor="deletingrr" 
       title="Deleting RRs from the DNS">

        <t>The failover server which makes a lease PENDING-FREE SHOULD
        initiate any DNS deletes, if it has recorded that DNS
        records were added on behalf of the client.</t>

        <t>A server not in PARTNER-DOWN state "makes a lease 
        PENDING-FREE" when it initiates a BNDUPD with a binding-status of
        FREE, FREE-BACKUP, EXPIRED, or RELEASED.  Its partner
        confirms this status by acking that BNDUPD, and upon receipt
        of the BNDREPLY the server has "made the lease PENDING-FREE".
        Conversely, a server in PARTNER-DOWN state "makes a lease 
        PENDING-FREE" when it sets the binding-status to FREE, since in
        PARTNER-DOWN state no communications is required with the
        partner.</t>

        <t>It is at this point that it should initiate the DNS
        operations to delete RRs from the DNS. Its partner SHOULD
        NOT initiate DNS deletes for DNS records related to the
        lease binding as part of sending the BNDREPLY message.   The
        partner MAY have issued BNDUPD messages with a binding-status
        of FREE, EXPIRED, or RELEASED previously, but the other
        server will have rejected these BNDUPD messages.</t>

        <t>The failover protocol ensures that only one of the two
        partner servers will be able to make a lease PENDING-FREE. The
        server making the lease PENDING-FREE may be doing so while it
        is in NORMAL communication with its partner, or it may be
        in PARTNER-DOWN state. If a server is in PARTNER-DOWN state,
        it may be performing DNS deletes for RRs which its partner
        added originally. This allows a single remaining partner
        server to assume responsibility for all of the DNS update 
        activity which the two servers were undertaking.</t>

        <t>Another implication of this approach is that no DNS RR
        deletes will be performed while either server is in
        COMMUNICATIONS-INTERRUPTED state, since no leases are
        moved into the PENDING-FREE state during that period.</t>

        <t>A failover server SHOULD ensure that a server failure
        while making a lease PENDING-FREE and initiating a DNS delete
        does not somehow leave the lease with a RR in the DNS
        with nothing recorded in the lease state database to
        trigger a DNS delete.
        </t>
    </section>

    <section anchor="nameassignment"
      title="Name Assignment with No Update of DNS">

        <t>In some cases, a DHCP server is configured to return a name
        to the DHCP client but not enter that name into the DNS.  
        This is typically a name that it has discovered
        or generated from information it has received from the client.
        In this case this name information SHOULD be communicated to the
        failover partner, if only to ensure that they will return the same
        name in the event the partner becomes the server to which the 
        DHCP client begins to interact.</t>

    </section>

</section>

  <!-- RESERVATIONS  
       This isn't really going to work as written, but it is a whole
       lot more complicated than this.  Do we want to even deal with
       this in the draft or just let people work it out?

  <section anchor="reserve" title="Reservations and failover">

    <t>Some DHCP servers support a capability to offer specific preconfigured 
    resources to DHCP clients.  These are real DHCP
    clients, they do the entire DHCP protocol, but these servers always
    offer the client a specific pre-configured resource, and they
    offer that resource to no other clients.  Such a capability has
    several names, but it is sometimes called a "reservation", in that
    the resource is reserved for a particular DHCP client.</t>

    <t>In a situation where there are two DHCP servers serving the same prefix
    without using failover, the two DHCP server's need to have disjoint 
    resource pools, but identical reservations for the DHCP
    clients.</t>

    <t>In a failover context, both servers need to be configured
    with the proper reservations in an identical manner, but if we
    stop there problems can occur around the edge conditions where
    reservations are made for resource that has already been leased
    to a different client.  Different servers handle this conflict
    in different ways, but the goal of the failover protocol is to
    allow correct operation with any server's approach to the normal
    processing of the DHCP protocol.</t>

    <t>The general solution with regards to reservations is as follows.
    Whenever a reserved resource becomes FREE (i.e., when first configured 
    or whenever a client frees it or it expires or is reset), the
    primary server MUST show that resource as FREE (and thus available
    for its own allocation) and it MUST send it to the secondary server
    in a BNDUPD with a flag set showing that it is reserved and with a
    status of FREE-BACKUP.</t>

    <t>Note that this implies that a reserved resource goes through
    the normal state changes from FREE to ACTIVE (and possibly back
    to FREE).  The failover protocol supports this approach to
    reservations, i.e., where the resource undergoes the normal
    state changes of any resource, but it can only be offered to
    the client for which it is reserved.</t>

    <t>From the above, it follows that a reservation solely on the
    secondary will not necessarily allow the secondary to offer
    that address to client to whom it is reserved.  The reservation
    must also appear on the primary as well for the secondary to
    be able to offer the resource to the client to which it is
    reserved.</t>

    <t>When the reservation on a resource is cancelled, if the resource 
    is currently FREE and the server is the primary, or FREE-BACKUP and the
    server is the secondary, the server MUST send a BNDUPD to the other
    server with the binding-status FREE and an indication that the
    resource is no longer reserved.</t>

  </section>
    -->


<section title="Security Considerations">

   <t>DHCPv6 failover is an extension of a standard DHCPv6 protocol, so all
   security considerations from <xref target="RFC3315" />, Section 23 and
   <xref target="RFC3633" />, Section 15 related to the server apply.</t>

   <t>
   The use of TCP introduces some additional concerns.  Attacks that
   attempt to exhaust the DHCP server's available TCP connection
   resources can compromise the ability of legitimate partners to
   receive service.  Malicious requestors who succeed in establishing
   connections but who then send invalid messages, partial messages, or no
   messages at all can also exhaust a server's pool of available
   connections.
   </t>

   <t>
   When operating in secure mode, TLS <xref target="RFC5246"/> is used
   to secure the connection.  The recommendations in <xref target="RFC7525"/>
   SHOULD be followed when negotiating a TLS connection.  
   </t>

   <t>
   Servers SHOULD offer configuration parameters to limit the sources
   of incoming connections through validation and use of the digital
   certificates presented to create a TLS connection.  They SHOULD
   also limit the number of accepted connections and limit the period
   of time during which an idle connection will be left open.  
   </t>

   <t>
   Authentication for DHCPv6 messages <xref target="RFC3315"/> MUST NOT be
   used to attempt to secure transmission of the messages described in
   this document.
   </t>

</section>

<section anchor="iana" title="IANA Considerations">

   <t>
   IANA is requested to assign values for the following new DHCPv6
   Message types in the registry maintained in 
   http://www.iana.org/assignments/dhcpv6-parameters:
   </t>

    <t>
       <list style="symbols">
      <t>BNDUPD (TBD1)</t>

      <t>BNDREPLY (TBD2)</t> 
      
      <t>POOLREQ (TBD3)</t>

      <t>POOLRESP (TBD4)</t> 

      <t>UPDREQ (TBD5)</t> 

      <t>UPDREQALL (TBD6)</t> 

      <t>UPDDONE (TBD7)</t> 

      <t>CONNECT (TBD8)</t> 

      <t>CONNECTREPLY (TBD9)</t> 
      
      <t>DISCONNECT (TBD10)</t> 
      
      <t>STATE (TBD11)</t> 

      <t>CONTACT (TBD12)</t> 
    </list>
    </t>


   <t>
   IANA is requested to assign values for the following new DHCPv6
   Option codes in the registry maintained in 
   http://www.iana.org/assignments/dhcpv6-parameters:

   <list>
      <t>OPTION_F_BINDING_STATUS (TBD13)</t>
      <t>OPTION_F_CONNECT_FLAGS (TBD14)</t>
      <t>OPTION_F_DNS_REMOVAL_INFO (TBD15)</t>
      <t>OPTION_F_DNS_HOST_NAME (TBD16)</t>
      <t>OPTION_F_DNS_ZONE_NAME (TBD17)</t>
      <t>OPTION_F_DNS_FLAGS (TBD18)</t>
      <t>OPTION_F_EXPIRATION_TIME (TBD19)</t>
      <t>OPTION_F_MAX_UNACKED_BNDUPD (TBD20)</t>
      <t>OPTION_F_MCLT (TBD21)</t>
      <t>OPTION_F_PARTNER_LIFETIME (TBD22)</t>
      <t>OPTION_F_PARTNER_LIFETIME_SENT (TBD23)</t>
      <t>OPTION_F_PARTNER_DOWN_TIME (TBD24)</t>
      <t>OPTION_F_PARTNER_RAW_CLT_TIME (TBD25)</t>
      <t>OPTION_F_PROTOCOL_VERSION (TBD26)</t>
      <t>OPTION_F_KEEPALIVE_TIME (TBD27)</t>
      <t>OPTION_F_RECONFIGURE_DATA (TBD28)</t>
      <t>OPTION_F_RELATIONSHIP_NAME (TBD29)</t>
      <t>OPTION_F_SERVER_FLAGS (TBD30)</t>
      <t>OPTION_F_SERVER_STATE (TBD31)</t>
      <t>OPTION_F_START_TIME_OF_STATE (TBD32)</t>
      <t>OPTION_F_STATE_EXPIRATION_TIME (TBD33)</t>
   </list>

   </t>

   <t>
   IANA is requested to assign values for the following new DHCPv6
   Status codes in the registry maintained in 
http://www.iana.org/assignments/dhcpv6-parameters:
   <list> 
    <!--
      <t>OneClientDifferentLeases (TBD30)</t>
    -->
      <t>AddressInUse (TBD34)</t>
      <t>ConfigurationConflict (TBD35)</t>
      <t>MissingBindingInformation (TBD36)</t>
      <t>OutdatedBindingInformation (TBD37)</t>
      <t>ServerShuttingDown (TBD38)</t>
      <t>DNSUpdateNotSupported (TBD39)</t>
   </list>
   </t>


</section>

<section title="Acknowledgements">
    <t>This document extensively uses concepts, definitions and
    other parts of an effort to document failover for DHCPv4.
    Authors would like to thank Shawn Routhier, Greg Rabil, Bernie
    Volz and Marcin Siodelski for their significant involvement and
    contributions. In particular, Bernie Volz and Shawn Routher
    provided detailed and substantive technical reviews of the draft.
    Authors would like to thank VithalPrasad Gaitonde, Krzysztof
    Gierlowski, Krzysztof Nowicki and Michal Hoeft for their
    insightful comments.</t>

</section>

</middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.1035'?>
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.2136'?>
      <?rfc include='reference.RFC.3315'?>
      <?rfc include='reference.RFC.3633'?>
      <?rfc include='reference.RFC.4703'?>
      <?rfc include='reference.RFC.4704'?>
      <?rfc include='reference.RFC.5007'?>
      <?rfc include='reference.RFC.5246'?>
      <?rfc include='reference.RFC.5460'?>
      <?rfc include='reference.RFC.6607'?>
      <?rfc include='reference.RFC.7525'?>
      <?rfc include='reference.RFC.7653'?>

    </references>

    <references title="Informative References">

      <?rfc include='reference.RFC.7031'?>
    <!--
      <reference anchor="dhcpv4-failover">
        <front>
          <title>DHCP Failover Protocol</title> <author fullname="Ralph
          Droms" initials="R." surname="Droms">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Kim Kinnear" initials="K."
          surname="Kinnear">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Mark Stapp" initials="M."
          surname="Stapp">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Bernie Volz" initials="B."
          surname="Volz">
            <organization>Ericsson</organization>
          </author> <author fullname="Steve Gonczi" initials="S."
          surname="Gonczi">
            <organization>Relicore</organization>
          </author> <author fullname="Greg Rabil" initials="G."
          surname="Rabil">
            <organization>Lucent Technologies</organization>
          </author> <author fullname="Michael Dooley" initials="M."
          surname="Dooley">
            <organization>Diamond IP Technologies</organization>
          </author> <author fullname="Arun Kapur" initials="A."
          surname="Kapur">
            <organization>K5 Networks</organization>
          </author> <date month="March" year='2003'/>
        </front> <seriesInfo name="Internet-Draft"
        value="draft-ietf-dhc-failover-12"/>
      </reference> 
    -->

    </references>
  </back>
</rfc>
