<?xml version='1.0' ?>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>

<?rfc compact="yes"?> <?rfc subcompact="no"?>

<?rfc symrefs="yes"?>

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' [
]>
<rfc ipr="trust200902" category="std"
     docName="draft-ietf-dhc-dhcpv6-failover-protocol-00">
  <front>
    <title abbrev="DHCPv6 Failover Protocol">DHCPv6 Failover Protocol</title>

    <author fullname="Tomasz Mrugalski" initials="T." surname="Mrugalski">
      <organization abbrev="ISC">Internet Systems Consortium, Inc.
      </organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <phone>+1 650 423 1345</phone>
        <email>tomasz.mrugalski@gmail.com</email>
      </address>
    </author>
    <author fullname="Kim Kinnear" initials="K." surname="Kinnear">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1414 Massachusetts Ave.</street>
          <city>Boxborough</city>
          <region>Massachusetts</region>
          <code>01719</code>
          <country>USA</country>
        </postal>
        <phone>+1 (978) 936-0000</phone>
        <email>kkinnear@cisco.com</email>
      </address>
    </author>

    <date />

    <area>Internet</area>
    <workgroup>Dynamic Host Configuration (DHC)</workgroup>
    <keyword>DHCPv6</keyword>
    <keyword>Failover</keyword>

    <abstract>
      <t>DHCPv6 defined in <xref target="RFC3315"/> does not offer
      server redundancy. This document defines a specific protocol
      implementation to provide for DHCPv6 failover, a mechanism for 
      running two servers on the same network with capability 
      for either server to take over clients' leases in case of server failure or network partition.  
      This is the third in a series of documents documenting 
      DHCPv6 Failover.
      DHCPv6 failover requirements are
      specified in <xref target="RFC7031"/>.  
      Design considerations are documented in 
      <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
      One could implement the DHCPv6 Failover protocol by
      referring only to the current document and not the design document,
      as the current document explains the details of the protocol.  
      However, the
      design document explains "why" the protocol operates as
      it does, making it required reading for someone implementing the
      failover protocol described in this document.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Glossary">
      <t>This is a supplemental glossary that should be combined with
      definitions in Section 3 of
      <xref target="RFC7031">RFC 7031</xref>.

      <list style="symbols">

        <t>auto-partner-down - a capability where a failover server
        will move from COMMUNICATIONS-INTERRUPTED state to 
        PARTNER-DOWN state automatically, without operator intervention.</t>

        <t>DDNS - Dynamic DNS.  Typically used as an acronym referring to
        dynamic update of the DNS.</t> 

        <t>Failover endpoint - The failover protocol allows for
        there to be a unique failover 'endpoint' for each failover
        relationship in which a failover server participates.  The
        failover relationship is defined by a relationship name,
        and includes the failover partner IP address, the role this
        server takes with respect to that partner (primary or
        secondary), and the prefixes associated with that relationship.
        Note that a single prefix can only be associated with a
        single failover relationship.  This failover endpoint can
        take actions and hold unique states.  Typically, there is
        one failover endpoint per partner (server), although there
        may be more.  'Server' and 'failover endpoint' are synonymous
        only if the server participates in only one failover
        relationship. However, for the sake of simplicity 'Server'
        is used throughout the document to refer to a failover
        endpoint unless to do so would be confusing.</t>

        <t>Failover communication - all messages exchanged between
        partners.</t>

        <t>Independent Allocation - an allocation algorithm
        that splits the available pool of resources between the primary
        and secondary servers that is particularly well suited for
        vast pools (i.e. when available resources are not expected
        to deplete). 
        See <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>
        for details.
        </t>

        <t>Lease - an association of a DHCPv6 client with an IPv6 
        address or delegated prefix.</t>

        <t>Partner - name of the other DHCPv6 server that participates
        in failover relationship. When the role (primary or secondary)
        is not important, the other server is referred to as a "failover
        partner" or simply partner.</t>

        <t>Primary Server - First out of two DHCPv6 servers that participate
        in a failover relationship. In active-passive mode this is the
        server that handles most of the client traffic. Its failover partner
        is referred to as secondary server. </t>

        <t>Proportional Allocation - an allocation algorithm
        that splits the available resources between
        the primary and secondary servers and maintains proportions between
        available resources on both. It is particularly well suited for more
        limited resources.  
        See <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>
        for details.
        </t>

        <t>Resource - Any type of resource that is managed by
        DHCPv6. Currently there are three types of such resources
        defined: a non-temporary IPv6 address, a temporary IPv6 address,         
        and an IPv6 prefix. Other resource types may
        be defined in the future.</t>

        <t>Responsive - A server that is responsive, will respond to
        DHCPv6 client requests.</t>

        <t>Secondary Server - Second of two DHCPv6 servers that participate
        in a failover relationship. Its failover partner is referred to as
        the primary server. In active-passive mode this server (the secondary)
        typically does not handle client traffic and acts as a backup.</t>

        <t>Server - A DHCPv6 server that implements DHCPv6 failover.
        'Server' and 'failover endpoint' are synonymous only if the
        server participates in only one failover relationship. </t>

        <t>Unresponsive - A server that is unresponsive will not
        respond to DHCPv6 client requests.</t>

      </list>
      </t>
    </section>

    <section title="Introduction">
      <t>The failover protocol provides a means for cooperating
      DHCPv6 servers to work together to provide a DHCPv6 service
      with availability that is increased beyond that which could
      be provided by a single DHCPv6 server operating alone.  It
      is designed to protect DHCPv6 clients against server unreachability,
      including server failure and network partition. It is possible
      to deploy exactly two servers that are able to continue
      providing a lease on an IPv6 address <xref target="RFC3315"/>
      or on an IPv6 prefix <xref target="RFC3633"/>
      without the DHCPv6 client experiencing lease expiration or a
      reassignment of a lease to a different IPv6 address (or prefix) 
      in the event of failure by one or the other of the two servers.</t>

      <t>This protocol defines active-passive mode, sometimes also
      called a hot standby model. This means that during normal
      operation one server is active (i.e. actively responds to
      clients' requests) while the second is passive (i.e. it 
      receives clients' requests, but does not respond to them and only
      maintains a copy on the binding database and is ready to take over
      incoming queries in case of primary server
      failure). Active-active mode (i.e. both servers actively
      handling clients' requests) is currently not supported for the
      sake of simplicity. Such a mode is likely to be defined as an
      extension at a later time and will probably be based on <xref
      target="I-D.ietf-dhc-dhcpv6-load-balancing" />.</t>

      <t>The failover protocol is designed to provide lease stability
      for leases with lease times beyond a short period.  Due in part to the
      additional overhead required as well as requirements to handle
      time skew between failover partners 
      (See <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>)
      failover is not suitable for leases shorter than 30 seconds. 
      The DHCPv6 Failover protocol MUST NOT be used for leases shorter 
      than 30 seconds.</t>

      <t>This protocol attempts to fulfill all DHCPv6 failover requirements
      defined in <xref target="RFC7031"/> as well as following the design
      approach documented in 
      <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
      </t>

    </section> 

<section title="Design Decisions">

   <t>The DHCPv6 failover design <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
   offered several approaches to be used to deal with some issues, and discusses the
   pros and cons of each.  This document needs to be specific with respect to some of
   these approaches. The following design decisions have therefore been taken as part
   of the process of producing this document:
   <list style="hanging">
        <t hangText="Resource Allocation"> <vspace/>
           Section 6 of <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
           discusses two alloction algorithms: proportional and independent.
           Proportional allocation is used for delegated prefixes, and 
           independent allocation is used for IP address allocation.</t>
   </list>
   </t>


</section>


<section title="Message and Option Definitions">

  <section anchor="msg-framing" title="Message Framing for TCP">

    <t>
    Failover
    communication is conducted over a TCP connection established between the
    partners. The protocol reuses the framing format specified in Section 5.1 of
    <xref target="RFC5460">DHCPv6 Bulk Leasequery</xref>, but uses different
    message types with a different message format, described in 
    <xref target="msg-format"/>.  
    All information is sent over the connection as typical
    DHCPv6 messages that convey DHCPv6 options, following the format defined in
    Section 22.1 of <xref target="RFC3315"/>.
    </t>

  </section>

  <section anchor="msg-format" title="Failover Message Format">

   <t>
   All Failover messages defined below share a common format with a
   fixed size header and a variable format area for options.  All
   values in the message header and in any included options are in 
   network byte order.
   </t>

   <t>
   The following diagram illustrates the format of DHCP messages exchanged
   between failover partners:
   </t>

   <figure>
   <artwork>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    msg-type   |               transaction-id                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           sent-time                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
   |                                                               . 
   .                            options                            .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   msg-type             Identifies the DHCP message type; the
                        available message types are listed in
                        below.

   transaction-id       The transaction ID for this message exchange.

   sent-time            The time the message was transmitted (set
                        as close to transmission as practical), 
                        in seconds since midnight (UTC), 
                        January 1, 2000, modulo 2^32.  Used to 
                        determine the time skew of the failover
                        partners.

   options              Options carried in this message.
   </artwork>
   </figure>


  </section>

  <section anchor="msg-list" title="Messages">

    <t>
    The following list contains the new message types created for failover
    communication.
    </t>

    <section anchor="msg-bndupd" title="BNDUPD">
      <t> The binding update message BNDUPD (TBD1) is used to send the binding lease
      changes to the partner. One message may contain one or more lease
      updates. The partner is expected to respond with a BNDACK message.  </t>
    </section>

    <section anchor="msg-bndack" title="BNDACK">
      <t> The binding acknowledgement message BNDACK (TBD2) is used for confirmation
      of the received BNDUPD message. It may contain a positive or negative
      response (e.g. due to detected lease conflict).  </t>
    </section>
      
    <section anchor="msg-poolreq" title="POOLREQ">
      <t>The Pool Request message POOLREQ (TBD3) is used by one server (typically
      secondary) to request allocation of resources (addresses or prefixes) from
      its partner. The partner responds with POOLRESP.</t>
    </section>

    <section anchor="msg-poolresp" title="POOLRESP">
      <t>The Pool Response POOLRESP (TBD4) message is used by one server
      (typically primary) to indicate that it has responded to its
      partner's request for resources allocation.  </t>
    </section>

    <section anchor="msg-updreq" title="UPDREQ">
      <t>The update request message UPDREQ (TBD5) is used by one server to request
      that its partner send all binding database changes that have not been
      sent and confirmed already. Requested partner is expected to respond
      with zero or more BNDUPD messages, followed by UPDDONE that signals
      end of updates.</t>
    </section>

    <section anchor="msg-updreqall" title="UPDREQALL">
      <t>The update request all UPDREQALL (TBD6) is used by one server to request
      that all binding database information be sent in order to recover from a
      total loss of its binding database by the requesting server. Requested
      server responds with zero or more BNDUPD messages, followed by UPDDONE
      that signal end of updates.</t>
    </section>

    <section anchor="msg-upddone" title="UPDDONE">
      <t>The update done message UPDDONE (TBD7) is used by the server
      responding to an UPDREQ or UPDREQALL to indicate that all
      requested updates have been sent by the responding server and
      acked by the requesting server.</t>
    </section>

    <section anchor="msg-connect" title="CONNECT">
      <t>The connect message CONNECT (TBD8) is used by the primary
      server to establish a high level connection with the secondary
      server, and to transmit several important configuration data
      items between the servers. The partner is expected to confirm
      by responding with CONNECTACK message.</t>
    </section>

    <section anchor="msg-connectack" title="CONNECTACK">
      <t>The connect acknowledgement message CONNECTACK (TBD9) is used by the
      secondary server to respond to a CONNECT message from the primary
      server.</t>
    </section>
      
    <section anchor="msg-disconnect" title="DISCONNECT">
      <t>The disconnect message DISCONNECT (TBD10) is used by either server when
      closing a connection and shutting down. No response is required for this
      message.</t>
    </section>
      
    <section anchor="msg-state" title="STATE">
      <t>The state message STATE (TBD11) is used by either server to inform its
      partner about a change of failover state. In some cases it may be used
      to also inform the partner about the current state, e.g. after connection
      is established in COMMUNICATIONS-INTERRUPTED or PARTNER-DOWN states.</t>
    </section>

    <section anchor="msg-contact" title="CONTACT">
      <t>
      The contact message CONTACT (TBD12) is used by either server
      to ensure that the other server continues to see the connection
      as operational.  It MUST be transmitted periodically over
      every established connection if other message traffic is not
      flowing, and it MAY be sent at any time.
      </t>

    </section>

  </section>


  <section anchor="option-list" title="Options">

    <t>
    The following new options are defined.
    </t>

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_binding_status"
             title="OPTION_F_BINDING_STATUS">
  
    <t>The binding-status represents an implementation independent representation
       of the status (or the state) of a resource (IP address or prefix).
   </t>
  
   <t>
   This is an unsigned byte.
   </t>
  
   <t>
   The code for this option is TBD13.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    OPTION_F_BINDING_STATUS    |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | binding-status|
   +-+-+-+-+-+-+-+-+
  
   option-code       OPTION_F_BINDING_STATUS (TBD13).
   option-len        1.
   binding-status    The binding status.  See below.
   </artwork>
   </figure>

    <figure>
    <artwork>
   Value   binding-status
   -----   --------------
   0       reserved
   1       ACTIVE 
   2       EXPIRED 
   3       RELEASED
   4       FREE*
   5       FREE
   6       FREE_BACKUP
   7       ABANDONED
   8       RESET
    </artwork>
    </figure>

   <t>The resource binding-status values  are as follows:</t>

  <t>
  <list style="hanging">
    <t hangText="ACTIVE"> -- The resource is assigned to a client. Client
    identification data MUST appear.</t>
    <t hangText="EXPIRED"> -- indicates that a client's binding on a
    given resource has expired. When the partner acks the BNDUPD of an
    expired resource, the server sets its internal state to FREE*. Client
    identification SHOULD appear.</t>
    <t hangText="RELEASED"> -- indicates that a client sent in RELEASE
    message. When the partner acks the BNDUPD of a released resource,
    the server sets its internal state to FREE*. Client identification
    SHOULD appear.</t>

    <t hangText="FREE*"> -- Once a resource is expired or released, its
    state becomes FREE*. Depending on which algorithm and which pool
    was used to allocate a given resource, FREE* may either mean FREE or
    FREE_BACKUP. Implementations do not have to implement this FREE*
    state, but may choose to switch to the destination state directly.
    For a clarity of representation, this transitional FREE* state is
    treated as a separate state. </t>

    <t hangText="FREE"> -- Is used when a DHCP server needs to
    communicate that a resource is unused by any client, but it
    was not just released, expired or reset by a network administrator.
    When the partner acks the BNDUPD of a FREE resource, the server
    marks the resource as available for assignment by the primary server.
    Note that on a secondary server running in PARTNER-DOWN state, after
    waiting the MCLT, the resource MAY be allocated to a client by the
    secondary server. Client identification MAY appear and indicates
    the last client to have used this resource as a hint.</t>

    <!-- tomek: this was called BACKUP in v4, but it was confusing for
         users. FREE_BACKUP is  -->
    <t hangText="FREE_BACKUP"> -- indicates that this resource can
    be allocated by the secondary server to a client at any time.
    It is only meaningful for delegated prefixes, using proportional
    allocation. Note that on the primary server running in PARTNER-DOWN
    state, after waiting the MCLT, the prefix MAY be allocated to
    a client by the primary server. Client identification MAY appear
    and indicates the last client to have used this resource as a
    hint.</t>

    <t hangText="ABANDONED"> -- indicates that a resource is considered
    unusable by the DHCP system. The primary reason for entering
    such state is reception of DECLINE message for said resource. Client 
    identification MAY appear.</t>

    <t hangText="RESET"> -- indicates that this resource was made
    available by operator command. This is a distinct state so that
    the reason that the resource became FREE can be determined.
    Client identification MAY appear.</t>

  </list>
  </t>


  
   </section>




   <!-- ============================================================= -->
  
   <section anchor="option_f_dns_removal_info"
             title="OPTION_F_DNS_REMOVAL_INFO">
  
   <t>This option contains the information necessary to remove a DNS
   name that was entered by the failover partner.
   </t>
  
   <t>
   The code for this option is TBD14.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_DNS_REMOVAL_INFO   |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          sub-options                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_DNS_REMOVAL_INFO (TBD14).
   option-len        4.
   sub-options       Three possible sub-options:
                     OPTION_F_DNS_HOST_NAME
                     OPTION_F_DNS_ZONE_NAME
                     OPTION_F_DNS_FLAGS
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_dns_host_name"
             title="OPTION_F_DNS_HOST_NAME">
  
   <t>
   Contains the host name that was entered into DNS by the failover partner.
   </t>
  
   <t>
      This is a DNS name encoded in RFC 1035 format
      <xref target="RFC1035">RFC 1035</xref>, 
      as specified in Section 8 of
      <xref target="RFC3315">RFC 3315</xref>. 
   </t>
  
   <t>
   This is a suboption of OPTION_F_DNS_REMOVAL_INFO.
   The suboption code for this suboption is 1.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_DNS_HOST_NAME    |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               .
   .                                                               .
   .                           host-name                           .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_DNS_HOST_NAME (1).
   option-len        0 + length of host-name.
   host-name         RFC 1035 encoded host-name.
   </artwork>
   </figure>
  
   </section>
 

 
 
   <!-- ============================================================= -->
  
   <section anchor="option_f_dns_zone_name"
             title="OPTION_F_DNS_ZONE_NAME">
  
   <t>
   Contains the zone name that was entered into DNS by the failover partner.
   </t>
  
   <t>
      This is a DNS name encoded in RFC 1035 format
      <xref target="RFC1035">RFC 1035</xref>, 
      as specified in Section 8 of
      <xref target="RFC3315">RFC 3315</xref>. 
   </t>
  
   <t>
   This is a suboption of OPTION_F_DNS_REMOVAL_INFO.
   The suboption code for this suboption is 2.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_DNS_ZONE_NAME    |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               .
   .                                                               .
   .                           zone-name                           .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_DNS_ZONE_NAME (2).
   option-len        0 + length of zone-name.
   zone-name         RFC 1035 encoded zone name.
   </artwork>
   </figure>
  
   </section>
 

   <!-- ============================================================= -->
  
   <section anchor="option_f_dns_flags"
             title="OPTION_F_DNS_FLAGS">
  
   <t>
   Flags which indicate what needs to be done to remove this DNS name.  
   </t>
  
   <t>
   This consists an unsigned 16 bit value in network byte order.
   </t>
  
   <t>
   This is a suboption of OPTION_F_DNS_REMOVAL_INFO.
   The suboption code for this suboption is 3.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       OPTION_F_DNS_FLAGS      |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             flags             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_DNS_FLAGS (3).
   option-len        2.
   flags             flag bits, see below:
   </artwork>
   </figure>

   <figure>
   <artwork>
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |  MBZ  |U|S|R|F|
   +-+-+-+-+-+-+-+-+

   The bits (numbered from the least-significant bit in network
   byte-order) are used as follows:
 
   4 (U): USING_REQUESTED_FQDN
          Set to 1 to indicate that name used came from the 
          FQDN that was received from the client.
   5 (S): SYNTHESIZED_NAME
          Set to 1 to indicate that the name was synthesized
          based on some algorithm.
   6 (R): REV_UPTODATE
          Set to 1 to indicate that the reverse zone is up to date.
   7 (F): FWD_UPTODATE
          Set to 1 to indicate that the forward zone is up to date.
   0-3  : Must be zero
   </artwork>
   </figure>
  
   </section>
 

   <!-- ============================================================= -->
  
   <section anchor="option_f_failover_expire_time"
             title="OPTION_F_FAILOVER_EXPIRE_TIME">
  
    <t>The greatest lifetime that this server has ever acked to its
    partner in a BNDACK.
    This MUST be an absolute time (i.e. seconds since midnight 
    January 1, 2000 UTC, modulo 2^32). 
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD15.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | OPTION_F_FAILOVER_EXPIRE_TIME |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     failover-expire-time                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_FAILOVER_EXPIRE_TIME (TBD15).
   option-len        4.
   failover-expire-time The failover-expire-time. This MUST be an 
                        absolute time (i.e. seconds since midnight 
                        January 1, 2000 UTC, modulo 2^32). 

   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_max_unacked_bndupd"
             title="OPTION_F_MAX_UNACKED_BNDUPD">
  
   <t>
   The maximum number of BNDUPD messages that this server is prepared to
   accept over the TCP connection without causing the TCP connection to
   block.
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD16.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  OPTION_F_MAX_UNACKED_BNDUPD  |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       max-unacked-bndupd                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code        OPTION_F_MAX_UNACKED_BNDUPD (TBD16).
   option-len         4.
   max-unacked-bndupd Maximum number of unacked BNDUPD message 
                      allowed.
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_mclt"
             title="OPTION_F_MCLT">
  
   <t>The maximum-client-lead-time (MCLT) is the is the upper
   bound on the difference allowed between the lease time provided to a
   DHCPv6 client by a server and the lease time known by that server's
   failover partner.  It is an interval, measured in seconds.
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD17.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         OPTION_F_MCLT         |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              mclt                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_MCLT (TBD17).
   option-len        4.
   mclt              The maximum-client-lease-time, in seconds.
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_next_partner_lifetime"
             title="OPTION_F_NEXT_PARTNER_LIFETIME">
  
   <t>
    The time we want to send to the partner the next time that
    we send them a BNDUPD.  This will become the time after which
    the partner can consider the IP address expired and is able
    to re-use the IP address.
    This MUST be an absolute time (i.e. seconds since midnight 
    January 1, 2000 UTC, modulo 2^32). 
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD18.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | OPTION_F_NEXT_PARTER_LIFETIME |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     next-partner-lifetime                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_NEXT_PARTER_LIFETIME (TBD18).
   option-len        4.
   next-partner-lifetime  The next-partner-lifetime. This MUST be an 
                          absolute time (i.e. seconds since midnight 
                          January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_next_partner_lifetime_sent"
             title="OPTION_F_NEXT_PARTNER_LIFETIME_SENT">
  
   <t>
    The time that was received in an OPTION_F_NEXT_PARTNER_LIFETIME
    <xref target="option_f_next_partner_lifetime"/> option.  This
    is an exact replacement (echo) of the time received in the
    OPTION_F_NEXT_PARTNER_LIFETIME option, uncorrected and unadjusted
    in any way.
    This MUST be an absolute time (i.e. seconds since midnight 
    January 1, 2000 UTC, modulo 2^32). 
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD19.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |OPTION_F_NEXT_PARTNER_LIFETIME_|           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   next-partner-lifetime-sent                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_NEXT_PARTNER_LIFETIME_SENT (TBD19).
   option-len        4.
   next-partner-lifetime-sent  The next-partner-lifetime-send. 
                               This MUST be an absolute time
                               (i.e. seconds since midnight 
                               January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_partner_down_time"
             title="OPTION_F_PARTNER_DOWN_TIME">
  
   <t>
    The time that the partner most recently lost commmunications with its
    failover partner. 
    This MUST be an absolute time (i.e. seconds since midnight 
    January 1, 2000 UTC, modulo 2^32). 
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD20.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_PARTNER_DOWN_TIME  |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       partner-down-time                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_PARTNER_DOWN_TIME (TBD20).
   option-len        4.
   partner-down-time Contains the partner-down-time. This MUST be an 
                     absolute time (i.e. seconds since midnight 
                     January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_partner_raw_clt_time"
             title="OPTION_F_PARTNER_RAW_CLT_TIME">
  
   <t>
    The time when the partner most recently interacted with the client
    associated with this IP address.
    This MUST be an absolute time (i.e. seconds since midnight 
    January 1, 2000 UTC, modulo 2^32).   This time is uncorrected
    for clock skew, timezone differences, and anything else.  It remains
    in the time context of the partner server.
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD21.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | OPTION_F_PARTNER_RAW_CLT_TIME |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      partner-raw-clt-time                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_PARTNER_RAW_CLT_TIME (TBD21).
   option-len        4.
   partner-raw-clt-time Contains the partner-raw-clt-time. This MUST 
                        be an absolute time (i.e. seconds since 
                        midnight January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_protocol_version"
             title="OPTION_F_PROTOCOL_VERSION">
  
   <t>
   The protocol version allows the one failover partner to determine
   the version of the protocol being used by the other partner, to allow
   for changes and upgrades in the future.
   </t>
  
   <t>
   This is an unsigned integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD22.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_PROTOCOL_VERSION   |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
   |                         protocol-version                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_PROTOCOL_VERSION (TBD22).
   option-len        4.
   protocol-version  The version of the protocol.
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_receive_time"
             title="OPTION_F_RECEIVE_TIME">
  
   <t>
   The number of seconds (an interval) within which the server must
   receive a message from its partner, or it will assume that 
   communications from the partner is not ok.
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD23.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_RECEIVE_TIME     |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          receive-time                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_RECEIVE_TIME (TBD23).
   option-len        4.
   receive-time      The receive-time.  An interval of seconds.
   </artwork>
   </figure>
  
   </section>

   <!-- ============================================================= -->
  
   <section anchor="option_f_reconfigure_data"
             title="OPTION_F_RECONFIGURE_DATA">
  
   <t>Contains the information necessary for one failover partner to
   use the reconfigure-key created on the other failover partner.</t>

   <t>
   The code for this option is TBD24.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_RECONFIGURE_DATA   |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        reconfigure-time                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               .
   .                                                               .
   .                        reconfigure-key                        .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_RECONFIGURE_DATA (TBD24).
   option-len        4 + length of reconfigure-key.
   reconfigure-time  Time at which reconfigure-key was created.
                     This MUST be an absolute time (i.e. seconds 
                     since midnight 
                     January 1, 2000 UTC, modulo 2^32). 
   reconfigure-key   The reconfigure-key.
   </artwork>
   </figure>
  
   </section>
 
 
   <!-- ============================================================= -->
  
   <section anchor="option_f_relationship_name"
             title="OPTION_F_RELATIONSHIP_NAME">
  
   <t>
   A name for this failover relationshiop. 
   </t>
  
   <t>
   A UTF-8 encoded text string suitable for
   display to an end user, which MUST NOT be null-terminated.
   </t>
  
   <t>
   The code for this option is TBD25.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   OPTION_F_RELATIONSHIP_NAME  |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               .
   .                                                               .
   .                       relationship-name                       .
   .                           (variable)                          .
   .                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_RELATIONSHIP_NAME (TBD25).
   option-len        0 + length of relationship-name.
   relationship-name A UTF-8 encoded text string suitable for
                     display to an end user, which MUST NOT be
                     null-terminated.
   </artwork>
   </figure>
  
   </section>
 

 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_server_flags"
             title="OPTION_F_SERVER_FLAGS">
  
   <t>
   The OPTION_F_SERVER_FLAGS option specifies information
   associated with the failover endpoint sending the option.
   </t>

   <t>
   This is an unsigned byte.
   </t>
  
   <t>
   The code for this option is TBD26.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_SERVER_FLAGS     |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  server-flags |
   +-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_SERVER_FLAGS (TBD26).
   option-len        1.
   server-flags      The server flags, see below:
   </artwork>
   </figure>

   <figure>
   <artwork>
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |  MBZ  |B|A|S|C|
   +-+-+-+-+-+-+-+-+

   The bits (numbered from the least-significant bit in network
   byte-order) are used as follows:
 
   4 (B): SECONDARY (BACKUP)
          Indicates that the sending server is a secondary 
          (or backup) server.
   5 (A): ACK_STARTUP
          Set to 1 to indicate that the OPTION_F_SERVER_FLAGS most
          recently received contained the STARTUP bit set.
   6 (S): STARTUP,
          MUST be set to 1 whenever the server is in STARTUP state.
   7 (C): COMMUNICATED
          Set to 1 to indicate that the sending server has
          communicated with its partner. 
   0-3  : Must be zero
   </artwork>
   </figure>

  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_server_state"
             title="OPTION_F_SERVER_STATE">
  
   <t>
   The OPTION_F_SERVER_STATE option specifies the endpoint state of
   the server sending the option.
   </t>

   <t>
   This is an unsigned byte.
   </t>
  
   <t>
   The code for this option is TBD27.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_SERVER_STATE     |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  server-state |
   +-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_SERVER_STATE (TBD27).
   option-len        1.
   server-state      Failover endpoint state.
   </artwork>
   </figure>

    <figure>
    <artwork>
   Value   Server State
   -----   ----------------------------------------------------------
   0       reserved
   1       STARTUP                Startup state (1)
   2       NORMAL                 Normal state
   3       COMMUNICATIONS-INTERRUPTED Communication interrupted 
   4       PARTNER-DOWN           Partner down 
   5       POTENTIAL-CONFLICT     Synchronizing
   6       RECOVER                Recovering bindings from partner
   7       PAUSED                 Shutting down for a short period.
   8       SHUTDOWN               Shutting down for an long period.
   9       RECOVER-DONE           Interlock state prior to NORMAL
   10      RESOLUTION-INTERRUPTED Comm. failed during resolution
   11      CONFLICT-DONE          Primary resolved its conflicts
    </artwork>
    </figure>

    <t>
    (1) The STARTUP state is never sent to the partner server, it is
    indicated by the STARTUP bit in the server-flags options (see 
    <xref target="state-startup"/>.
    </t>

  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_start_time_of_state"
             title="OPTION_F_START_TIME_OF_STATE">
  
    <t>The time at which the associated state began to hold its current
       value.  When this option appears in a STATE message, the state to
       which it refers is the server endpoint state.  When it appears in
       an IA_NA or IA_PD message, the state to which it refers is the
       binding-status value in the IA_NA or IA_PD option.
       This MUST be an absolute time (i.e. seconds since midnight 
       January 1, 2000 UTC, modulo 2^32). 
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD28.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  OPTION_F_START_TIME_OF_STATE |           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      start-time-of-state                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_START_TIME_OF_STATE (TBD28).
   option-len        4.
   start-time-of-state  The start-time-of-state. This MUST be an 
                        absolute time (i.e. seconds since midnight 
                        January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>
 

 
   <!-- ============================================================= -->
  
   <section anchor="option_f_state_expiration_time"
             title="OPTION_F_STATE_EXPIRATION_TIME">
  
   <t>
    The state-expiration-time is the time at which  the current state
    of this lease will expire. 
    This MUST be an absolute time (i.e. seconds since midnight 
    January 1, 2000 UTC, modulo 2^32). 
   </t>
  
   <t>
   This is an unsigned 32 bit integer in network byte order.
   </t>
  
   <t>
   The code for this option is TBD29.
   </t>
  
   <figure>
   <artwork>
  
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | OPTION_F_STATE_EXPIRATION_TIME|           option-len          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     state-expiration-time                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
  
   option-code       OPTION_F_STATE_EXPIRATION_TIME (TBD29).
   option-len        4.
   state-expiration-time  The state-expiration-time.  This MUST be an
                          absolute time (i.e. seconds since midnight 
                          January 1, 2000 UTC, modulo 2^32). 
   </artwork>
   </figure>
  
   </section>

   </section>

  <section anchor="status-list" title="Status Codes">


   <t>
      The following new status codes are defined, to be used in the
      OPTION_STATUS_CODE option.
   <list style="hanging">
        <t hangText="OneClientDifferentLeases (TBD30)"> <vspace/>
           The client on one server has resources that conflict with the 
           resources that this client has on the other server.</t>
        <t hangText="AddressInUseByOtherClient (TBD31)"> <vspace/>
           The one client on one server has leased resources that are in
           conflict with the resources that this client has leased on another
           server.</t>
        <t hangText="ConfigurationConflict (TBD32)"> <vspace/>
           The configuration implied by the information in a BNDUPD
           (e.g. the IPV6 address or prefix address)
           is in direct conflict with the information known to the
           receiving server.</t>
        <t hangText="MissingBindingInformation (TBD33)"> <vspace/>
           There is insufficient information in a BNDUPD to effectively
           process it.</t>
        <t hangText="OutdatedBindingInformation (TBD34)"> <vspace/>
           Returned when the information in a server's binding
           database conflicts with the information found in an incoming
           BNDUPD, and the server believes that the information in
           its binding database more accurately reflects reality.</t>
   </list>
   </t>


  </section>


</section>



<section title="Connection Management">
  <section anchor="create-connections" title="Creating Connections">
    <t>Every primary server implementing the failover protocol
    MUST attempt to connect to all of its partners periodically,
    where the period is implementation dependent and SHOULD be
    configurable.  In the event that a connection has been rejected
    by a CONNECTACK message with a reject-reason option contained
    in it or a DISCONNECT message, a server SHOULD reduce the
    frequency with which it attempts to connect to that server but
    it MUST continue to attempt to connect periodically.</t>

    <t>Every secondary server implementing the failover protocol
    MUST listen for connection attempts from the primary server.
    </t>

    <t>When a primary server successfully creates a TCP connection
    with a secondary server, it SHOULD attempt to negotiate a TLS
    <xref target="RFC5246"/>connection over the newly created TCP
    connection, as described in Section 8.2 of
    <xref target="I-D.ietf-dhc-dhcpv6-active-leasequery"/>.
    In the language of that section, the primary failover server
    operates as the "requestor" and the secondary failover server
    operates as the "DHCPv6 server".</t>

    <t>If a TLS connection is not negotiated, either server MAY
    choose to continue to establish a failover relationship or
    it MAY choose to refuse to proceed without a TLS connection.
    </t>

    <t>When a connection attempt succeeds, the primary server which
    has initiated the connection attempt MUST send a CONNECT message
    down the connection.  </t>

    <t>When a connection attempt is received by a secondary server, the only information
    that the secondary server has is the IP address of the partner
    initiating a connection.  If it has any relationships with the
    connecting server for which it is a secondary server, it should
    just await the CONNECT message or a STARTTLS message (see Section
    8.2 of
    <xref target="I-D.ietf-dhc-dhcpv6-active-leasequery"/>).
    Once it has received the CONNECT message, it will use the information
    in that message to determine which relationship this connection
    is to service.</t>
    
    <t>If it has no secondary relationships with the connecting
    server, it MUST drop the connection.  The goal is to limit
    the resources expended dealing with attempts to create a spurious
    failover connection.</t>

    <t>To summarize -- a primary server MUST use a connection that it has
    initiated in order to send a CONNECT message.  Every server that
    is a secondary server in a relationship MUST listen for CONNECT
    messages from the primary server.</t>

    <t>Once a connection is established, the primary server MUST send
    a CONNECT message across the connection.  A secondary server MUST
    wait for the CONNECT message from a primary server.  If the
    secondary server doesn't receive a CONNECT message from the
    primary server in an installation dependent amount of time, it MAY
    drop the connection.</t>

    <t>The secondary server responds to the CONNECT message with a
    CONNECTACK message indicating its response to request for a connection
    contained in the CONNECT message.</t>

    <t>When the CONNECT and CONNECTACK exchange successfully produces a
    working failover connection, the next message sent over a new connection 
    is a STATE message.  Upon the receipt of this message, the receiver can consider
    communications ok.</t>

  </section>

  <section title="Endpoint Identification">
     <t>A failover endpoint is always associated with a set
    of DHCPv6 prefixes that are configured on the DHCPv6 server where
    the endpoint appears.  A DHCPv6 prefix MUST NOT be associated with
    more than one failover endpoint.</t>

    <t>The failover protocol SHOULD be configured with one failover
    relationship between each pair of failover servers. In this
    case there is one failover endpoint for that relationship on
    each failover partner.  This failover relationship MUST have a
    unique name.</t>

    <t>Any failover endpoint can take actions and hold unique states.</t>

    <t>This document frequently describes the behavior of the protocol in
    terms of primary and secondary servers, not primary and secondary
    failover endpoints.  However, it is important to remember that every
    'server' described in this document is in reality a failover endpoint
    that resides in a particular process, and that several failover
    end-points may reside in the same server process.</t>

    <t>It is not the case that there is a unique failover endpoint
    for each prefix that participates in a failover relationship.
    On one server, there is (typically) one failover endpoint per
    partner, regardless of how many prefixes are managed by that
    combination of partner and role.  On a particular server, any
    given prefix that participates in failover will be associated
    with exactly one failover endpoint.</t>

    <t>When a connection is received from the partner, the unique failover
    endpoint to which the message is directed is determined solely by
    the IP address of the partner, the relationship-name, and the role
    of the receiving server.</t>

  </section>

 <section anchor="connection-parameters" title="Connection Maintenance Parameters">

    <t>
    The following parameters and timers are used to ensure the integrity
    of the connections between two failover servers.
    </t>

    <figure>
    <artwork>
   Parameter         Default   Description
   ------------------------------------------
   FO_RECEIVE_TIMER  timer     counts down to time connection
                               assumed dead due to lack of packets

   FO_RECEIVE_TIME   60        maximum time server will consider
                               connection still up with no packets

   FO_CONTACT_PER_RECEIVE_TIME number of CONTACT messages to send 
                     4         during partner's FO_RECEIVE_TIME 
                               period

   FO_SEND_TIMER     timer     counts down to time to send next 
                               CONTACT message

   FO_SEND_TIME      15        maximum time to wait between sending
                               CONTACT packets if no other traffic
                               Created from partner's FO_RECEIVE_TIME
                               divided by FO_CONTACT_PER_RECEIVE_TIME
    </artwork>
    </figure>

 </section>

 <section anchor="reachability" title="Unreachability detection">
 
   <t>Each partner MUST maintain an FO_SEND_TIMER for each failover
   connection. The FO_SEND_TIMER is reset to FO_SEND_TIME every
   time any message is transmitted, and counts down once per second.
   If the timer reaches zero, a CONTACT message is transmitted and
   timer is reset to FO_SEND_TIME.  The CONTACT message may be
   transmitted at any time. An implementation MAY use additional
   mechanisms to detect partner unreachability.</t>

   <t> The FO_SEND_TIME is initialized from the configured
   FO_RECEIVE_TIME divided by FO_CONTACT_PER_RECEIVE_TIME.  When a
   CONNECT or CONNECTACK message is received, the OPTION_F_RECEIVE_TIME
   option is checked, and if it appears then the value in that
   option is used to calculate the FO_SEND_TIME by dividing the
   value received by the configured FO_CONTACT_PER_RECEIVE_TIME.
   </t>

   <t> Each partner MUST maintain an FO_RECEIVE_TIMER for each
   failover connection.  This timer is initialized to FO_RECEIVE_TIME
   and counts down once per second.  It is reset to FO_RECEIVE_TIME
   whenever a packet is received. If it ever reaches zero, the
   connection is considered dead.  In addition, the FO_RECEIVE_TIME
   MUST be sent to the failover partner on every CONNECT or CONNECTACK
   messages, in the OPTION_F_RECEIVE_TIME option.
   </t>

 </section>


</section>



<section title="Binding Updates and Acks">

  <section anchor="time-bndupd" title="Times Required for Exchanging Binding Updates">
    <!-- tomek: here's the table from v4-failover-12, section 7.1:

                                        binding-status            BACKUP
                                                                  RESET
                                                                  ABANDONED
   Option                        ACTIVE     EXPIRED    RELEASED   FREE
   ======                        ======     =======    ========   ====
   assigned-IP-address (3)       MUST       MUST       MUST       MUST
   IP-flags                      MUST(4)    MUST(4)    MUST(4)    MUST(4)
   binding-status                MUST       MUST       MUST       MUST
   client-identifier             MAY        MAY        MAY        MAY(2)
   client-hardware-address       MUST       MUST       MUST       MAY(2)
   lease-expiration-time         MUST       MUST NOT   MUST NOT   MUST NOT
   potential-expiration-time     MUST       MUST NOT   MUST NOT   MUST NOT
   start-time-of-state           SHOULD     SHOULD     SHOULD     SHOULD
   client-last-trans.-time       MUST       SHOULD     MUST       MAY
   DDNS(1)                       SHOULD     SHOULD     SHOULD     SHOULD
   client-request-/soptions        SHOULD     SHOULD NOT SHOULD     SHOULD NOT
   client-reply-options          SHOULD     SHOULD NOT SHOULD NOT SHOULD NOT

   (1) MUST if server is performing dynamic DNS for this IP address, else
       MUST NOT.
   (2) MUST NOT if binding-status is ABANDONED.
   (3) assigned-IP-address MUST be the first option for an IP address
   (4) IP-flags option MUST appear if any flags are non-zero, else it
       MAY appear. -->


    <t>Each server must keep track of the following specific times beyond those
    required by the base DHCPv6 protocol <xref target="RFC3315" />.  
    <list style="hanging">
        <t hangText="failover-expire-time"> <vspace/>
           The greatest lifteime that this server has ever acked to its failover
           partner in a BNDACK.</t>
        <t hangText="failover-partner-lifetime"> <vspace/>
           The greatest lifetime that the failover partner has ever acked to
           this server in a BNDACK.</t>
        <t hangText="next-partner-lifetime"> <vspace/>
           The time that we want to send the partner, which will be the time 
           after which the partner can consider the IPv6 address expired.</t>
        <t hangText="client-last-transaction-time"> <vspace/>
           The time when the this server most recently intereacted with the
           client associated with this IP address.</t>
        <t hangText="partner-raw-clt-time"> <vspace/>
           The time when the partner most recently interacted with the client
           associated with this IP address.  This time remains exactly as it
           was received by this server, and it not adjusted to be in the time
           context of this server.</t>
        <t hangText="start-time-of-state"> <vspace/>
           The time when the binding status of this lease was changed 
           to its current value.</t>
        <t hangText="state-expiration-time"> <vspace/>
           The time when the current state of this lease will expire.</t>
    </list>
    </t>

  </section>

  <section anchor="send-bndupd" title="Sending Binding Updates">

    <t>Each server updates its failover partner about recent changes
       in lease states using the BNDUPD message.  Every BNDUPD
       message contains information about one or more client bindings.
       All information about a particular client binding is contained
       in a single OPTION_CLIENT_DATA option (see <xref target="RFC5007"/>
       Section 4.1.2.2).</t>

    <t>The OPTION_CLIENT_DATA option MUST contain
       at least the data shown below in its client-options section:
    <list style="symbols">
       <t>OPTION_CLIENTID containing the DUID of the client most 
          recently associated with this IP address*;</t>
       <t>OPTION_LQ_BASE_TIME containing the absolute time that the information
          was placed into this OPTION_CLIENT_DATA option.
          (see <xref target="I-D.ietf-dhc-dhcpv6-active-leasequery"/> Section 6.3.1);</t>
       <t>OPTION_F_RECONFIGURE_DATA
          containing the time and reconfigure key, if any*;</t>
       <t>OPTION_LQ_RELAY_DATA containing information described 
          in Section 4.1.2.4 of <xref target="RFC5007" />*;</t>
       <t>OPTION_IA_NA for an IPv6 Address or OPTION_IA_PD for an IPv6 Prefix. More
          than one of either of these options MAY appear if there are more 
          than one associated with this client;
         <list style="symbols">
            <t>IAID - Identity Association used by the client, while obtaining 
            a given lease. (Note1: one client may use many IAIDs
            simultaneously. Note2: IAID for IA, TA and PD are orthogonal
            number spaces.)*;</t>
            <t>T1 time sent to client*;</t>
            <t>T2 time sent to client*;</t>
            <t>Inside of the IA_NA-options or IA_PD-option sections:
            <list style="symbols">
               <t>
               OPTION_IAADDR for an IPv6 address or an OPTION_IAPREFIX for a IPv6 prefix;
               <list style="symbols">
                  <t>IPv6 Address or IPv6 Prefix (with length);</t>
                  <t>preferred lifetime sent to client*;</t>
                  <t>valid lifetime sent to client*;</t>
                  <t>Inside of the IAaddr-options or IAprefix-options:
                  <list style="symbols">
                     <t>OPTION_F_BINDING_STATUS containing the binding-status;</t>
                     <t>OPTION_F_START_TIME_OF_STATE containing the 
                        start-time-of-state;</t>
                     <t>OPTION_F_STATE_EXPIRATION_TIME containing the 
                        state-expiration-time**;</t>
                     <t>OPTION_CLT_TIME (relative) containing the 
                        client-last-transaction-time.  See <xref target="RFC5007" /> 
                        for this option*;</t> 
                     <t>OPTION_F_NEXT_PARTNER_LIFETIME (absolute) containing 
                        next-partner-lifetime*;</t>
                     <t>OPTION_F_PARTNER_RAW_CLT_TIME (absolute) 
                        containing the partner-raw-clt-time*;</t>
                     <t>OPTION_F_FAILOVER_EXPIRE_TIME (absolute) 
                        containing the failover-expire-time*;</t>
                     <t>DHCP_O_CLIENT_FQDN 
                        containing the the FQDN information associated with
                        this resource and client*;</t>
                  </list></t>
               </list></t>
            </list></t>
         </list></t>
    </list>
    Note that additonal data MAY be included beyond that listed above.  The
    IAddr_options or IAprefix-options area are the places where additional information
    should be included.
    </t>

    <t>Items marked with a single asterisk (*) MUST appear only if the resource is associated
    with a client. Otherwise it MUST NOT appear.</t>

    <t>Items marked with a double asterisk (**) MUST appear only if the value in the
    OPTION_F_BINDING_STATUS is associated with a timeout, otherwise it MUST NOT appear.</t>

   <t>The OPTION_CLT_TIME MUST,
   if it appears, be the time that the server last interacted
   with the DHCP client.  It MUST NOT be, for instance, the time
   that the lease on an IP address expired.  If there has been
   no interaction with the DHCP client in question (or there is
   no DHCP client presently associated with this resource), then
   there will be no OPTION_CLT_TIME option in the OPTION_CLIENT_DATA option</t>

    <t> A server
    SHOULD be prepared to clean up DNS information once the lease expires or is
    released. See <xref target="DDNS"/> for a detailed discussion about
    Dynamic DNS. Another reason the partner may be interested in keeping additional
    data is a better support for leasequery <xref target="RFC5007"/>, bulk
    leasequery <xref target="RFC5460"/> or active leasequery
    <xref target="I-D.ietf-dhc-dhcpv6-active-leasequery"/>,
    some of which features queries based on
    Relay-ID, by link address and by Remote-ID.</t>
  </section> <!-- sending binnding updates -->

  <section title="Receiving Binding Updates">

  <section anchor="correcting-time-skew" title="Correcting Time Skew">

    <t>Unless otherwise specified, all of the times discussed below are corrected
       to be in the time context of the receiving server, as follows:
       <list style="numbers">
          <t>The sent-time from the Failover message is compared with the
             current time of the receiving server.  The difference is noted,
             and used to affect the time correction.  It MAY be used directly
             as the time correction, but it SHOULD instead be used to 
             have a cumulative effect on the time correction.  This is
             called the time-correction.</t>
          <t>Any OPTION_LQ_BASE_TIME options in the BNDUPD message MUST
             be corrected with the time-correction.
             This is called the corrected-base-time.</t>
          <t>Any relative time values received in the BNDUPD MUST be
             added to or subtracted from the corrected-base-time.</t>
          <t>Any absolute time values received in the BNDUPD MUST be
             corrected with the time-correction</t>
       </list></t>
       <t>When all of this is done to an incoming time, that time can be
          before, after, or essentially the same as another time.  Any time
          which ends up being +/- 5 seconds of another time SHOULD be considered
          the same.</t>

 </section>


  <section anchor="processing-binding-updates" title="Processing Binding Updates">

     <t>When a BNDUPD is received each OPTION_CLIENT_DATA option
     is processed separately, and each must be independently
     accepted or rejected.</t>

      <t>When analyzing an OPTION_CLIENT_DATA option from a partner server, if
      there is insufficient information in the OPTION_CLIENT_DATA to process
      it, then reject the OPTION_CLIENT_DATA with "MissingBindingInformation".</t>

      <t>The server receiving a BNDUPD update from its partner must
      evaluate the received information in each OPTION_CLIENT_DATA
      option to see if it is consistent with already known state
      and decide which information - the previously known or that
      just received - is "better".  If the information in the BNDUPD
      is "better", the receiving server will accept the information
      in the BNDUPD.  If the information in the server's binding
      database is "better", the server will reject the information
      in the BNDUPD.</t>

   <t>A server receving a BNDUPD message MUST respond to the sender of that
      message with a BNDACK message which contains the same xid as the
      BNDUPD message.  This BNDACK message MUST contain one
      or more
      OPTION_CLIENT_DATA options, each of which corresponds to 
      one of the OPTION_CLIENT_DATA options in the BNDUPD message.</t>

     <t>Each OPTION_CLIENT_DATA in the BNDACK which is accepted SHOULD
     NOT contain an OPTION_STATUS_CODE unless a status message
     needs to be sent to the failover partner, in which case it
     SHOULD include an OPTION_STATUS_CODE option with a status
     code indicating success and whatever message is needed.
     </t>

     <t>To indicate rejection of the information
     in an OPTION_CLIENT_DATA, an OPTION_STATUS_CODE SHOULD be
     included with a status code indicating an error, in the
     OPTION_CLIENT_DATA option in the BNDACK message.</t>

 </section>

  <section anchor="accept-or-reject" title="Accept or Reject?">

     <t>The first task in processing the information in an
     OPTION_CLIENT_DATA option is extract the client information
     and resource information out of the OPTION_CLIENT_DATA option,
     and to access the resource (IP address or prefix) information
     in the server's binding database.</t>

      <t>If the resource specified in the OPTION_CLIENT_DATA is not
      a resource associated with the failover endpoint which received
      the OPTION_CLIENT_DATA option, then reject it with reject-reason
      "ConfigurationConflict".</t>

      <t>In general, acceptance or rejection is based around the
      comparison of two different time values, one from the
      OPTION_CLIENT_DATA and one from receiving server's binding
      database associated with the resource found in the
      OPTION_CLIENT_DATA.  The time for the OPTION_CLIENT_DATA is
      the OPTION_CLT_TIME if one appears, and the
      OPTION_F_START_TIME_OF_STATE if one does not.  The time for
      the resource in the server's binding database is the
      client-last-transaction-time, if one appears, and the
      start-time-of-state if one does not.</t>

      <t>The basic approach is to compare these times, and if the
      one from the OPTION_CLIENT_DATA is clearly later, then accept
      the information in the OPTION_CLIENT_DATA.  If the one from
      the server's binding database is clearly later, then reject
      the information in the OPTION_CLIENT_DATA.  The challenge
      comes when they are essentially the same (i.e., +/- 5 seconds).
      The table below (<xref target="tbl-conflict-resolution"/>)
      contains the rules for dealing with these situations.
   </t>

  <figure anchor="tbl-conflict-resolution" title="Conflict Resolution">
    <artwork><![CDATA[
                       binding-status in received OPTION_CLIENT_DATA
binding-status
in receiving                                      FREE        RESET
server           ACTIVE   EXPIRED   RELEASED   FREE_BACKUP  ABANDONED

ACTIVE           accept(4) time(2)   time(1)    time(2)      accept
EXPIRED          time(1)   accept    accept     accept       accept
RELEASED         time(1)   time(1)   accept     accept       accept
FREE/FREE_BACKUP accept    accept    accept     accept       accept
RESET            time(3)   accept    accept     accept       accept
ABANDONED        reject    reject    reject     reject       accept
]]></artwork></figure>

    <t>time(1): If the time value in the OPTION_CLIENT_DATA is later than
    the time value in the server's binding database, accept
    it, else reject it.</t>

    <t>time(2): If the current time is later than the receiving server's
    state-expiration-time, accept it, else reject it.</t>

    <t>time(3): If the OPTION_CLT_TIME value in the OPTION_CLIENT_DATA is later than
    the start-time-of-state in the receiving server's binding, accept it, else
    reject it.</t>

    <t>(1,2,3): If rejecting, use reject reason "OutdatedBindingInformation".</t>

    <t>(4): If the client in an OPTION_CLIENT_DATA option and in a receiving server's
    binding differ, then if the receiving server is a secondary accept it, else
    reject it with a reject reason of "AddressInUseByOtherClient".</t>

      <t>The lease update may be accepted or rejected.  Rejection
      SHOULD NOT change the flag in a lease that says that it should
      be transmitted to the failover partner.  If this flag is set,
      then it should be transmitted, but if it is not already set,
      the rejection of a lease state update SHOULD NOT trigger an
      automatic update of the failover partner sending the rejected
      update.  The potential for update storms is too great, and
      in the unusual case where the servers simply can't agree,
      that disagreement is better than an update storm.  </t>

    <!-- <t>Discussion: There will definitely be different types of update
      rejections. For example, this will allow a server to treat differently a
      case when receiving a new lease that it previously haven't seen than a
      case when partner sents old version of a lease for which a newer state is
      known.</t>-->
    </section>

    <section anchor="accepting-updates" title="Accepting Updates">



       <t>When the information in an OPTION_CLIENT_DATA option has been accepted, some
          of that information is stored in the receiving server's binding database, 
          and corresponding OPTION_CLIENT_DATA is entered into a BNDACK.  The
          information to enter into the OPTION_CLIENT_DATA in the BNDACK is described
          in <xref target="send-bndack"/>.</t>

       <t>The information contained in the accepted OPTION_CLIENT_DATA option
       is stored in the receiving server's binding database as follows:
       <list style="numbers">
          <t>The OPTION_CLIENTID is used to find the client.</t>
          <t>The other data contained in the top level of the OPTION_CLIENT_DATA
             option is stored with the client as appropriate.</t>
          <t>For each of the IA_NA or IA_PD options in the OPTION_CLIENT_DATA option
             and for each of the OPTION_IADDR or OPTION_IAPREFIX options in the 
             IA_* options:
             <list style="numbers">
                <t>OPTION_F_BINDING_STATUS is stored as the binding-status</t>
                <t>OPTION_F_NEXT_PARTNER_LIFETIME is stored in the 
                   failover-expire-time</t>
                <t>OPTION_F_STATE_EXPIRATION_TIME is stored in the
                   state-expiration-time</t>
                <t>OPTION_F_CLT_TIME (which MUST NOT be converted with the
                   corrected-base-time, but must be converted with the raw
                   value from the OPTION_LQ_BASE_TIME) is stored
                   in the partner-raw-clt-time</t>
                <t>OPTION_F_PARTNER_RAW_CLT_TIME (which MUST NOT be corrected with
                   the time-correction)
                   replaces the client-last-transaction-time if it is later
                   than the current client-last-transaction-time.</t>
                <t>OPTION_F_FAILOVER_EXPIRE_TIME replaced the failover-partner-lifetime
                   if it is later than the current failover-partner-lifetime.</t>
          </list></t>
       </list></t>




    </section>

  </section>

  <section anchor="send-bndack" title="Sending Binding Acks">

     <t>A server MUST respond to every BNDUPD message with a BNDACK
        message.  The BNDACK message MUST contain an OPTION_CLIENT_DATA
        option corresponding to every OPTION_CLIENT_DATA option in the
        BNDUPD message.  The BNDACK message MUST have the same xid
        as the BNDUPD message to which it is a response.
        Each OPTION_CLIENT_DATA option MUST contain
        at least the data shown below in its client-options section:
    <list style="symbols">
       <t>OPTION_CLIENTID containing the DUID of the client most 
          recently associated with this IP address*;</t>
       <t>OPTION_IA_NA for an IPv6 Address or OPTION_IA_PD for an IPv6 Prefix. More
          than one of either of these options MAY appear if there are more 
          than one associated with this client;
         <list style="symbols">
            <t>Inside of the IA_NA-options or IA_PD-option sections:
            <list style="symbols">
               <t>
               OPTION_IAADDR for an IPv6 address or an OPTION_IAPREFIX for a IPv6 prefix;
               <list style="symbols">
                  <t>IPv6 Address or IPv6 Prefix (with length);</t>
                  <t>Inside of the IAaddr-options or IAprefix-options:
                  <list style="symbols">
                     <t>OPTION_STATUS_CODE containing an error code, or
                        containing a success code if a message is required.
                        If the information in the corresponding OPTION_CLIENT_DATA 
                        in the BNDACK was accepted, and no status message was
                        required (which is the usual case), no OPTION_STATUS_CODE 
                        option appears.</t>
                     <t>OPTION_F_BINDING_STATUS containing the binding-status received
                        in the BNDUPD;</t>
                     <t>OPTION_F_STATE_EXPIRATION_TIME containing the 
                        state-expiration-time received in the BNDUPD;</t>
                     <t>OPTION_F_NEXT_PARTNER_LIFETIME (absolute) containing 
                        next-partner-lifetime recevied in the BNDUPD;</t>
                  </list></t>
               </list></t>
            </list></t>
         </list></t>
    </list>
    </t>

  </section>

  <section anchor="receive-bndack" title="Receiving Binding Acks">


     <t>When a BNDACK is received each OPTION_CLIENT_DATA option
        is processed separately, and each can either represent an
        ACK or a NAK.  If a particular OPTION_CLIENT_DATA option
        does not contain an OPTION_STATUS_CODE option, or if there
        is an OPTION_STATUS_CODE option which contains a success
        code, then the OPTION_CLIENT_DATA option represents
        an acknowledgement (ACK) that the BNDUPD was a success.</t>

     <t>Alternatively, the appearance of an OPTION_STATUS_CODE representing
        an error in an OPTION_CLIENT_DATA option indicates a NAK of the
        BNDUPD represented by the OPTION_CLIENT_DATA.</t>

     <t>The information contained in the BNDACK in an OPTION_CLIENT_DATA that
        represents an ACK is stored with the appropriate client and lease, as follows:
       <list style="numbers">
          <t>The OPTION_CLIENTID is used to find the client.</t>
          <t>For each of the IA_NA or IA_PD options in the OPTION_CLIENT_DATA option
             and for each of the OPTION_IADDR or OPTION_IAPREFIX options:
             <list style="numbers">
                <t>OPTION_STATUS_CODE if any is examined to see if it indicates
                   a BNDNAK.  If it indicates a BNDNAK for this client, do not
                   perform the rest of these steps.</t>
                <t>OPTION_F_NEXT_PARTNER_LIFETIME_SENT is stored in the 
                   failover-partner-lifetime</t>
          </list></t>
       </list></t>

       <t>The time next-partner-lifetime is set to 0.</t>


  </section>


    <section anchor="acknowledging-reception" title="Acknowledging Reception">

      <t>Upon acceptance of a binding lease, the server MUST notify its partner
      that it updated its binding database. A server MUST NOT send the BNDACK before its
      binding database is updated. A BNDACK MUST contain at lease the minimum set of information
      required to unambiguously identify the BNDUPD that triggered the BNDACK.</t>

    </section>

</section>




<section title="Resource Allocation">

    <t>This section discusses allocation details of the allocation
    of resources to specific clients.
    </t>


  <section anchor="reallocation" title="Re-allocating Leases">
    <!-- issue 4 
    TODO: Describe controlled re-allocation of released/expired
    leases to different clients.

    Done 10/16/12 Kim
    -->
    <!-- see section 5.2.2 in v4 failover -->

    <t>When in PARTNER-DOWN state there is a waiting period after
    which a resource can be re-allocated to another client.  For
    resources which are available when the server enters PARTNER-DOWN
    state, the period is the MCLT from the entry into PARTNER-DOWN
    state.  For resources which are not available when the server
    enters PARTNER-DOWN state, the period is the MCLT after the
    later of the following times: the failover-partner-lifetime, the
    next-partner-lifetime (if any), and the failover-expire-time.
    If this time would be earlier than the current time
    plus the MCLT, then the time the server entered PARTNER-DOWN
    state plus the maximum-client-lead-time is used.</t>

    <!-- I don't think we want to discuss these paragraphs from the
     v4 draft.  Experience shows that nobody wants to live with MCLT
     restrictions in PARTNER-DOWN state.

    Two options exist for lease times given out while in PARTNER-DOWN
    state, with different ramifications flowing from each.

    If the server wishes the Failover protocol to protect it from loss of
    stable storage in PARTNER-DOWN state, then it should ensure that the
    MCLT based lease time restrictions in section 5.1 are maintained,
    even in PARTNER-DOWN state.

    If the server wishes to forego the protection of the Failover proto-
    col in the event of loss of stable storage, then it need recognize no
    restrictions on actual client lease times while in PARTNER-DOWN
    state.

    -->

    <t>In any other state, a server cannot reallocate a resource from one
    client to another without first notifying its partner (through a
    BNDUPD message) and receiving acknowledgement (through a BNDACK message) 
    that its partner is aware that that first client is not using
    the resource.</t>

    <t>This may be modeled in the following way.</t>

    <t>An "available" resource on a server may be allocated to any client.
    A resource which was leased to a client and which expired or was
    released by that client would take on a new state, EXPIRED or
    RELEASED respectively.  The partner server would then be notified
    that this resource was EXPIRED or RELEASED through a BNDUPD.  When
    the sending server received the BNDACK for that resource showing it
    was FREE, it would move the resource from EXPIRED or RELEASED to
    FREE, and it would be available for allocation by the primary server
    to any clients.</t>

    <t>A server MAY reallocate a resource in the EXPIRED or RELEASED
    state to the same client with no restrictions provided it has not
    sent a BNDUPD message to its partner.  This situation would exist if
    the lease expired or was released after the transition into
    PARTNER-DOWN state, for instance.</t>

  </section>


</section> <!-- partner update -->

  <section anchor="states" title="Endpoint States">
    <section anchor="state-machine-operation" title="State Machine Operation">

      <t>Each server (or, more accurately, failover endpoint) can take
      on a variety of failover states.  These states play a crucial role
      in determining the actions that a server will perform when
      processing a request from a DHCPv6 client as well as dealing with
      changing external conditions (e.g., loss of connection to a failover
      partner).</t>

      <t> The failover state in which a server is running controls the following
      behaviors: </t>
        <t><list style="symbols">

          <t>Responsiveness -- the server is either responsive to DHCPv6
          client requests or it is not.</t>

          <t>Allocation Pool -- which pool of addresses (or prefixes) can be
          used for advertisement on receipt of a SOLICIT or allocation on receipt
          of a REQUEST message.</t>

          <t>MCLT -- ensure that valid lifetimes are not beyond what the partner
          has acked plus the MCLT (or not).</t>

        </list></t>

      <t>A server will transition from one failover state to another based
      on the specific values held by the following state variables:</t>

        <t><list style="symbols">

          <t>Current failover state.</t>

          <t>Communications status (OK or not OK).</t>

          <t>Partner's failover state (if known).</t>

        </list></t>

      <t>Whenever any of the above state variables
      changes state, the state machine is invoked, which may then trigger a
      change in the current failover state.  Thus, whenever the communications
      status changes, the state machine processing is invoked.  This may or
      may not result in a change in the current failover state.</t>

      <t>Whenever a server transitions to a new failover state, the new state
      MUST be communicated to its failover partner in a STATE message if the
      communications status is OK.  In addition, whenever a server makes a
      transition into a new state, it MUST record the new state, its current
      understanding of its partner's state, and the time at which it entered the
      new state in stable storage.</t>

      <t>The following state transition diagram gives a condensed view of the
      state machine.  If there is a difference between the words describing a
      particular state and the diagram below, the words should be considered
      authoritative.</t>

      <t>In the diagram below, the word (responsive) or (unresponsive) appers
      in the states, and refers to whether the server in this state is allowed
      to respond to client DHCP requests.</t>

      <t>In the state transition diagram below, the "+" or "-" in the upper
      right corner of each state is a notation about whether communication is
      ongoing with the other server.

      <!-- that's an ugly hack: add couple extra lines here, so the diagram
      ends on a new page -->
      <vspace blankLines="8"/>
      </t>

    <figure anchor="endpoint-state-machine" title="Failover Endpoint State Machine">
    <artwork>
    <![CDATA[
    +---------------+  V  +--------------+
    |    RECOVER -|+|  |  |   STARTUP  - |
    |(unresponsive) |  +->+(unresponsive)|
    +------+--------+     +--------------+
    +-Comm. OK             +-----------------+
    |     Other State:     |  PARTNER DOWN - +<---------------------+
    |    RESOLUTION-INTER. | (responsive)    |                      ^
   All     POTENTIAL-      +----+------------+                      |
  Others   CONFLICT------------ | --------+                         |
    |      CONFLICT-DONE     Comm. OK     |     +--------------+    |
 UPDREQ or                 Other State:   |  +--+ RESOLUTION - |    |
 UPDREQALL                  |       |     |  |  | INTERRUPTED  |    |
 Rcv UPDDONE             RECOVER    All   |  |  | (responsive) |    |
    |  +---------------+    |      Others |  |  +------------+-+    |
    +->+RECOVER-WAIT +-| RECOVER    |     |  |         ^     |      |
       |(unresponsive) |  WAIT or   |     |  Comm.     |    Ext.    |
       +-----------+---+  DONE      |     |  OK     Comm.   Cmd---->+
Comm.---+     Wait MCLT     |       V     V  V     Failed           |
Changed |          V    +---+   +---+-----+--+-+       |            |
 |  +---+----------++   |       |  POTENTIAL + +-------+            |
 |  |RECOVER-DONE +-|  Wait     |  CONFLICT    +------+             |
 +->+(unresponsive) |  for      |(unresponsive)|   Primary          |
    +------+--------+  Other  +>+----+--------++   resolve    Comm. |
     Comm. OK          State: |      |        ^    conflict  Changed|
+---Other State:-+   RECOVER  |   Secondary   |       V       V   | |
|    |           |     DONE   |    resolve    |  ++----------+---++ |
| All Others:  POTENT.  |     |   conflict    |  |CONFLICT-DONE-|+| |
| Wait for    CONFLICT--|-----+      |        |  | (responsive)   | |
| Other State:          V            V        |  +------+---------+ |
| NORMAL or RECOVER    ++------------+---+    | Other State: NORMAL |
|    |       DONE      |     NORMAL    + +<--------------+          |
|    +--+----------+-->+  (responsive)   +-------External Command-->+
|       ^          ^   +--------+--------+                          |
|       |          |            |             |                     |
|   Wait for   Comm. OK  Comm. Failed         |                     |
|    Other      Other           |             |             External
|    State:     State:          |             |             Command
| RECOVER-DONE  NORMAL     Start Safe      Comm. OK            or
|       |     COMM. INT.  Period Timer    Other State:        Safe
|    Comm. OK.     |            V          All Others        Period
|   Other State:   |  +---------+--------+    |            expiration
|     RECOVER      +--+ COMMUNICATIONS - +----+                     |
|       +-------------+   INTERRUPTED    |                          |
RECOVER               |  (responsive)    +------------------------->+
RECOVER-WAIT--------->+------------------+
]]></artwork></figure>

    </section> <!-- state-machine-operation -->

    <section anchor="state-init" title="State Machine Initialization">

      <t>The state machine is characterized by storage (in stable storage) of at least the
      following information:</t>

        <t><list style="symbols">

          <t>Current failover state.</t>

          <t>Previous failover state.</t>

          <t>Start time of current failover state.</t>

          <t>Partner's failover state.</t>

          <t>Start time of partner's failover state.</t>

          <t>Time most recent packet received from partner.</t>

        </list></t>

      <t>The state machine is initialized by reading these data items
      from stable storage and restoring their values from the information
      saved.  If there is no information in stable storage concerning these
      items, then they should be initialized as follows:</t>

        <t><list style="symbols">

          <t>Current failover state:  Primary: PARTNER-DOWN, Secondary: RECOVER</t>

          <t>Previous failover state:  None.</t>

          <t>Start time of current failover state: Current time.</t>

          <t>Partner's failover state: None until reception of STATE message.</t>

          <t>Start time of partner's failover state: None until reception of STATE message.</t>

          <t>Time most recent packet received from partner: None until packet received.</t>

        </list></t>

    </section>

    <section anchor="state-startup" title="STARTUP State">

      <t>The STARTUP state affords an opportunity for a server to
      probe its partner server, before starting to service DHCP
      clients.  When in the STARTUP state, a server attempts to
      learn its partner's state and determine (using that information
      if it is available) what state it should enter.</t>

      <t>The STARTUP state is not shown with any specific state
      transitions in the <xref target="endpoint-state-machine">state machine
      diagram</xref> because the processing during the STARTUP state
      can cause the server to transition to any of the other states,
      so that specific state transition arcs would only obscure
      other information.</t>

      <section anchor="operation-in-startup-state" title="Operation in STARTUP State">

        <t>The server MUST NOT be responsive to DHCPv6 clients in STARTUP state.</t>

        <t>Whenever a STATE message is sent to the partner while
        in STARTUP state the STARTUP flag MUST be set in the message
        and the previously recorded failover state MUST be placed
        in the server-state option.</t>

      </section> <!-- operation-in-startup-state -->

      <section anchor="transition-out-of-startup-state" title="Transition Out of STARTUP State">

        <t>The following algorithm is followed every time the
        server initializes itself, and enters STARTUP state.</t>

        <t>Step 1:</t>

        <t>If there is any record in stable storage of a previous
        failover state for this server, set PREVIOUS-STATE to the
        last recorded value in stable storage, and go to Step 2.</t>

        <t>If there is no record of any previous failover state in
        stable storage for this server, then set the PREVIOUS-STATE
        to RECOVER and set the TIME-OF-FAILURE to 0.  This will
        allow two servers which already have lease information to
        synchronize themselves prior to operating.</t>

        <t>In some cases, an existing server will be commissioned
        as a failover server and brought back into operation where
        its partner is not yet available.  In this case, the newly
        commissioned failover server will not operate until its
        partner comes online  -- but it has operational responsibilities
        as a DHCP server nonetheless.  To properly handle this
        situation, a server SHOULD be configurable in such a way
        as to move directly into PARTNER-DOWN state after the startup
        period expires if it has been unable to contact its partner
        during the startup period.</t>

        <t>Step 2:</t>

        <t>Implementations will differ in the ways that they deal
        with the state machine for failover endpoint states.  In
        many cases, state transitions will occur when communications
        goes from "OK" to failed, or from failed to "OK", and some
        implementations will implement a portion of their state
        machine processing based on these changes.</t>
        
        <t>In these cases, during startup, if the previous state
        is one where communications was "OK", then set the previous
        state to the state that is the result of the communications
        failed state transition when in that state (if such transition
        exists -- some states don't have a communications failed
        state transition, since they allow both communications OK
        and failed).</t>

        <t>Step 3:</t>

        <t>Start the STARTUP state timer.  The time that a server
        remains in the STARTUP state (absent any communications
        with its partner) is implementation dependent but SHOULD
        be short.  It SHOULD be long enough for a TCP connection
        to be created to a heavily loaded partner across a slow
        network.</t>

        <t>Step 4:</t>

        <t>If the server is a primary server: attempt to create a 
           TCP connection to the failover partner.  If the server is
           a secondary server, listen on the failover port and wait
           for the primary server to connect.  See 
           <xref target="create-connections"/>.</t>  

        <t>Step 5:</t>

        <t>Wait for "communications OK".</t>

        <t>When and if communications become "OK", clear the STARTUP
        flag, and set the current state to the PREVIOUS-STATE.</t>

        <t>If the partner is in PARTNER-DOWN state, and if the time
        at which it entered PARTNER-DOWN state (as received in the
        start-time-of-state option in the STATE message) is later
        than the last recorded time of operation of this server,
        then set CURRENT-STATE to RECOVER.  If the time at which
        it entered PARTNER-DOWN state is earlier than the last
        recorded time of operation of this server, then set
        CURRENT-STATE to POTENTIAL-CONFLICT.</t>

        <t>Then, transition to the current state and take the
        "communications OK" state transition based on the current
        state of this server and the partner.</t>

        <t>Step 6:</t>

        <t>If the startup time expires prior to communications 
           becoming "OK", the server SHOULD transition
        to the PREVIOUS-STATE.</t>

      </section> <!-- transition-out-of-startup-state -->

    </section> <!-- end of STARTUP state -->

    <section anchor="state-partner-down" title="PARTNER-DOWN State">

    <t>PARTNER-DOWN state is a state either server can enter.  When
    in this state, the server assumes that it is the only server
    operating and serving the client base. If one server is in
    PARTNER-DOWN state, the other server MUST NOT be operating.</t>

    <t>A server can enter PARTNER-DOWN state either as a result of 
    operator intervention (when an operator determines that the server's
    partner is, indeed, down), or as a result of an optional auto-partner-down
    capability where PARTNER-DOWN state is entered automatically after
    a server has been in COMMUNICATIONS-INTERRUPTED state for a pre-determined
    period of time.</t>

      <section anchor="operation-in-partner-down-state" title="Operation in PARTNER-DOWN State">

        <t>The server MUST be responsive in PARTNER-DOWN state, regardless
        if it is primary or secondary.</t>

        <t>It will allow renewal of all outstanding leases on resources.
        For those resources for which the server is
        using proportional allocation (i.e. prefixes), it will allocate resources
        from its own pool, and after a fixed period of time (the
        MCLT interval) has elapsed from entry into PARTNER-DOWN
        state, it may allocate IP addresses from the set of all
        available pools. Server SHOULD fully deplete its own pool,
        before starting allocations from its downed partner's pool.</t>

        <t>Any resource tagged as available for allocation by the
        other server (at entry to PARTNER-DOWN state) MUST NOT be
        allocated to a new client until the MCLT
        beyond the entry into PARTNER-DOWN state has elapsed.</t>

        <t>A server in PARTNER-DOWN state MUST NOT allocate a resource
        to a DHCP client different from that to which it was
        allocated at the entrance to PARTNER-DOWN state until the
        MCLT beyond the maximum of the following
        times: client expiration time, most recently transmitted
        potential-expiration-time, most recently received ack of
        potential-expiration-time from the partner, and most recently
        acked potential-expiration-time to the partner.  <!-- tomek:
        commented out as don't have section about BNDUPD message yet.
        See section 7.1.5 for details. --> If this time would be earlier
        than the current time plus the maximum-client-lead-time, then
        the time the server entered PARTNER-DOWN state plus the
        maximum-client-lead-time is used.</t>

        <t>The server is not restricted by the MCLT when offering
        lease times while in PARTNER-DOWN state.</t>

        <t>In the unlikely case when there are two servers operating
        in a PARTNER-DOWN state, there is a chance of duplicate leases
        for the same prefix to be
        assigned. This leads to a POTENTIAL-CONFLICT (unresponsive)
        state when they re-establish contact. The duplicate lease
        issue can be postponed to a large extent by the server granting
        new leases first from its own pool. Therefore the server operating
        in PARTNER-DOWN state MUST use its own pool first for new
        leases before assigning any leases from its downed partner pool.
        </t>

      </section> <!-- operation-in-partner-down-state -->

      <section anchor="transition-out-of-partner-down-state" title="Transition Out of PARTNER-DOWN State">

        <t>When a server in PARTNER-DOWN state succeeds in establishing
        a connection to its partner, its actions are conditional
        on the state and flags received in the STATE message from
        the other server as part of the process of establishing the
        connection.</t>

        <t>If the STARTUP bit is set in the server-flags option of
        a received STATE message, a server in PARTNER-DOWN state
        MUST NOT take any state transitions based on reestablishing
        communications. Essentially, if a server is in PARTNER-DOWN
        state, it ignores all STATE messages from its partner that
        have the STARTUP bit set in the server-flags option of the
        STATE message.</t>

        <t>If the STARTUP bit is not set in the server-flags option
        of a STATE message received from its partner, then a server
        in PARTNER-DOWN state takes the following actions based on
        the state of the partner as received in a STATE message
        (either immediately after establishing communications or
        at any time later when a new state is received)</t>

        <t><list style="symbols">

        <t>If the partner is in: [ NORMAL, COMMUNICATIONS-INTERRUPTED, PARTNER-DOWN,
        POTENTIAL-CONFLICT, RESOLUTION-INTERRUPTED, or CONFLICT-DONE ]
        state, then transition to POTENTIAL-CONFLICT state</t>

        <t>If the partner is in: [ RECOVER, RECOVER-WAIT ] state stay in PARTNER-DOWN state</t>

        <t>If the partner is in: [ RECOVER-DONE ] state transition into NORMAL state</t>

        </list></t>

      </section> <!-- transition-out-of-partner-down-state -->

    </section> <!-- end of partner-down state -->

    <section anchor="state-recover" title="RECOVER State">

      <t>This state indicates that the server has no information
      in its stable storage or that it is re-integrating with a
      server in PARTNER-DOWN state after it has been down.  A server
      in this state MUST attempt to refresh its stable storage from
      the other server.</t>

      <section anchor="operation-in-recover-state" title="Operation in RECOVER State">

        <t>The server MUST NOT be responsive in RECOVER state.</t>

        <t>A server in RECOVER state will attempt to reestablish
        communications with the other server.</t>

      </section> <!-- operation-in-recover-state -->

      <section anchor="transition-out-of-recover-state" title="Transition Out of RECOVER State">

        <t>If the other server is in POTENTIAL-CONFLICT,
        RESOLUTION-INTERRUPTED, or CONFLICT-DONE state when
        communications are reestablished, then the server in RECOVER
        state will move to POTENTIAL-CONFLICT state itself.</t>

        <t>If the other server is in any other state, then the
        server in RECOVER state will request an update of missing
        binding information by sending an UPDREQ message.  If the
        server has determined that it has lost its stable storage
        because it has no record of ever having talked to its
        partner, while its partner does have a record of communicating
        with it, it MUST send an UPDREQALL message, otherwise it
        MUST send an UPDREQ message.</t>

        <t>It will wait for an UPDDONE message, and upon receipt
        of that message it will transition to RECOVER-WAIT state.</t>

        <t>If communications fails during the reception of the
        results of the UPDREQ or UPDREQALL message, the server will
        remain in RECOVER state, and will re-issue the UPDREQ or
        UPDREQALL when communications are re-established.</t>

        <t>If an UPDDONE message isn't received within an implementation
        dependent amount of time, and no BNDUPD messages are being
        received, the connection SHOULD be dropped.</t>

        <figure anchor="figure-transition-out-of-recover-state" title="Transition out of RECOVER state">
        <artwork><![CDATA[
                A                                        B
              Server                                  Server

                |                                        |
             RECOVER                               PARTNER-DOWN
                |                                        |
                | >--UPDREQ-------------------->         |
                |                                        |
                |        <---------------------BNDUPD--< |
                | >--BNDACK-------------------->         |
               ...                                      ...
                |                                        |
                |        <---------------------BNDUPD--< |
                | >--BNDACK-------------------->         |
                |                                        |
                |        <--------------------UPDDONE--< |
                |                                        |
           RECOVER-WAIT                                  |
                |                                        |
                | >--STATE-(RECOVER-WAIT)------>         |
                |                                        |
                |                                        |
       Wait MCLT from last known                         |
          time of failover operation                     |
                |                                        |
           RECOVER-DONE                                  |
                |                                        |
                | >--STATE-(RECOVER-DONE)------>         |
                |                                     NORMAL
                |        <-------------(NORMAL)-STATE--< |
             NORMAL                                      |
                | >---- State-(NORMAL)--------------->   |
                |                                        |
                |                                        |
        ]]></artwork></figure>


        <t>If at any time while a server is in RECOVER state
        communications fails, the server will stay in RECOVER state.
        When communications are restored, it will restart the process
        of transitioning out of RECOVER state.</t>

      </section> <!-- transition-out-of-recover-state -->

    </section> <!-- end of recover state -->

    <section anchor="state-recover-wait" title="RECOVER-WAIT State">

      <t>This state indicates that the server has sent an UPDREQ
      or UPDREQALL and has received the UPDDONE message indicating
      that it has received all outstanding binding update information.
      In the RECOVER-WAIT state the server will wait for the MCLT
      in order to ensure that any processing that this server might
      have done prior to losing its stable storage will not cause
      future difficulties.</t>

      <section anchor="operation-in-recover-wait-state" title="Operation in RECOVER-WAIT State">

        <t>The server MUST NOT be responsive in RECOVER-WAIT state.</t>

      </section> <!-- operation-in-recover-wait-state -->

      <section anchor="transition-out-of-recover-wait-state" title="Transition Out of RECOVER-WAIT State">

        <t>Upon entry to RECOVER-WAIT state the server MUST start
        a timer whose expiration is set to a time equal to the time
        the server went down (if known) or the time the server
        started (if the down-time is unknown) plus the
        maximum-client-lead-time.  When this timer expires, the
        server will transition into RECOVER-DONE state.</t>

        <t>This is to allow any IP addresses that were allocated
        by this server prior to loss of its client binding information
        in stable storage to contact the other server or to time
        out.</t>

        <t>If this is the first time this server has run failover
        -- as determined by the information received from the
        partner, not necessarily only as determined by this server's
        stable storage (as that may have been lost), then the waiting
        time discussed above may be skipped, and the server MAY
        transition immediately to RECOVER-DONE state.</t>

        <t>If the server has never before run failover, then there
        is no need to wait in this state -- but, again, to determine
        if this server has run failover it is vital that the
        information provided by the partner be utilized, since the
        stable storage of this server may have been lost.</t>

        <t>If communications fails while a server is in RECOVER-WAIT
        state, it has no effect on the operation of this state.
        The server SHOULD continue to operate its timer, and if the
        timer expires during the period where communications with
        the other server have failed, then the server SHOULD
        transition to RECOVER-DONE state.  This is rare -- failover
        state transitions are not usually made while communications
        are interrupted, but in this case there is no reason to
        inhibit the timer.</t>

      </section> <!-- transition-out-of-recover-wait-state -->

    </section> <!-- recover-wait state -->

    <section anchor="state-recover-done" title="RECOVER-DONE State">

      <t>This state exists to allow an interlocked transition for
      one server from RECOVER state and another server from
      PARTNER-DOWN or COMMUNICATIONS-INTERRUPTED state into NORMAL
      state.</t>

      <section anchor="operation-in-recover-done-state" title="Operation in RECOVER-DONE State">

        <t>A server in RECOVER-DONE state SHOULD be unresponsive, but MAY 
        respond to RENEW requests but MUST only change the state of resources
        that appear in the RENEW request.  It MUST NOT allocate any additional
        resources when in RECOVER-DONE state.</t>

      </section> <!-- operation-in-recover-done-state -->

      <section anchor="transition-out-of-recover-done-state"
               title="Transition Out of RECOVER-DONE State">

        <t>When a server in RECOVER-DONE state determines that its
        partner server has entered NORMAL or RECOVER-DONE state,
        then it will transition into NORMAL state.</t>

        <t>If communication fails while in RECOVER-DONE state, a
        server will stay in RECOVER-DONE state.</t>

      </section> <!-- transition-out-of-recover-done-state -->

    </section> <!-- recover-done state -->

    <section anchor="state-normal" title="NORMAL State">
      <t>NORMAL state is the state used by a server when it is communicating
      with the other server, and any required resynchronization has been
      performed. While some bindings database synchronization is performed
      in NORMAL state, potential conflicts are resolved prior to entry into
      NORMAL state as is binding database data loss.</t>

      <t>When entering NORMAL state, a server will send to the other server
      all currently unacknowledged binding updates as BNDUPD messages.</t>

      <t>When the above process is complete, if the server entering NORMAL
      state is a secondary server, then it will request resources (prefixes) 
      for allocation using the POOLREQ message.</t>

      <section anchor="operation-in-normal-state"
               title="Operation in NORMAL State">

      <t>The primary server is responsive in NORMAL state. The secondary is
      unresponsive in NORMAL state.</t>

        <t>When in NORMAL state a primary server will operate in the following manner:
      <list style="hanging">
        <t hangText="Lease time calculations"> <vspace/>

        As discussed in 
        <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>, the
        lease interval given to a DHCP client can never be more than the
        MCLT greater than the most recently received 
        potential-expiration-time from the failover partner or the current time,
        whichever is later.
        <vspace blankLines="1"/>
        As long as a server adheres to this constraint, the specifics of
        the lease interval that it gives to a DHCP client or the value
        of the potential-expiration-time sent to its failover partner
        are implementation dependent.</t>

        <t hangText="Lazy update of partner server"> <vspace/>

        After sending a REPLY that includes a lease update to a client,
        the server servicing a DHCP client request attempts to update
        its partner with the new binding information.</t> 

        <t hangText="Reallocation of resources between clients"> <vspace/>

        Whenever a client binding is released or expires, a BNDUPD
        message must be sent to the partner, setting the binding
        state to RELEASED or EXPIRED.  However, until a BNDACK is
        received for this message, the resource cannot be allocated
        to another client.  It cannot be allocated to the same client
        again if a BNDUPD was sent, otherwise it can. See <xref
        target="reallocation"/> for details.
        </t>
      </list>
      </t>

      <t>In NORMAL state, each server receives binding updates from
      its partner server in BNDUPD messages. It records these in its
      binding database in stable storage and then sends a
      corresponding BNDACK message to its partner server.</t>

      </section> <!-- operation-in-normal-state -->
      <section anchor="transition-out-of-normal-state"
               title="Transition Out of NORMAL State">
        <t>If an external command is received by a server in NORMAL
        state informing it that its partner is down, then transition
        into PARTNER- DOWN state.  Generally, this would be an unusual
        situation, where some external agency knew the partner server
        was down prior to the failover server discovering it on its
        own.</t>  
        <!-- Does it make sense? That is at least strange - server maintain
        connection with its parner and suddenly operator states that that
        partner is down. -->

        <t>If a server in NORMAL state fails to receive acks to messages sent to
        its partner for an implementation dependent period of time, it MAY
        move into COMMUNICATIONS-INTERRUPTED state.  This situation might
        occur if the partner server was capable of maintaining the TCP connection 
        between the server and also capable of sending a CONTACT message 
        periodically, but was (for some reason) incapable of processing 
        BNDUPD messages.</t>

        <t>If the communications is determined to not be "ok" (as
        defined in <xref target="reachability"/>), then transition
        into COMMUNICATIONS-INTERRUPTED state.</t>

        <t>If a server in NORMAL state receives any messages from its partner
        where the partner has changed state from that expected by the server
        in NORMAL state, then the server should transition into
        COMMUNICATIONS-INTERRUPTED state and take the appropriate state transition 
        from there.  For example, it would be expected for the partner
        to transition from POTENTIAL-CONFLICT into NORMAL state, but not for
        the partner to transition from NORMAL into POTENTIAL-CONFLICT state.</t>

        <t><!-- we don't need PAUSED If a server in NORMAL state
        receives any messages from its partner where the PARTNER has
        changed into PAUSED state, the server should transition into
        COMMUNICATIONS-INTERRUPTED state. -->If a server in NORMAL
        state receives a DISCONNECT message from its partner, the server should transition
        into COMMUNICATIONS-INTERRUPTED state.</t>
      </section> <!-- transition-out-of-normal-state -->
    </section> <!-- normal state -->

    <section anchor="state-comm-interrrupted"
             title="COMMUNICATIONS-INTERRUPTED State">
      <t>A server goes into COMMUNICATIONS-INTERRUPTED state whenever it is
      unable to communicate with its partner. Primary and secondary
      servers cycle automatically (without administrative intervention)
      between NORMAL and COMMUNICATIONS-INTERRUPTED state as the network
      connection between them fails and recovers, or as the partner server
      cycles between operational and non-operational.  No duplicate resource
      allocation can occur while the servers cycle between these
      states.</t>

      <t>When a server enters COMMUNICATIONS-INTERRUPTED state, if it has been
      configured to support an automatic transition out of COMMUNICATIONS-
      INTERRUPTED state and into PARTNER-DOWN state (i.e., a auto-partner-down
      has been configured), then a timer MUST be started
      for the length of the configured auto-partner-down period.</t>
      <!-- tomek: Issue 15: do we want auto-partner-down timer? -->

      <t>A server transitioning into the COMMUNICATIONS-INTERRUPTED
      state from the NORMAL state SHOULD raise some alarm condition to
      alert administrative staff to a potential problem in the DHCP
      subsystem.</t>

      <section anchor="operation-in-comm-interrupted-state"
               title="Operation in COMMUNICATIONS-INTERRUPTED State">

        <t>In this state a server MUST respond to all DHCP client
        requests.  When allocating new leases, each server allocates
        from its own pool, where the primary MUST allocate only FREE
        resources, and the secondary MUST
        allocate only FREE_BACKUP resources.  When
        responding to RENEW messages, each server will allow continued
        renewal of a DHCP client's current lease on a resource
        irrespective of whether that lease was given out by the
        receiving server or not, although the renewal period MUST NOT
        exceed the maximum client lead time (MCLT) beyond the latest
        of: 1) the potential valid lifetime already acknowledged by
        the other server, or 2) now, or 3) the potential valid lifetime 
        received from the partner server.</t>

        <t>However, since the server cannot communicate with its
        partner in this state, the acknowledged potential valid
        lifetime will not be updated in any new bindings.  This is
        likely to eventually cause the actual valid lifetimes to
        converge to the MCLT (unless this is greater than
        the desired-client-lease-time).</t>

        <t>The server should continue to try to establish a connection
        with its partner.</t>

      </section> <!-- operation-in-comm-interrrupted-state -->
      <section anchor="transition-out-of-comm-interrrupted-state"
               title="Transition Out of COMMUNICATIONS-INTERRUPTED State">

        <t>If the safe period timer expires while a server is in the
        COMMUNICATIONS-INTERRUPTED state, it will transition immediately into
        PARTNER-DOWN state.</t>

        <t>If an external command is received by a server in COMMUNICATIONS-
        INTERRUPTED state informing it that its partner is down, it will
        transition immediately into PARTNER-DOWN state.</t>

        <t>If communications is restored with the other server, then the server
        in COMMUNICATIONS-INTERRUPTED state will transition into another
        state based on the state of the partner:

        <list style="symbols">
          <t>NORMAL or COMMUNICATIONS-INTERRUPTED: Transition into the
          NORMAL state.</t>
          <!-- The partner SHOULD NOT be in NORMAL state here, since upon res-
          toration of communications it MUST have created a new TCP con-
          nection which would have forced it into COMMUNICATIONS-
          INTERRUPTED state.  Still, we should account for every state
          just in case. -->

          <t>RECOVER: Stay in COMMUNICATIONS-INTERRUPTED state.</t>

          <t>RECOVER-DONE: Transition into NORMAL state.</t>

          <t>PARTNER-DOWN, POTENTIAL-CONFLICT, CONFLICT-DONE, or
          RESOLUTION-INTERRUPTED: Transition into POTENTIAL-CONFLICT
          state.</t>

        </list></t>

        <t>The following figure illustrates the transition from NORMAL
        to COMMUNICATIONS-INTERRUPTED state and then back to NORMAL
        state again.</t>

        <!-- this title is too long. That should be a caption field -->
        <figure anchor="state-change-example" title="Transition from NORMAL to
         COMMUNICATIONS-INTERRUPTED and back (example with 2 prefixes
         allocated to secondary)">
          <artwork><![CDATA[
   Primary                                Secondary
    Server                                  Server

    NORMAL                                  NORMAL
      | >--CONTACT------------------->         |
      |        <--------------------CONTACT--< |
      |         [TCP connection broken]        |
 COMMUNICATIONS          :              COMMUNICATIONS
   INTERRUPTED           :                INTERRUPTED
      |      [attempt new TCP connection]      |
      |         [connection succeeds]          |
      |                                        |
      | >--CONNECT------------------->         |
      |        <-----------------CONNECTACK--< |
      |                                     NORMAL
      |        <-------------------STATE-----< |
    NORMAL                                     |
      | >--STATE--------------------->         |
      |
      | >--BNDUPD-------------------->         |
      |        <---------------------BNDACK--< |
      |                                        |
      |        <---------------------BNDUPD--< |
      | >------BNDACK---------------->         |
     ...                                      ...
      |                                        |
      |        <--------------------POOLREQ--< |
      | >--POOLRESP------------------>         |
      |                                        |
      | >--BNDUPD-(#1)--------------->         |
      |        <---------------------BNDACK--< |
      |                                        |
      | >--BNDUPD-(#2)--------------->         |
      |        <---------------------BNDACK--< |
      |                                        |]]></artwork></figure>



      </section> <!-- transition-out-of-comm-interrrupted-state -->
    </section> <!-- comm-interrrupted state -->

    <section anchor="state-potential-conflict" title="POTENTIAL-CONFLICT State">
      <t>This state indicates that the two servers are attempting to
      reintegrate with each other, but at least one of them was
      running in a state that did not guarantee automatic
      reintegration would be possible.  In POTENTIAL-CONFLICT state
      the servers may determine that the same resource has been
      offered and accepted by two different clients.</t>

      <t>It is a goal of this protocol to minimize the possibility that
      POTENTIAL-CONFLICT state is ever entered.</t>

      <t>When a primary server enters POTENTIAL-CONFLICT state it should
      request that the secondary send it all updates of which it is
      currently unaware by sending an UPDREQ message to the secondary
      server.</t>

      <t>A secondary server entering POTENTIAL-CONFLICT state will wait for
      the primary to send it an UPDREQ message.</t>

      <section anchor="operation-in-potential-conflict-state"
               title="Operation in POTENTIAL-CONFLICT State">
        <t>Any server in POTENTIAL-CONFLICT state MUST NOT process any
        incoming DHCP requests.</t>
      </section> <!-- operation-in-potential-conflict-state -->
      <section anchor="transition-out-of-potential-conflict-state"
               title="Transition Out of POTENTIAL-CONFLICT State">

        <t>If communications fails with the partner while in
        POTENTIAL-CONFLICT state, then the server will transition to
        RESOLUTION-INTERRUPTED state.</t>

        <t>Whenever either server receives an UPDDONE message from its
        partner while in POTENTIAL-CONFLICT state, it MUST transition
        to a new state.  The primary MUST transition to CONFLICT-DONE
        state, and the secondary MUST transition to NORMAL state.
        This will cause the primary server to leave POTENTIAL-CONFLICT
        state prior to the secondary, since the primary sends an
        UPDREQ message and receives an UPDDONE before the secondary
        sends an UPDREQ message and receives its UPDDONE message.</t>

        <t>When a secondary server receives an indication that the primary
        server has made a transition from POTENTIAL-CONFLICT to CONFLICT-DONE
        state, it SHOULD send an UPDREQ message to the primary server.</t>

<figure anchor="out-of-potential-conflict"
        title="Transition out of POTENTIAL-CONFLICT">
    <artwork><![CDATA[
    Primary                                Secondary
    Server                                  Server

      |                                        |
POTENTIAL-CONFLICT                    POTENTIAL-CONFLICT
      |                                        |
      | >--UPDREQ-------------------->         |
      |                                        |
      |        <---------------------BNDUPD--< |
      | >--BNDACK-------------------->         |
     ...                                      ...
      |                                        |
      |        <---------------------BNDUPD--< |
      | >--BNDACK-------------------->         |
      |                                        |
      |        <--------------------UPDDONE--< |
CONFLICT-DONE                                  |
      | >--STATE--(CONFLICT-DONE)---->         |
      |        <---------------------UPDREQ--< |
      |                                        |
      | >--BNDUPD-------------------->         |
      |        <---------------------BNDACK--< |
     ...                                      ...
      | >--BNDUPD-------------------->         |
      |        <---------------------BNDACK--< |
      |                                        |
      | >--UPDDONE------------------->         |
      |                                     NORMAL
      |        <------------STATE--(NORMAL)--< |
   NORMAL                                      |
      | >--STATE--(NORMAL)----------->         |
      |                                        |
      |        <--------------------POOLREQ--< |
      | >------POOLRESP-------------->         |
      |                                        |]]></artwork></figure>



      </section> <!-- transition-out-of-potential-conflict-state -->
    </section> <!-- potential-conflict state -->

    <section anchor="state-resolution-interrupted" title="RESOLUTION-INTERRUPTED State">
      <t>This state indicates that the two servers were attempting to
      reintegrate with each other in POTENTIAL-CONFLICT state, but
      communications failed prior to completion of re-integration.</t>

      <t>The RESOLUTION-INTERRUPTED state exists because
      servers are not responsive in POTENTIAL-CONFLICT state, and
      if one server drops out of service while both servers
      are in POTENTIAL-CONFLICT state, the server that remains
      in service will not be able to process DHCP client requests and
      there will be no DHCP service available.  The RESOLUTION-INTERRUPTED
      state is the state that a server moves to if its partner
      disappears while it is in POTENTIAL-CONFLICT state.</t>

      <t>When a server enters RESOLUTION-INTERRUPTED state it SHOULD raise an
      alarm condition to alert administrative staff of a problem in the
      DHCP subsystem.</t>

      <section anchor="operation-in-resolution-interrupted-state"
               title="Operation in RESOLUTION-INTERRUPTED State">
        <t>In this state a server MUST respond to all DHCP client
        requests. When allocating new resources, each server SHOULD 
        allocate from its own pool (if
        that can be determined), where the primary SHOULD allocate
        only FREE resources, and the secondary SHOULD allocate only
        FREE_BACKUP resources. When responding to renewal requests, each
        server will allow continued renewal of a DHCP client's current
        lease independent of whether that lease was given out by the
        receiving server or not, although the renewal period MUST NOT
        exceed the maximum client lead time (MCLT) beyond the latest
        of: 1) the potential valid lifetime already acknowledged by
        the other server or 2) now or 3) potential valid lifetime 
        received from the partner server.</t>

        <t>However, since the server cannot communicate with its
        partner in this state, the acknowledged potential valid
        lifetime will not be updated in any new bindings.</t>
      </section> <!--
        operation-in-resolution-interrupted-state -->
      <section anchor="transition-out-of-resolution-interrupted-state"
               title="Transition Out of RESOLUTION-INTERRUPTED State">

        <t>If an external command is received by a server in
        RESOLUTION-INTERRUPTED state informing it that its partner is
        down, it will transition immediately into PARTNER-DOWN
        state.</t>

        <t>If communications is restored with the other server, then
        the server in RESOLUTION-INTERRUPTED state will transition
        into POTENTIAL-CONFLICT state.</t>

      </section> <!-- transition-out-of-resolution-interrupted-state -->
    </section> <!-- resolution-interrupted state -->

    <section anchor="state-conflict-done" title="CONFLICT-DONE State">
      <t>This state indicates that during the process where the two
      servers are attempting to re-integrate with each other, the
      primary server has received all of the updates from the
      secondary server.  It makes a transition into CONFLICT-DONE state
      in order that it may be totally responsive to the client load.
      There is no operational difference between CONFLICT-DONE and
      NORMAL for primary as in both states it responds to all
      clients' requests. The distinction between CONFLICT-DONE and
      NORMAL states will be more apparent when load balancing 
      extension will be defined. <!--,
      as opposed to NORMAL state where it would be in a "balanced"
      responsive state, running the load balancing algorithm.--></t>

      <!-- issue 7  Kim: I believe we discussed this, and decided
      to leave CONFLICT-DONE in the state machine, so that when
      load-balancing is supported we won't have to rev the state
      machine.

      Yes, we did:  Tomek said this in some email on Sept 7, 2012:

        I'd like to comment on some decisions made regarding load
        balancing, before someone raises it again. v4 failover
        standardization failed, because the draft was too large and
        there was nobody willing to review it. That's why we try
        to succeed with v6 failover by splitting it to smaller
        chunks. That's why this failover covers the absolute minimum,
        i.e. active-passive only with load balancing being out of
        scope. You may notice that some of the states (RECOVER-DONE
        and CONFLICT-DONE) are really useful only for load balancing.
        We decided to keep them in to make extension to LB much
        simpler - the state machine will be operating in the same
        manner with and without LB. Obviously, there are many folks
        interested in load balancing. We are, too, but we want it
        to be an extension, defined in separate draft.
      
      Tomek: Ok, I've changed the wording slightly to not explicitly
      say that server does load balancing, as it is not officially
      defined yet. -->

      <section anchor="operation-in-conflict-done-state"
               title="Operation in CONFLICT-DONE State">
        <t>A primary server in CONFLICT-DONE state is fully responsive
        to all DHCP clients (similar to the situation in
        COMMUNICATIONS-INTERRUPTED state).</t>

        <t>If communications fails, remain in CONFLICT-DONE state.  If
        communications becomes OK, remain in CONFLICT-DONE state until
        the conditions for transition out become satisfied.</t>
      </section> <!-- operation-in-conflict-done-state -->
      <section anchor="transition-out-of-conflict-done-state"
               title="Transition Out of CONFLICT-DONE State">
        <t>If communications fails with the partner while in
        CONFLICT-DONE state, then the server will remain in
        CONFLICT-DONE state.</t>

        <t>When a primary server determines that the secondary
        server has made a transition into NORMAL state, the primary
        server will also transition into NORMAL state.</t>
      </section> <!-- transition-out-of-conflict-done-state -->
    </section> <!-- conflict-done state -->

  </section> <!-- endpoint states -->


  <section anchor="DDNS" title="Dynamic DNS Considerations">

    <t>DHCP servers (and clients) can use DNS Dynamic Updates as
    described in <xref target="RFC2136">RFC 2136</xref> to maintain
    DNS name-mappings as they maintain DHCP leases.  Many different
    administrative models for DHCP-DNS integration are possible.
    Descriptions of several of these models, and guidelines that
    DHCP servers and clients should follow in carrying them out,
    are laid out in <xref target="RFC4704">RFC 4704</xref>.</t>

    <t>The nature of the failover protocol introduces some issues
    concerning dynamic DNS (DDNS) updates that are not part of non-failover
    environments.  This section describes these issues, and defines
    the information which failover partners should exchange in order
    to ensure consistent behavior.  The presence of this section
    should not be interpreted as requiring an implementation of
    the DHCPv6 failover protocol to also support DDNS updates.</t>

    <t>The purpose of this discussion is to clarify the areas where
    the failover and DHCP-DDNS protocols intersect for the benefit
    of implementations which support both protocols, not to introduce
    a new requirement into the DHCPv6 failover protocol.  Thus, a
    DHCPv6 server which implements the failover protocol MAY also
    support dynamic DNS updates, but if it does support dynamic DNS
    updates it SHOULD utilize the techniques described here in order
    to correctly distribute them between the failover partners.
    See <xref target="RFC4704">RFC 4704</xref> as well as <xref
    target="RFC4703">RFC 4703</xref> for information on how DHCPv6
    servers deal with potential conflicts when updating DNS even
    without failover.</t>

    <t>From the standpoint of the failover protocol, there is no
    reason why a server which is utilizing the DDNS protocol to
    update a DNS server should not be a partner with a server which
    is not utilizing the DDNS protocol to update a DNS server.
    However, a server which is not able to support DDNS or is not
    configured to support DDNS SHOULD output a warning message when
    it receives BNDUPD messages which indicate that its failover
    partner is configured to support the DDNS protocol to update a
    DNS server.  An implementation MAY consider this an error and
    refuse to operate, or it MAY choose to operate anyway, having
    warned the administrator of the problem in some way.</t>

    <section anchor="failover-ddns"
       title="Relationship between failover and dynamic DNS update">

        <t>The failover protocol describes the conditions under
        which each failover server may renew a lease to its current
        DHCP client, and describes the conditions under which it
        may grant a lease to a new DHCP client.  An analogous set
        of conditions determines when a failover server should
        initiate a DDNS update, and when it should attempt to remove
        records from the DNS. The failover protocol's conditions
        are based on the desired external behavior: avoiding duplicate
        address and prefix assignments; allowing clients to continue
        using leases which they obtained from one failover partner
        even if they can only communicate with the other partner;
        allowing the secondary DHCP server to grant new leases even
        if it is unable to communicate with the primary server.
        The desired external DDNS behavior for DHCP failover servers
        is similar to that described above for the failover protocol
        itself:</t>

        <t><list style="numbers">
            <t>Allow timely DDNS updates from the server which
            grants a lease to a client. Recognize that there is
            often a DDNS update lifecycle which parallels the DHCP
            lease lifecycle. This is likely to include the addition
            of records when the lease is granted, and the removal
            of DNS records when the leased resource is subsequently
            made available for allocation to a different client.</t>

            <t>Communicate enough information between the two
            failover servers to allow one to complete the DDNS
            update 'lifecycle' even if the other server originally
            granted the lease.</t>

            <t>Avoid redundant or overlapping DDNS updates, where
            both failover servers are attempting to perform DDNS
            updates for the same lease-client binding.</t>
            
            <t>Avoid situations where one partner is attempting to
            add RRs related to a lease binding while the other
            partner is attempting to remove RRs related to the same
            lease binding.</t>
        </list></t>

        <t>While DHCP servers configured for DDNS typically perform
        these operations on both the AAAA and the PTR resource records, 
        this is not required.  It is entirely possible that a DHCP server
        could be configured to only update the DNS with PTR records, and 
        the DHCPv6 clients could be responsible for updating the DNS with
        their own AAAA records.  In this case, the discussions here would
        apply only to the PTR records.</t>

    </section>

    <section anchor="useofddns" 
       title="Exchanging DDNS Information">

        <t>In order for either server to be able to complete a DDNS
        update, or to remove DNS records which were added by its
        partner, both servers need to know the FQDN associated with
        the lease-client binding.  In addition, to properly handle
        DDNS updates, additional information is required.  All of
        the following information needs to be transmitted between
        the failover partners:</t>

        <t><list style="numbers">
            <t>The FQDN that the client requested be associated
            with the resource.  If the client doesn't request a
            particular FQDN and one is synthesized by the failover
            server or if the failover server is configured to replace
            a client requested FQDN with a different FQDN, then
            the server generated value would be used. </t>

            <t>The FQDN that was actually placed in the DNS for
            this lease. It may differ from the client requested
            FQDN due to some form of disambiguation or other DHCP
            server configuration (as described above).</t>
            
            <t>The status of and DDNS operations in progress or
            completed.</t>

            <t>Information sufficient to allow the failover partner
            to remove the FQDN from the DNS should that become
            necessary.</t>
        </list></t>

        <t>These data items are the minimum necessary set to reliably
        allow two failover partners to successfully share the
        responsibility to keep the DNS up to date with the resources
        allocated to clients.</t>

        <t>This information would typically be included in BNDUPD
        messages sent from one failover partner to the other.
        Failover servers MAY choose not to include this information
        in BNDUPD messages if there has been no change in the status
        of any DDNS update related to the lease.</t>

        <t>The partner server receiving BNDUPD messages containing
        the DDNS information SHOULD compare the status information
        and the FQDN with the current DDNS information it has
        associated with the lease binding, and update its notion
        of the DDNS status accordingly.</t>

        <t>Some implementations will instead choose to send a BNDUPD
        without waiting for the DDNS update to complete, and then
        will send a second BNDUPD once the DDNS update is complete.
        Other implementations will delay sending the partner a
        BNDUPD until the DDNS update has been acknowledged by the
        DNS server, or until some time-limit has elapsed, in order
        to avoid sending a second BNDUPD.</t>

        <t>The FQDN option contains the FQDN that will be associated
        with the AAAA RR (if the server is performing an AAAA RR update
        for the client).  The PTR RR can be generated automatically from
        the IP address or prefix value. The FQDN may be composed
        in any of several ways, depending on server configuration
        and the information provided by the client in its DHCP
        messages. The client may supply a hostname which it would
        like the server to use in forming the FQDN, or it may supply
        the entire FQDN. The server may be configured to attempt
        to use the information the client supplies, it may be
        configured with an FQDN to use for the client, or it may
        be configured to synthesize an FQDN.</t>

        <t>Since the server interacting with the client may not have completed the
        DDNS update at the time it sends the first BNDUPD about the
        lease binding, there may be cases where the FQDN in later
        BNDUPD messages does not match the FQDN included in earlier
        messages.  For example, the responsive server may be
        configured to handle situations where two or more DHCP
        client FQDNs are identical by modifying the most-specific
        label in the FQDNs of some of the clients in an attempt to
        generate unique FQDNs for them (a process sometimes called
        "disambiguation").  Alternatively, at sites which use some
        or all of the information which clients supply to form the
        FQDN, it's possible that a client's configuration may be
        changed so that it begins to supply new data.  The 
        server interacting with the client may react by removing the DNS records which it
        originally added for the client, and replacing them with
        records that refer to the client's new FQDN. In such cases,
        the server SHOULD include the actual FQDN that
        was used in subsequent DDNS options in any BNDUPD messages exchanged between
        the failover partners.  This server
        SHOULD include relevant information in its BNDUPD messages.
        This information may be necessary in order to allow the
        non-responsive partner to detect client configuration changes
        that change the hostname or FQDN data which the client
        includes in its DHCP requests.</t>

    </section>

    <section anchor="addingrr" 
       title="Adding RRs to the DNS">

        <t>A failover server which is going to perform DDNS updates
        SHOULD initiate the DDNS update when it grants a new lease
        to a client. The server which did not grant the lease SHOULD NOT
        initiate
        a DDNS update when it receives the BNDUPD after the lease
        has been granted. The failover protocol ensures that only
        one of the partners will grant a lease to any individual
        client, so it follows that this requirement will prevent
        both partners from initiating updates simultaneously. The
        server initiating the update SHOULD follow the protocol in
        <xref target="RFC4704">RFC 4704</xref>.  The server may be
        configured to perform a AAAA RR update on behalf of its
        clients, or not. Ordinarily, a failover server will not
        initiate DDNS updates when it renews leases. In two cases,
        however, a failover server MAY initiate a DDNS update when
        it renews a lease to its existing client:</t>

        <t><list style="numbers">
            <t>When the lease was granted before the server was
            configured to perform DDNS updates, the server MAY be
            configured to perform updates when it next renews
            existing leases.  The server which granted the lease
            is the server which should initiate the DDNS update.</t>

            <t>If a server is in PARTNER-DOWN state, it can conclude
            that its partner is no longer attempting to perform an
            update for the existing client. If the remaining server
            has not recorded that an update for the binding has
            been successfully completed, the server MAY initiate a
            DDNS update.  It MAY initiate this update immediately
            upon entry to PARTNER-DOWN state, it may perform this
            in the background, or it MAY initiate this update upon
            next hearing from the DHCP client.</t>
        </list></t>

    </section>

    <section anchor="deletingrr" 
       title="Deleting RRs from the DNS">

        <t>The failover server which makes a resource FREE* SHOULD
        initiate any DDNS deletes, if it has recorded that DNS
        records were added on behalf of the client.</t>

        <t>A server not in PARTNER-DOWN state "makes a resource
        FREE" when it initiates a BNDUPD with a binding-status of
        FREE, FREE_BACKUP, EXPIRED, or RELEASED.  Its partner
        confirms this status by acking that BNDUPD, and upon receipt
        of the BNDACK the server has "made the resource FREE".
        Conversely, a server in PARTNER-DOWN state "makes a resource
        FREE" when it sets the binding-status to FREE, since in
        PARTNER-DOWN state no communications is required with the
        partner.</t>

        <t>It is at this point that it should initiate the DDNS
        operations to delete RRs from the DDNS. Its partner SHOULD
        NOT initiate DDNS deletes for DNS records related to the
        lease binding as part of sending the BNDACK message.   The
        partner MAY have issued BNDUPD messages with a binding-status
        of FREE, EXPIRED, or RELEASED previously, but the other
        server will have rejected these BNDUPD messages.</t>

        <t>The failover protocol ensures that only one of the two
        partner servers will be able to make a resource FREE*. The
        server making the resource FREE may be doing so while it
        is in NORMAL communication with its partner, or it may be
        in PARTNER-DOWN state. If a server is in PARTNER-DOWN state,
        it may be performing DDNS deletes for RRs which its partner
        added originally. This allows a single remaining partner
        server to assume responsibility for all of the DDNS activity
        which the two servers were undertaking.</t>

        <t>Another implication of this approach is that no DDNS RR
        deletes will be performed while either server is in
        COMMUNICATIONS-INTERRUPTED state, since no resource are
        moved into the FREE* state during that period.</t>
    </section>

    <section anchor="nameassignment"
      title="Name Assignment with No Update of DNS">

        <t>In some cases, a DHCP server is configured to return a name
        to the DHCPv6 client but not enter that name into the DNS.  
        This is typically a name that it has discovered
        or generated from information it has received from the client.
        In this case this name information SHOULD be communicated to the
        failover partner, if only to ensure that they will return the same
        name in the event the partner becomes the server to which the 
        DHCPv6 client begins to interact.</t>

    </section>

  </section>

  <!-- RESERVATIONS  
       This isn't really going to work as written, but it is a whole
       lot more complicated than this.  Do we want to even deal with
       this in the draft or just let people work it out?

  <section anchor="reserve" title="Reservations and failover">

    <t>Some DHCP servers support a capability to offer specific preconfigured 
    resources to DHCP clients.  These are real DHCP
    clients, they do the entire DHCP protocol, but these servers always
    offer the client a specific pre-configured resource, and they
    offer that resource to no other clients.  Such a capability has
    several names, but it is sometimes called a "reservation", in that
    the resource is reserved for a particular DHCP client.</t>

    <t>In a situation where there are two DHCP servers serving the same prefix
    without using failover, the two DHCP server's need to have disjoint 
    resource pools, but identical reservations for the DHCP
    clients.</t>

    <t>In a failover context, both servers need to be configured
    with the proper reservations in an identical manner, but if we
    stop there problems can occur around the edge conditions where
    reservations are made for resource that has already been leased
    to a different client.  Different servers handle this conflict
    in different ways, but the goal of the failover protocol is to
    allow correct operation with any server's approach to the normal
    processing of the DHCP protocol.</t>

    <t>The general solution with regards to reservations is as follows.
    Whenever a reserved resource becomes FREE (i.e., when first configured 
    or whenever a client frees it or it expires or is reset), the
    primary server MUST show that resource as FREE (and thus available
    for its own allocation) and it MUST send it to the secondary server
    in a BNDUPD with a flag set showing that it is reserved and with a
    status of FREE_BACKUP.</t>

    <t>Note that this implies that a reserved resource goes through
    the normal state changes from FREE to ACTIVE (and possibly back
    to FREE).  The failover protocol supports this approach to
    reservations, i.e., where the resource undergoes the normal
    state changes of any resource, but it can only be offered to
    the client for which it is reserved.</t>

    <t>From the above, it follows that a reservation solely on the
    secondary will not necessarily allow the secondary to offer
    that address to client to whom it is reserved.  The reservation
    must also appear on the primary as well for the secondary to
    be able to offer the resource to the client to which it is
    reserved.</t>

    <t>When the reservation on a resource is cancelled, if the resource 
    is currently FREE and the server is the primary, or FREE_BACKUP and the
    server is the secondary, the server MUST send a BNDUPD to the other
    server with the binding-status FREE and an indication that the
    resource is no longer reserved.</t>

  </section>
    -->


  <section title="Security Considerations">
    <t>DHCPv6 failover is an extension of a standard DHCPv6 protocol, so all
    security considerations from <xref target="RFC3315" />, Section 23 and
    <xref target="RFC3633" />, Section 15 related to the server apply.</t>

    <t>As traffic exchange between clients and server is not encrypted,
    an attacker that penetrated the network and is able to intercept traffic,
    will not gain any additional information by also sniffing communication
    between partners.</t>

    <t>An attacker that is able to impersonate one partner can efficiently
    perform a denial of service attack on the remaining uncompromised server.
    Several techniques may be used: pretending that conflict resolution
    is required, requesting rebalance, claiming that a valid lease was released
    or declined etc. For that reason the communication between servers
    SHOULD support failover connections over TLS, as explained in 
    <xref target="create-connections" />. Such secure connections SHOULD
    be optional and configurable by the administrator.</t>

    <t>A server MUST NOT operate in PARTNER-DOWN if its partner is up.
    Network administrators are expected to switch the remaining active server
    to PARTNER-DOWN state only if they is sure that its partner server
    is indeed down. Failing to obey this requirement will result in both
    servers likely assigning duplicate leases to different clients. Implementers
    should take that into consideration if they decide to implement
    the auto-partner-down timer-based transition to PARTNER-DOWN state.</t>

    <t>Running a network protected by DHCPv6 failover requires more resources
    than running without it. In particular some of the resources are
    allocated to the secondary server and they are not usable in a normal
    (i.e. non failures) operation immediately, though over time they will
    be rebalanced and end up on the server that needs them. While limiting 
    this pool may be preferable from resource utilization perspective, 
    it must be a reasonably large pool, so the secondary may take over once 
    the primary becomes unavailable.</t>

  </section>

  <section title="IANA Considerations">

   <t>
   IANA is requested to assign values for the following new DHCPv6
   Message types in the registry maintained in 
   http://www.iana.org/assignments/dhcpv6-parameters:
   </t>

    <t>
       <list style="symbols">
      <t>BNDUPD (TBD1)</t>

      <t>BNDACK (TBD2)</t> 
      
      <t>POOLREQ (TBD3)</t>

      <t>POOLRESP (TBD4)</t> 

      <t>UPDREQ (TBD5)</t> 

      <t>UPDREQALL (TBD6)</t> 

      <t>UPDDONE (TBD7)</t> 

      <t>CONNECT (TBD8)</t> 

      <t>CONNECTACK (TBD9)</t> 
      
      <t>DISCONNECT (TBD10)</t> 
      
      <t>STATE (TBD11)</t> 

      <t>CONTACT (TBD12)</t> 
    </list>
    </t>


   <t>
   IANA is requested to assign values for the following new DHCPv6
   Option codes in the registry maintained in 
   http://www.iana.org/assignments/dhcpv6-parameters:

   <list>
      <t>OPTION_F_BINDING_STATUS (TBD13)</t>
      <t>OPTION_F_DNS_REMOVAL_INFO (TBD14)</t>
      <t>OPTION_F_FAILOVER_EXPIRE_TIME (TBD15)</t>
      <t>OPTION_F_MAX_UNACKED_BNDUPD (TBD16)</t>
      <t>OPTION_F_MCLT (TBD17)</t>
      <t>OPTION_F_NEXT_PARTNER_LIFETIME (TBD18)</t>
      <t>OPTION_F_NEXT_PARTNER_LIFETIME_SENT (TBD19)</t>
      <t>OPTION_F_PARTNER_DOWN_TIME (TBD20)</t>
      <t>OPTION_F_PARTNER_RAW_CLT_TIME (TBD21)</t>
      <t>OPTION_F_PROTOCOL_VERSION (TBD22)</t>
      <t>OPTION_F_RECEIVE_TIME (TBD23)</t>
      <t>OPTION_F_RECONFIGURE_DATA (TBD24)</t>
      <t>OPTION_F_RELATIONSHIP_NAME (TBD25)</t>
      <t>OPTION_F_SERVER_FLAGS (TBD26)</t>
      <t>OPTION_F_SERVER_STATE (TBD27)</t>
      <t>OPTION_F_START_TIME_OF_STATE (TBD28)</t>
      <t>OPTION_F_STATE_EXPIRATION_TIME (TBD29)</t>
   </list>

   </t>

   <t>
   IANA is requested to assign values for the following new DHCPv6
   Status codes in the registry maintained in 
http://www.iana.org/assignments/dhcpv6-parameters:
   <list> 
      <t>OneClientDifferentLeases (TBD30)</t>
      <t>AddressInUseByOtherClient (TBD31)</t>
      <t>ConfigurationConflict (TBD32)</t>
      <t>MissingBindingInformation (TBD33)</t>
      <t>OutdatedBindingInformation (TBD34)</t>
   </list>
   </t>


  </section>

  <section title="Acknowledgements">
    <t>This document extensively uses concepts, definitions and other
    parts of <xref target="dhcpv4-failover"/> document.  Authors would
    like to thank Shawn Routher, Greg Rabil, Bernie Volz and Marcin Siodelski
    for their significant involvement and contributions. Authors would like to
    thank VithalPrasad Gaitonde, Krzysztof Gierlowski, Krzysztof Nowicki and
    Michal Hoeft for their insightful comments.</t>

    <t>This work has been partially supported by Department of
    Computer Communications (a division of Gdansk University of
    Technology) and the Polish Ministry of Science and Higher
    Education under the European Regional Development Fund, Grant
    No. POIG.01.01.02-00-045/09-00 (Future Internet Engineering
    Project).</t>
  </section>

</middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.1035'?>
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.2136'?>
      <?rfc include='reference.RFC.3315'?>
      <?rfc include='reference.RFC.3633'?>
      <?rfc include='reference.RFC.4703'?>
      <?rfc include='reference.RFC.4704'?>
      <?rfc include='reference.RFC.5007'?>
      <?rfc include='reference.RFC.5246'?>
      <?rfc include='reference.RFC.5460'?>
      <?rfc include='reference.RFC.7031'?>
    </references>
    <references title="Informative References">
      <?rfc include='reference.I-D.ietf-dhc-dhcpv6-failover-design.xml'?>
      <?rfc include='reference.I-D.ietf-dhc-dhcpv6-load-balancing.xml'?>
      <?rfc include='reference.I-D.ietf-dhc-dhcpv6-active-leasequery'?>
      <reference anchor="dhcpv4-failover">
        <front>
          <title>DHCP Failover Protocol</title> <author fullname="Ralph
          Droms" initials="R." surname="Droms">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Kim Kinnear" initials="K."
          surname="Kinnear">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Mark Stapp" initials="M."
          surname="Stapp">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Bernie Volz" initials="B."
          surname="Volz">
            <organization>Ericsson</organization>
          </author> <author fullname="Steve Gonczi" initials="S."
          surname="Gonczi">
            <organization>Relicore</organization>
          </author> <author fullname="Greg Rabil" initials="G."
          surname="Rabil">
            <organization>Lucent Technologies</organization>
          </author> <author fullname="Michael Dooley" initials="M."
          surname="Dooley">
            <organization>Diamond IP Technologies</organization>
          </author> <author fullname="Arun Kapur" initials="A."
          surname="Kapur">
            <organization>K5 Networks</organization>
          </author> <date month="March" year='2003'/>
        </front> <seriesInfo name="Internet-Draft"
        value="draft-ietf-dhc-failover-12"/>
      </reference> 

    </references>
  </back>
</rfc>
