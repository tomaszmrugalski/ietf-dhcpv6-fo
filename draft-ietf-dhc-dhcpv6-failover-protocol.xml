<?xml version='1.0' ?>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>

<?rfc compact="yes"?> <?rfc subcompact="no"?>

<?rfc symrefs="yes"?>

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' [
]>
<rfc ipr="trust200902" category="std"
     docName="draft-ietf-dhc-dhcpv6-failover-protocol-00">
  <front>
    <title abbrev="DHCPv6 Failover Protocol">DHCPv6 Failover Protocol</title>

    <author fullname="Tomasz Mrugalski" initials="T." surname="Mrugalski">
      <organization abbrev="ISC">Internet Systems Consortium, Inc.
      </organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <phone>+1 650 423 1345</phone>
        <email>tomasz.mrugalski@gmail.com</email>
      </address>
    </author>
    <author fullname="Kim Kinnear" initials="K." surname="Kinnear">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1414 Massachusetts Ave.</street>
          <city>Boxborough</city>
          <region>Massachusetts</region>
          <code>01719</code>
          <country>USA</country>
        </postal>
        <phone>+1 (978) 936-0000</phone>
        <email>kkinnear@cisco.com</email>
      </address>
    </author>

    <date />

    <area>Internet</area>
    <workgroup>Dynamic Host Configuration (DHC)</workgroup>
    <keyword>DHCPv6</keyword>
    <keyword>Failover</keyword>

    <abstract>
      <t>DHCPv6 defined in <xref target="RFC3315"/> does not offer
      server redundancy. This document defines a specific protocol
      implementation to provide for DHCPv6 failover, a mechanism for 
      running two servers on the same network with capability 
      for either server to take over clients' leases in case of server failure or network partition.  
      This is the third in a series of documents documenting 
      DHCPv6 Failover.
      DHCPv6 failover requirements are
      specified in <xref target="RFC7031"/>.  
      Design considerations are documented in 
      <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
      In theory one could implement the DHCPv6 Failover protocol by
      referring only to the current document and not the design document,
      as the current document explains the "how" of the protocol.  However, the
      design document explains "why" the protocol operates as
      it does, making it required reading for someone implementing the
      failover protocol.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Glossary">
      <t>This is a supplemental glossary that should be combined with
      definitions in Section 3 of
      <xref target="I-D.ietf-dhc-dhcpv6-failover-requirements"/>.

      <list style="symbols">

        <t>auto-partner-down - a capability where a failover server
	will move from COMMUNICATIONS-INTERRUPTED state to 
	PARTNER-DOWN state automatically, without operator intervention.</t>

	<t>DDNS - Dynamic DNS.  Typically used as an acronym referring to
	dynamic update of the DNS.</t> 

	<t>Failover endpoint - The failover protocol allows for
	there to be a unique failover 'endpoint' for each failover
	relationship in which a failover server participates.  The
	failover relationship is defined by a relationship name,
	and includes the failover partner IP address, the role this
	server takes with respect to that partner (primary or
	secondary), and the prefixes associated with that relationship.
	Note that a single prefix can only be associated with a
	single failover relationship.  This failover endpoint can
	take actions and hold unique states.  Typically, there is
	one failover endpoint per partner (server), although there
	may be more.  'Server' and 'failover endpoint' are synonymous
	only if the server participates in only one failover
	relationship. However, for the sake of simplicity 'Server'
	is used throughout the document to refer to a failover
	endpoint unless to do so would be confusing.</t>

        <t>Failover communication - all messages exchanged between
        partners.</t>

        <t>Independent Allocation - an allocation algorithm
        that splits the available pool of resources between the primary
        and secondary servers that is particularly well suited for
        vast pools (i.e. when available resources are not expected
        to deplete). 
	See <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>
	for details.
	</t>

	<t>Lease - an association of a DHCPv6 client with an IPv6 
	address or delegated prefix.</t>

        <t>Partner - name of the other DHCPv6 server that participates
        in failover relationship. When the role (primary or secondary)
        is not important, the other server is referred to as a "failover
        partner" or simply partner.</t>

        <t>Primary Server - First out of two DHCPv6 servers that participate
        in a failover relationship. In active-passive mode this is the
        server that handles most of the client traffic. Its failover partner
        is referred to as secondary server. </t>

        <t>Proportional Allocation - an allocation algorithm
        that splits the available resources between
        the primary and secondary servers and maintains proportions between
	available resources on both. It is particularly well suited for more
        limited resources.  
	See <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>
	for details.
	</t>

	<t>Resource - Any type of resource that is managed by
	DHCPv6. Currently there are three types of such resources
	defined: a non-temporary IPv6 address, a temporary IPv6 address,	 
	and an IPv6 prefix. Other resource types may
	be defined in the future.</t>

        <t>Responsive - A server that is responsive, will respond to
        DHCPv6 client requests.</t>

        <t>Secondary Server - Second of two DHCPv6 servers that participate
        in a failover relationship. Its failover partner is referred to as
        the primary server. In active-passive mode this server (the secondary)
	typically does not handle client traffic and acts as a backup.</t>

        <t>Server - A DHCPv6 server that implements DHCPv6 failover.
        'Server' and 'failover endpoint' are synonymous only if the
        server participates in only one failover relationship. </t>

        <t>Unresponsive - A server that is unresponsive will not
        respond to DHCPv6 client requests.</t>

      </list>
      </t>
    </section>

    <section title="Introduction">
      <t>The failover protocol design provides a means for cooperating
      DHCPv6 servers to work together to provide a DHCPv6 service
      with availability that is increased beyond that which could
      be provided by a single DHCPv6 server operating alone.  It
      is designed to protect DHCPv6 clients against server unreachability,
      including server failure and network partition. It is possible
      to deploy exactly two servers that are able to continue
      providing a lease on an IPv6 address <xref target="RFC3315"/>
      or on an IPv6 prefix <xref target="RFC3633"/>
      without the DHCPv6 client experiencing lease expiration or a
      reassignment of a lease to a different IPv6 address (or prefix) 
      in the event of failure by one or the other of the two servers.</t>

      <t>This protocol defines active-passive mode, sometimes also
      called a hot standby model. This means that during normal
      operation one server is active (i.e. actively responds to
      clients' requests) while the second is passive (i.e. it does
      receive clients' requests, but does not respond to them and only
      maintains a copy of lease database and is ready to take over
      incoming queries in case of primary server
      failure). Active-active mode (i.e. both servers actively
      handling clients' requests) is currently not supported for the
      sake of simplicity. Such a mode is likely to be defined as an
      extension at a later time and will probably be based on <xref
      target="I-D.ietf-dhc-dhcpv6-load-balancing" />.</t>

      <t>The failover protocol is designed to provide lease stability
      for leases with lease times beyond a short period.  Due in part to the
      additional overhead required as well as requirements to handle
      time skew between failover partners (See <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>)
      failover is not suitable for leases shorter than 30 seconds. 
      The DHCPv6 Failover protocol MUST NOT be used for leases shorter 
      than 30 seconds.</t>

      <t>This protocol attempts to fulfill all DHCPv6 failover requirements
      defined in <xref target="RFC7031"/> as well as following the design
      approach documented in <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
      </t>

    </section> 


<section title="Message and Option Definitions">

  <section anchor="msg-framing" title="Message Framing for TCP">

    <t>
    Failover
    communication is conducted over a TCP connection established between the
    partners. The protocol reuses the framing format specified in Section 5.1 of
    <xref target="RFC5460">DHCPv6 Bulk Leasequery</xref>, but uses different
    message types. All information is sent over the connection as typical
    DHCPv6 messages that convey DHCPv6 options, following the format defined in
    Section 22.1 of <xref target="RFC3315"/>.
    </t>

  </section>

  <section anchor="msg-list" title="Messages">

    <t>
    The following list contains the new message types created for failover
    communication.
    </t>

    <section anchor="msg-bndupd" title="BNDUPD">
      <t> The binding update message BNDUPD (TBD1) is used to send the binding lease
      changes to the partner. One message may contain one or more lease
      updates. The partner is expected to respond with a BNDACK message.  </t>
    </section>

    <section anchor="msg-bndack" title="BNDACK">
      <t> The binding acknowledgement message BNDACK (TBD2) is used for confirmation of the
      received BNDUPD message. It may contain a positive or negative response
      (e.g. due to detected lease conflict).  </t>
    </section>
      
    <section anchor="msg-poolreq" title="POOLREQ">
      <t>The Pool Request message POOLREQ (TBD3) is used by one server (typically
      secondary) to request allocation of resources (addresses or prefixes) from
      its partner. The partner responds with POOLRESP.</t>
    </section>

    <section anchor="msg-poolresp" title="POOLRESP">
      <t>The Pool Response POOLRESP (TBD4) message is used by one server
      (typically primary) to indicate that it has responded to its
      partner's request for resources allocation.  </t>
    </section>

    <section anchor="msg-updreq" title="UPDREQ">
      <t>The update request message UPDREQ (TBD5) is used by one server to request
      that its partner send all binding database changes that have not been
      sent and confirmed already. Requested partner is expected to respond
      with zero or more BNDUPD messages, followed by UPDDONE that signals
      end of updates.</t>
    </section>

    <section anchor="msg-updreqall" title="UPDREQALL">
      <t>The update request all UPDREQALL (TBD6) is used by one server to request
      that all binding database information be sent in order to recover from a
      total loss of its binding database by the requesting server. Requested
      server responds with zero or more BNDUPD messages, followed by UPDDONE
      that signal end of updates.</t>
    </section>

    <section anchor="msg-upddone" title="UPDDONE">
      <t>The update done message UPDDONE (TBD7) is used by the server
      responding to an UPDREQ or UPDREQALL to indicate that all
      requested updates have been sent by the responding server and
      acked by the requesting server.</t>
    </section>

    <section anchor="msg-connect" title="CONNECT">
      <t>The connect message CONNECT (TBD8) is used by the primary server to
      establish a high level connection with the other server, and to transmit
      several important configuration data items between the servers. The
      partner is expected to confirm by responding with CONNECTACK message.</t>
    </section>

    <section anchor="msg-connectack" title="CONNECTACK">
      <t>The connect acknowledgement message CONNECTACK (TBD9) is used by the
      secondary server to respond to a CONNECT message from the primary
      server.</t>
    </section>
      
    <section anchor="msg-disconnect" title="DISCONNECT">
      <t>The disconnect message DISCONNECT (TBD10) is used by either server when
      closing a connection and shutting down. No response is required for this
      message.</t>
    </section>
      
    <section anchor="msg-state" title="STATE">
      <t>The state message STATE (TBD11) is used by either server to inform its
      partner about a change of failover state. In some cases it may be used
      to also inform the partner about current state, e.g. after connection
      is established in COMMUNICATIONS-INTERRUPTED or PARTNER-DOWN states.</t>
    </section>

    <section anchor="msg-contact" title="CONTACT">
      <t>The contact message CONTACT (TBD12) is used by either server to ensure that
      the other server continues to see the connection as operational.  It
      MUST be transmitted periodically over every established connection if
      other message traffic is not flowing, and it MAY be sent at any time.</t>
    </section>

  </section>


  <section anchor="option-list" title="Options">

    <t>
    The following new options are defined.
    </t>


    <!-- ================================================ -->

    <section title="OPTION_F_SERVER_STATE">

    <t>
    The OPTION_F_SERVER_STATE option specifies the endpoint state of
    the server sending the option.
    </t>

    <t>
    This is an unsigned byte.
    </t>

    <t>
    The code for this option is TBD.
    </t>

    <figure>
    <artwork>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_SERVER_STATE     |                1              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | server-state  |                                                
   +-+-+-+-+-+-+-+-+

     option-code       OPTION_F_SERVER_STATE (TBD).
     option-len        1.
     state             Failover endpoint state.

    </artwork>
    </figure>

    <figure>
    <artwork>
   Value   Server State
   -----   ----------------------------------------------------------
   0       reserved
   1       STARTUP                Startup state (1)
   2       NORMAL                 Normal state
   3       COMMUNICATIONS-INTERRUPTED Communication interrupted 
   4       PARTNER-DOWN           Partner down 
   5       POTENTIAL-CONFLICT     Synchronizing
   6       RECOVER                Recovering bindings from partner
   7       PAUSED                 Shutting down for a short period.
   8       SHUTDOWN               Shutting down for an long period.
   9       RECOVER-DONE           Interlock state prior to NORMAL
   10      RESOLUTION-INTERRUPTED Comm. failed during resolution
   11      CONFLICT-DONE          Primary resolved its conflicts
    </artwork>
    </figure>

    <t>
    (1) The STARTUP state is never sent to the partner server, it is
    indicated by the STARTUP bit in the server-flags options (see 
    <xref target="state-startup"/>.
    </t>

    </section>

    <!-- ================================================ -->

    <section title="OPTION_F_SERVER_FLAGS">

    <t>
    The OPTION_F_SERVER_FLAGS option specifies information
    associated with the failover endpoint sending the option.
    </t>

    <t>
    This is an unsigned byte.
    </t>

    <t>
    The code for this option is TBD.
    </t>

    <figure>
    <artwork>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_SERVER_FLAGS     |                1              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | server-flags  |                                                
   +-+-+-+-+-+-+-+-+

     option-code       OPTION_F_SERVER_FLAGS (TBD).
     option-len        1.
     state             Flags associated with endpoint.
    </artwork>
    </figure>

    <figure>
    <artwork>
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |  MBZ  |B|A|S|C|
   +-+-+-+-+-+-+-+-+

   The bits (numbered from the least-significant bit in network
   byte-order) are used as follows:

   4 (B): SECONDARY (BACKUP)
	  Indicates that the sending server is a secondary (or backup)
	  server.
   5 (A): ACK_STARTUP
          Set to 1 to indicate that the OPTION_F_SERVER_FLAGS most
	  recently received contained the STARTUP bit set.
   6 (S): STARTUP,
          MUST be set to 1 whenever the server is in STARTUP state.
   7 (C): COMMUNICATED
          Set to 1 to indicate that the sending server has
	  communicated with its partner. 
   0-3  : Must be zero
    </artwork>
    </figure>

    </section>



    <!-- ================================================ -->

    <section title="OPTION_F_RECEIVE_TIME">

    <t>
    The OPTION_F_RECEIVE_FLAGS option specifies how long the
    failover endpoint sending this option will allow a connection
    that is considered up to go without a packet reception before
    considering the connection down.
    </t>

    <t>
    This is an unsigned integer in network byte order.
    </t>

    <t>
    The code for this option is TBD.
    </t>

    <figure>
    <artwork>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     OPTION_F_RECEIVE_TIME     |                4              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         receive-time                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

     option-code       OPTION_F_RECEIVE_TIME (TBD).
     option-len        4.
     receive-time      How long this endpoint will wait before 
                       considering a connection down due to lack of
		       any packet flow.
    </artwork>
    </figure>

    </section>


    <!-- ================================================ -->

    <section title="OPTION_F_BINDING_STATUS">

    </section>

    <!-- ================================================ -->

    <section title="OPTION_F_START_TIME_OF_STATE">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_STATE_EXPIRATION_TIME">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_FAILOVER_EXPIRATION_TIME">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_PARTNER_RAW_CLT_TIME">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_MCLT">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_BASE_TIME">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_RELATIONSHIP_NAME">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_PROTOCOL_VERSION">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_MAX_UNACKED_BNDUPD">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_NEXT_PARTNER_LIFETIME">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_NEXT_PARTNER_LIFETIME_SENT">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_PARTNER_DOWN_TIME">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_DNS_INFO">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_REQUESTED_FQDN">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_DNS_INFO">

    </section>
    <!-- ================================================ -->

    <section title="OPTION_F_DNS_REMOVAL_INFO">

    </section>




  </section>


</section>


<section title="Connection Management">
  <section anchor="create-connections" title="Creating Connections">
    <t>Every primary server implementing the failover protocol
    MUST attempt to connect to all of its partners periodically,
    where the period is implementation dependent and SHOULD be
    configurable.  In the event that a connection has been rejected
    by a CONNECTACK message with a reject-reason option contained
    in it or a DISCONNECT message, a server SHOULD reduce the
    frequency with which it attempts to connect to that server but
    it MUST continue to attempt to connect periodically.</t>

    <t>Every secondary server implementing the failover protocol
    MUST listen for connection attempts from the primary server.
    </t>

    <t>When a connection attempt succeeds, the primary server which
    has initiated the connection attempt MUST send a CONNECT message
    down the connection.  </t>

    <t>When a connection attempt is received, the only information
    that the receiving server has is the IP address of the partner
    initiating a connection.  If it has any relationships with the
    connecting server for which it is a secondary server, it should
    just await the CONNECT message to determine which relationship
    this connection is to serve.</t>

    <t>If it has no secondary relationships with the connecting
    server, it MUST drop the connection.  The goal is to limit
    the resources expended dealing with attempts to create a spurious
    failover connection.</t>

    <t>To summarize -- a primary server MUST use a connection that it has
    initiated in order to send a CONNECT message.  Every server that
    is a secondary server in a relationship simply listens for connection
    attempts from the primary server.
    </t>

    <t>Once a connection is established, the primary server MUST send
    a CONNECT message across the connection.  A secondary server MUST
    wait for the CONNECT message from a primary server.  If the
    secondary server doesn't receive a CONNECT message from the
    primary server in an installation dependent amount of time, it MAY
    drop the connection.</t>

    <t>Every CONNECT message includes a TLS-request option, and if the
    CONNECTACK message does not reject the CONNECT message and the
    TLS-reply option says TLS MUST be used, then the servers will
    immediately enter into TLS negotiation.</t>

    <t>Once TLS negotiation is complete, the primary server MUST
    resend the CONNECT message on the newly secured TLS connection and
    then wait for the CONNECTACK message in response.  The TLS-request
    and TLS-reply options MUST NOT appear in either this second
    CONNECT or its associated CONNECTACK message as they had in the
    first messages.</t>

    <t>The second message sent over a new connection (either a bare
    TCP connection or a connection utilizing TLS) is a STATE message.
    Upon the receipt of this message, the receiver can consider
    communications up.</t>

  </section>

  <section title="Endpoint Identification">
    <t>The proper operation of the failover protocol requires more than
    the transmission of messages between one server and the other.  Each
    endpoint might seem to be a single DHCPv6 server, but in fact there
    are situations where additional flexibility in configuration
    is useful.  A failover endpoint is always associated with a set
    of DHCPv6 prefixes that are configured on the DHCPv6 server where
    the endpoint appears.  A DHCPv6 prefix MUST NOT be associated with
    more than one failover endpoint.</t>

    <t>The failover protocol SHOULD be configured with one failover
    relationship between each pair of failover servers. In this
    case there is one failover endpoint for that relationship on
    each failover partner.  This failover relationship MUST have a
    unique name.</t>

    <t>There is typically little need for additional relationships between
    any two servers but there MAY be more than one failover relationship
    between two servers -- however each MUST have a unique relationship
    name.</t>

    <t>Any failover endpoint can take actions and hold unique states.</t>

    <t>This document frequently describes the behavior of the protocol in
    terms of primary and secondary servers, not primary and secondary
    failover endpoints.  However, it is important to remember that every
    'server' described in this document is in reality a failover endpoint
    that resides in a particular process, and that several failover
    end-points may reside in the same server process.</t>

    <t>It is not the case that there is a unique failover endpoint for
    each prefix that participates in a failover relationship.  On one
    server, there is (typically) one failover endpoint per partner,
    regardless of how many prefixes are managed by that combination of
    partner and role.  Conversely, on a particular server, any given
    prefix will be associated with exactly one failover endpoint.</t>

    <t>When a connection is received from the partner, the unique failover
    endpoint to which the message is directed is determined solely by
    the IP address of the partner, the relationship-name, and the role
    of the receiving server.</t>

  </section>

 <section anchor="connection-parameters" title="Connection Maintenance Parameters">

    <t>
    The following parameters and timers are used to ensure the integrity
    of the connections between two failover servers.
    </t>

    <figure>
    <artwork>
   Parameter         Default   Description
   ------------------------------------------
   FO_RECEIVE_TIMER  timer     counts down to time connection
                               assumed dead due to lack of packets

   FO_RECEIVE_TIME   60        maximum time server will consider
                               connection still up with no packets

   FO_CONTACT_PER_RECEIVE_TIME number of CONTACT messages to send 
                     4         during partner's FO_RECEIVE_TIME 
		               period

   FO_SEND_TIMER     timer     counts down to time to send next 
                               CONTACT message

   FO_SEND_TIME      15        maximum time to wait between sending
                               CONTACT packets if no other traffic
			       Created from partner's FO_RECEIVE_TIME
			       divided by FO_CONTACT_PER_RECEIVE_TIME
    </artwork>
    </figure>

 </section>

 <section anchor="reachability" title="Unreachability detection">
 
   <t>Each partner MUST maintain an FO_SEND_TIMER for each failover
   connection. The FO_SEND_TIMER is reset to FO_SEND_TIME every
   time any message is transmitted, and counts down once per second.
   If the timer reaches zero, a CONTACT message is transmitted and
   timer is reset to FO_SEND_TIME.  The CONTACT message may be
   transmitted at any time. An implementation MAY use additional
   mechanisms to detect partner unreachability.</t>

   <t> The FO_SEND_TIME is initialized from the configured
   FO_RECEIVE_TIME divided by FO_CONTACT_PER_RECEIVE_TIME.  When a
   CONNECT or CONNECTACK message is received, the OPTION_F_RECEIVE_TIME
   option is checked, and if it appears then the value in that
   option is used to calculate the FO_SEND_TIME by dividing the
   value received by the configured FO_CONTACT_PER_RECEIVE_TIME.
   </t>

   <t> Each partner MUST maintain an FO_RECEIVE_TIMER for each
   failover connection.  This timer is initialized to FO_RECEIVE_TIME
   and counts down once per second.  It is reset to FO_RECEIVE_TIME
   whenever a packet is received. If it ever reaches zero, the
   connection is considered dead.  In addition, the FO_RECEIVE_TIME
   MUST be sent to the failover partner on every CONNECT or CONNECTACK
   messages, in the OPTION_F_RECEIVE_TIME option.
   </t>

 </section>


</section>



<section title="Binding Updates">

  <section anchor="send-bndupd" title="Sending Binding Update">

    <t>This and the following section is written as though every
    BNDUPD message contains only a single binding update transaction
    in order to reduce the complexity of the discussion.  Servers
    MAY generate messages with multiple binding update transactions
    in them, and their partner servers MAY process these messages.
    Before multiple binding update transactions are to be sent and
    processed over a failover connection, their use MUST be negotiated
    during the CONNECT and CONNECTACK connection establishment
    processing.</t>

    <!-- tomek: here's the table from v4-failover-12, section 7.1:

                                        binding-status            BACKUP
                                                                  RESET
                                                                  ABANDONED
   Option                        ACTIVE     EXPIRED    RELEASED   FREE
   ======                        ======     =======    ========   ====
   assigned-IP-address (3)       MUST       MUST       MUST       MUST
   IP-flags                      MUST(4)    MUST(4)    MUST(4)    MUST(4)
   binding-status                MUST       MUST       MUST       MUST
   client-identifier             MAY        MAY        MAY        MAY(2)
   client-hardware-address       MUST       MUST       MUST       MAY(2)
   lease-expiration-time         MUST       MUST NOT   MUST NOT   MUST NOT
   potential-expiration-time     MUST       MUST NOT   MUST NOT   MUST NOT
   start-time-of-state           SHOULD     SHOULD     SHOULD     SHOULD
   client-last-trans.-time       MUST       SHOULD     MUST       MAY
   DDNS(1)                       SHOULD     SHOULD     SHOULD     SHOULD
   client-request-options        SHOULD     SHOULD NOT SHOULD     SHOULD NOT
   client-reply-options          SHOULD     SHOULD NOT SHOULD NOT SHOULD NOT

   (1) MUST if server is performing dynamic DNS for this IP address, else
       MUST NOT.
   (2) MUST NOT if binding-status is ABANDONED.
   (3) assigned-IP-address MUST be the first option for an IP address
   (4) IP-flags option MUST appear if any flags are non-zero, else it
       MAY appear. -->

    <t>Each server updates its failover partner about recent changes in lease
    states.  Each update MUST include at least the following information:
    <list style="numbers">
      <t>resource type - non-temporary address or a prefix. Resource type can
      be indicated by the container that conveys the actual resource (e.g. an IA_NA
      option indicates non-temporary IPv6 address);</t>
      <t>resource information - the actual address or prefix. That is conveyed
      using the appropriate option, e.g. an IAADDR for an address or an IAPREFIX for
      a prefix;</t>
      <t>valid life time sent to client*;</t>
      <t>IAID - Identity Association used by the client, while obtaining
      a given lease. (Note1: one client may use many IAIDs
      simultaneously. Note2: IAID for IA, TA and PD are orthogonal
      number spaces.)*;</t>
      <t>Next Expected Client Transmission (renewal time) - time interval since Client Last
      Transmission Time, when a response from a client is expected*; <!--
      this is a T1 timer. Since we decided to use IA_NA/IA_PD anyway, we
      will just set it properly --></t>
      <t>potential valid life time - a lifetime that the server is willing to
      set if there were no MCLT/failover restrictions imposed*;</t>
      <t>preferred life time sent to client - the actual value sent back to
      the client*;</t>
      <t>CLTT - Client Last Transaction Time, a timestamp of the last received
      transmission from a client*;</t>
      <t>Client DUID*.</t>
      <t>Resource state.</t>
      <t>start time of state (especially for non-client updates).</t>
    </list>
    </t>
    <t>Items marked with asterisk MUST appear only if the lease is/was associated
    with a client. Otherwise it MUST NOT appear.</t>
    <!-- TODO: point out that in some states client DUID MUST NOT appear -->
    <!-- tomek: we don't really care about preferred lifetime. Since it is
         defined in IAADDR/IAPREFIX options that we will be reusing, we will
         need to send something. We may just send actual preferred lifetime, but
         it won't be useful for anything. -->
    <!-- tomek: we will use IA_NA + IAADDR, IA_PD + IAPREFIX options here
	 with some new additional options:
	 - valid lifetime requested by client
	 - potential valid life time
	 - cltt -->

    <t>The BNDUPD message MAY contain additional information related to the
    updated lease. The additional information MAY include, but is not limited to:
    <list style="numbers">
      <!-- tomek: v4-failover-12 states that FQDN either MUST or MUST NOT
           appear, depending on whether server did or did not DDNS. Perhaps
           putting it in the optional section is not the right place? -->
      <!-- tomek: I'm not sure it tying FQDN to the actual DDNS update is a good
      idea. There's a corner case when FQDN is used only to assign names to
      hosts, without updating DNSes. It is a use case allowed by the standard,
      not sure if it has any practical applications or if it is really used.
      I suggest a different wording: "depending on whether the server did or
      did not send FQDN option to clients" -->
      <t>assigned FQDN name, defined in <xref target="RFC4704"/>;</t>
      <t>Options Requested by the client, i.e. content of the ORO;</t>
      <t>Relay Data option from DHCPv6 Leasequery, see <xref target="RFC5007"/> Section 4.1.2.4</t>
      <t>Any other options the updating partner deems useful.</t>
    </list>
    </t>

    <t>The receiving partner MAY store any additional information received, but it MAY
    choose to ignore it as well. Some information may be useful, so it is a
    good idea to keep or update it. One reason is FQDN information. A server
    SHOULD be prepared to clean up DNS information once the lease expires or is
    released. See <xref target="DDNS"/> for a detailed discussion about
    Dynamic DNS. Another reason the partner may be interested in keeping additional
    data is a better support for leasequery <xref target="RFC5007"/> or bulk
    leasequery <xref target="RFC5460"/>, which features queries based on
    Relay-ID, by link address and by Remote-ID.</t>
  </section> <!-- sending data -->

  <section title="Receiving Binding Update">

    <!-- see v4-failover-12, section 7.1.2 -->
    <t>When a server receives a BNDUPD message, it needs to decide how to
    process the binding update transaction it contains and whether that
    transaction represents a conflict of any sort. The conflict resolution
    process MUST be used on the receipt of every BNDUPD message, not just those
    that are received while in POTENTIAL-CONFLICT state, in order to increase
    the robustness of the protocol.</t>
    
    <t>There are three sorts of conflicts:
    <list style="numbers">
      <t>Two clients, one resource - This is the duplicate resource allocation
      conflict. There two different clients each allocated the same resource. See
      <xref target="conflict-resolution"/>.</t>
      <t>Two resources, one client conflict - This conflict exists when a client
      on one server is associated with a one resource, and on the other server
      with a different resource in the same or related prefix. This does not
      refer to the case where a single client has resources in multiple
      different prefixes or administrative domains (i.e. a mobile client that
      changed its location), but rather the case where on
      the same prefix the client has a lease on one IP address in one server
      and on a different IP address on the other server.
      
      <!-- how to start new paragraph within the same bullet? -->
      <vspace blankLines="1"/>

      This conflict may or may not be a problem for a given DHCP server
      implementation and policy. If implementations and policies allow, both
      resources can be assigned to a given client. In the event that a DHCP
      server requires that a DHCP client have only one outstanding lease of a
      given type, the conflict MUST be resolved by accepting the lease which has
      the latest CLTT.

      <vspace blankLines="1"/>
      It should be further clarified that DHCPv6 protocol makes
      assignments based on a (client DUID, resource type, IAID)
      triplet. The possibility of using different IAIDs was omitted in
      this paragraph for clarity. If one client is assigned multiple
      resources of the same type, but with different IAIDs, there is
      no conflict. Also, IAID values for different resource types are
      orthogonal, i.e. an IA_NA with IAID=1 is different than an IA_PD with
      IAID=1 and there is no conflict.
      </t>

      <t>binding-status conflict - This is normal conflict, where one server is
      updating the other with newer information. See <xref
      target="conflict-resolution"/> for details of how to resolve these
      conflicts.</t>

      <t> configuration conflict -- This kind of conflict stems
      from a differing configuration on one server than on the other
      server.  It may be transient (last until both servers can
      process a new configuration) or it may be chronic.  It cannot
      be resolved by communications over the failover connection,
      but must be resolved (if it is not transient) by administrator
      action to resolve the conflicts.</t>

    </list>
    </t>
  </section>

    <section anchor="conflict-resolution" title="Conflict Resolution">
      <!-- tomek: that paragraph is no longer needed. Following paragraphs
	   based on v4 failover decribe the issue much better -->
      <t>The server receiving a lease update from its partner must evaluate the
      received lease information to see if it is consistent with already known
      state and decide which information - the previously known or that just received -
      is "better". The server should take into consideration the following
      aspects: if the lease is already assigned to a specific client, who had
      contact with client recently, start time of the lease, etc.</t>

      <t>When analyzing a BNDUPD message from a partner server, if there is
      insufficient information in the BNDUPD to process it, then reject the
      BNDUPD with reject-reason "Missing binding information".</t>

      <t>If the resource in the BNDUPD is not a resource associated with
      the failover endpoint which received the BNDUPD message, then reject
      it with reject-reason "Illegal IP address or prefix (not part of any
      address or prefix pool)".</t>
      <!-- issue 12: do we want separate reject-reason for prefixes? -->

      <t>Every BNDUPD message SHOULD contain a client-last-transaction-time
      option, which MUST, if it appears, be the time that the server last
      interacted with the DHCP client.  It MUST NOT be, for instance, the
      time that the lease on an IP address expired.  If there has been no
      interaction with the DHCP client in question (or there is no DHCP
      client presently associated with this resource), then there will be
      no client-last-transaction-time option in the BNDUPD message.</t>

      <t>The list in <xref target="tbl-conflict-resolution"/> presents the conflict
      resolution outcome. To "accept" a BNDUPD means to update the server's
      bindings database with the information contained in the BNDUDP and once
      the update is complete, send a BNDACK message corresponding to the BNDUPD
      message. To "reject" a BNDUPD means to leave the server's binding database
      unchanged and to respond to the BNDUPD with BNDACK with a reject-reason 
      option included.</t>

      <t>When interpreting the information in the following table (<xref
      target="tbl-conflict-resolution"/>), for those rules that are listed with
      "time" -- if a BNDUPD doesn't have a client-last-transaction-time value,
      then it MUST NOT be considered later than the client-last-transaction-time
      in the receiving server's binding.  If the BNDUPD contains a client-last-
      transaction-time value and the receiving server's binding does not, then
      the client-last-transaction-time value in the BNDUPD MUST be considered
      later than the server's.</t>

  <figure anchor="tbl-conflict-resolution" title="Conflict Resolution">
    <artwork><![CDATA[
                          binding-status in received BNDUPD.
binding-status
in receiving                                      FREE        RESET
server           ACTIVE   EXPIRED   RELEASED   FREE_BACKUP  ABANDONED

ACTIVE           accept(5) time(2)   time(1)    time(2)      accept
EXPIRED          time(1)   accept    accept     accept       accept
RELEASED         time(1)   time(1)   accept     accept       accept
FREE/FREE_BACKUP accept    accept    accept     accept       accept
RESET            time(3)   accept    accept     accept       accept
ABANDONED        reject(4) reject(4) reject(4)  reject(4)    accept
]]></artwork></figure>

    <t>time(1): If the client-last-transaction-time in the BNDUPD is later than
    the client-last-transaction-time in the receiving server's binding, accept
    it, else reject it.</t>

    <t>time(2): If the current time is later than the receiving server's
    lease-expiration-time, accept it, else reject it.</t>

    <t>time(3): If the client-last-transaction-time in the BNDUPD is later than
    the start-time-of-state in the receiving server's binding, accept it, else
    reject it.</t>

    <t>(1,2,3): If rejecting, use reject reason "Outdated binding
    information".</t>

    <t>(4): Use reject reason "Less critical binding information".</t>

    <t>(5): If the clients in a BNDUPD message and in a receiving server's
    binding differ, then if the receiving server is a secondary accept it, else
    reject it with a reject reason of "Fatal conflict exists: address in use
    by other client".</t>

    <!-- issue 5: Done. The issue was: This is just a loose collection of
         notes. This section will probably need to be rewritten as a a flowchart
         of some kind. -->

      <t>The lease update may be accepted or rejected.  Rejection SHOULD NOT
      change the flag in a lease that says that it should be transmitted to the
      failover partner.  If this flag is set, then it should be transmitted, but
      if it is not already set, the rejection of a lease state update SHOULD NOT
      trigger an automatic update of the failover partner sending the rejected
      update.  The potential for update storms is too great, and in the unusual
      case where the servers simply can't agree, that disagreement is better
      than an update storm.
      </t>

    <!-- <t>Discussion: There will definitely be different types of update
      rejections. For example, this will allow a server to treat differently a
      case when receiving a new lease that it previously haven't seen than a
      case when partner sents old version of a lease for which a newer state is
      known.</t>-->
    </section>

    <section anchor="acknowledging-reception" title="Acknowledging Reception">

      <t>Upon acceptance of a binding lease, the server MUST notify its partner
      that it updated its database. A server MUST NOT send the BNDACK before its
      database is updated. A BNDACK MUST contain at lease the minimum set of information
      required to unambiguously identify the BNDUPD that triggered the BNDACK.</t>

    </section>

</section>




<section title="Resource Allocation">

    <t>This section discusses allocation details of the allocation
    of resources to specific clients.
    </t>


  <section anchor="reallocation" title="Re-allocating Leases">
    <!-- issue 4 
    TODO: Describe controlled re-allocation of released/expired
    leases to different clients.

    Done 10/16/12 Kim
    -->
    <!-- see section 5.2.2 in v4 failover -->

    <t>When in PARTNER-DOWN state there is a waiting period after
    which a resource can be re-allocated to another client.  For
    resources which are available when the server enters PARTNER-DOWN
    state, the period is the MCLT from the entry into PARTNER-DOWN
    state.  For resources which are not available when the server
    enters PARTNER-DOWN state, the period is the MCLT after the
    later of the following times: the potential valid lifetime, the
    most recently transmitted potential valid lifetime, the most
    recently received acknowledged potential valid lifetime, and
    the most recently transmitted acknowledged potential valid
    lifetime.  If this time would be earlier than the current time
    plus the MCLT, then the time the server entered PARTNER-DOWN
    state plus the maximum-client-lead-time is used.</t>

    <!-- I don't think we want to discuss these paragraphs from the
     v4 draft.  Experience shows that nobody wants to live with MCLT
     restrictions in PARTNER-DOWN state.

    Two options exist for lease times given out while in PARTNER-DOWN
    state, with different ramifications flowing from each.

    If the server wishes the Failover protocol to protect it from loss of
    stable storage in PARTNER-DOWN state, then it should ensure that the
    MCLT based lease time restrictions in section 5.1 are maintained,
    even in PARTNER-DOWN state.

    If the server wishes to forego the protection of the Failover proto-
    col in the event of loss of stable storage, then it need recognize no
    restrictions on actual client lease times while in PARTNER-DOWN
    state.

    -->

    <t>In any other state, a server cannot reallocate a resource from one
    client to another without first notifying its partner (through a
    BNDUPD message) and receiving acknowledgement (through a BNDACK message) 
    that its partner is aware that that first client is not using
    the resource.</t>

    <t>This could be modeled in the following way.  Though this specific
    implementation is in no way required, it may serve to better illustrate 
    the concept.</t>

    <t>An "available" resource on a server may be allocated to any client.
    A resource which was leased to a client and which expired or was
    released by that client would take on a new state, EXPIRED or
    RELEASED respectively.  The partner server would then be notified
    that this resource was EXPIRED or RELEASED through a BNDUPD.  When
    the sending server received the BNDACK for that resource showing it
    was FREE, it would move the resource from EXPIRED or RELEASED to
    FREE, and it would be available for allocation by the primary server
    to any clients.</t>

    <t>A server MAY reallocate a resource in the EXPIRED or RELEASED
    state to the same client with no restrictions provided it has not
    sent a BNDUPD message to its partner.  This situation would exist if
    the lease expired or was released after the transition into
    PARTNER-DOWN state, for instance.</t>

  </section>


</section> <!-- partner update -->

  <section anchor="states" title="Endpoint States">
    <section anchor="state-machine-operation" title="State Machine Operation">

      <t>Each server (or, more accurately, failover endpoint) can take
      on a variety of failover states.  These states play a crucial role
      in determining the actions that a server will perform when
      processing a request from a DHCPv6 client as well as dealing with
      changing external conditions (e.g., loss of connection to a failover
      partner).</t>

      <t> The failover state in which a server is running controls the following
      behaviors: </t>
        <t><list style="symbols">

          <t>Responsiveness -- the server is either responsive to DHCPv6
          client requests or it is not.</t>

          <t>Allocation Pool -- which pool of addresses (or prefixes) can be
          used for advertisement on receipt of a SOLICIT or allocation on receipt
	  of a REQUEST message.</t>

          <t>MCLT -- ensure that valid lifetimes are not beyond what the partner
          has acked plus the MCLT (or not).</t>

        </list></t>

      <t>A server will transition from one failover state to another based
      on the specific values held by the following state variables:</t>

        <t><list style="symbols">

          <t>Current failover state.</t>

          <t>Communications status (OK or not OK).</t>

          <t>Partner's failover state (if known).</t>

        </list></t>

      <t>Whenever any of the above state variables
      changes state, the state machine is invoked, which may then trigger a
      change in the current failover state.  Thus, whenever the communications
      status changes, the state machine processing is invoked.  This may or
      may not result in a change in the current failover state.</t>

      <t>Whenever a server transitions to a new failover state, the new state
      MUST be communicated to its failover partner in a STATE message if the
      communications status is OK.  In addition, whenever a server makes a
      transition into a new state, it MUST record the new state, its current
      understanding of its partner's state, and the time at which it entered the
      new state in stable storage.</t>

      <t>The following state transition diagram gives a condensed view of the
      state machine.  If there is a difference between the words describing a
      particular state and the diagram below, the words should be considered
      authoritative.</t>

      <t>In the state transition diagram below, the "+" or "-" in the upper
      right corner of each state is a notation about whether communication is
      ongoing with the other server.

      <!-- that's an ugly hack: add couple extra lines here, so the diagram
      ends on a new page -->
      <vspace blankLines="8"/>
      </t>

    <figure anchor="endpoint-state-machine" title="Failover Endpoint State Machine">
    <artwork>
    <![CDATA[
    +---------------+  V  +--------------+
    |    RECOVER -|+|  |  |   STARTUP  - |
    |(unresponsive) |  +->+(unresponsive)|
    +------+--------+     +--------------+
    +-Comm. OK             +-----------------+
    |     Other State:     |  PARTNER DOWN - +<---------------------+
    |    RESOLUTION-INTER. | (responsive)    |                      ^
   All     POTENTIAL-      +----+------------+                      |
  Others   CONFLICT------------ | --------+                         |
    |      CONFLICT-DONE     Comm. OK     |     +--------------+    |
 UPDREQ or                 Other State:   |  +--+ RESOLUTION - |    |
 UPDREQALL                  |       |     |  |  | INTERRUPTED  |    |
 Rcv UPDDONE             RECOVER    All   |  |  | (responsive) |    |
    |  +---------------+    |      Others |  |  +------------+-+    |
    +->+RECOVER-WAIT +-| RECOVER    |     |  |         ^     |      |
       |(unresponsive) |  WAIT or   |     |  Comm.     |    Ext.    |
       +-----------+---+  DONE      |     |  OK     Comm.   Cmd---->+
Comm.---+     Wait MCLT     |       V     V  V     Failed           |
Changed |          V    +---+   +---+-----+--+-+       |            |
 |  +---+----------++   |       |  POTENTIAL + +-------+            |
 |  |RECOVER-DONE +-|  Wait     |  CONFLICT    +------+             |
 +->+(unresponsive) |  for      |(unresponsive)|   Primary          |
    +------+--------+  Other  +>+----+--------++   resolve    Comm. |
     Comm. OK          State: |      |        ^    conflict  Changed|
+---Other State:-+   RECOVER  |   Secondary   |       V       V   | |
|    |           |     DONE   |    resolve    |  ++----------+---++ |
| All Others:  POTENT.  |     |   conflict    |  |CONFLICT-DONE-|+| |
| Wait for    CONFLICT--|-----+      |        |  | (responsive)   | |
| Other State:          V            V        |  +------+---------+ |
| NORMAL or RECOVER    ++------------+---+    | Other State: NORMAL |
|    |       DONE      |     NORMAL    + +<--------------+          |
|    +--+----------+-->+  (responsive)   +-------External Command-->+
|       ^          ^   +--------+--------+                          |
|       |          |            |             |                     |
|   Wait for   Comm. OK  Comm. Failed         |                     |
|    Other      Other           |             |             External
|    State:     State:          |             |             Command
| RECOVER-DONE  NORMAL     Start Safe      Comm. OK            or
|       |     COMM. INT.  Period Timer    Other State:        Safe
|    Comm. OK.     |            V          All Others        Period
|   Other State:   |  +---------+--------+    |            expiration
|     RECOVER      +--+ COMMUNICATIONS - +----+                     |
|       +-------------+   INTERRUPTED    |                          |
RECOVER               |  (responsive)    +------------------------->+
RECOVER-WAIT--------->+------------------+
]]></artwork></figure>

    </section> <!-- state-machine-operation -->

    <section anchor="state-init" title="State Machine Initialization">

      <t>The state machine is characterized by storage (in stable storage) of at least the
      following information:</t>

        <t><list style="symbols">

          <t>Current failover state.</t>

          <t>Previous failover state.</t>

          <t>Start time of current failover state.</t>

          <t>Partner's failover state.</t>

          <t>Start time of partner's failover state.</t>

          <t>Time most recent packet received from partner.</t>

        </list></t>

      <t>The state machine is initialized by reading these data items
      from stable storage and restoring their values from the information
      saved.  If there is no information in stable storage concerning these
      items, then they should be initialized as follows:</t>

        <t><list style="symbols">

          <t>Current failover state:  Primary: PARTNER-DOWN, Secondary: RECOVER</t>

          <t>Previous failover state:  None.</t>

          <t>Start time of current failover state: Current time.</t>

          <t>Partner's failover state: None until reception of STATE message.</t>

          <t>Start time of partner's failover state: None until reception of STATE message.</t>

          <t>Time most recent packet received from partner: None until packet received.</t>

        </list></t>

    </section>

    <section anchor="state-startup" title="STARTUP State">

      <t>The STARTUP state affords an opportunity for a server to
      probe its partner server, before starting to service DHCP
      clients.  When in the STARTUP state, a server attempts to
      learn its partner's state and determine (using that information
      if it is available) what state it should enter.</t>

      <t>The STARTUP state is not shown with any specific state
      transitions in the <xref target="endpoint-state-machine">state machine
      diagram</xref> because the processing during the STARTUP state
      can cause the server to transition to any of the other states,
      so that specific state transition arcs would only obscure
      other information.</t>

      <section anchor="operation-in-startup-state" title="Operation in STARTUP State">

        <t>The server MUST NOT be responsive to DHCPv6 clients in STARTUP state.</t>

        <t>Whenever a STATE message is sent to the partner while
        in STARTUP state the STARTUP flag MUST be set in the message
        and the previously recorded failover state MUST be placed
        in the server-state option.</t>

      </section> <!-- operation-in-startup-state -->

      <section anchor="transition-out-of-startup-state" title="Transition Out of STARTUP State">

        <t>The following algorithm is followed every time the
        server initializes itself, and enters STARTUP state.</t>

        <t>Step 1:</t>

        <t>If there is any record in stable storage of a previous
        failover state for this server, set PREVIOUS-STATE to the
        last recorded value in stable storage, and go to Step 2.</t>

        <t>If there is no record of any previous failover state in
        stable storage for this server, then set the PREVIOUS-STATE
        to RECOVER and set the TIME-OF-FAILURE to 0.  This will
        allow two servers which already have lease information to
        synchronize themselves prior to operating.</t>

        <t>In some cases, an existing server will be commissioned
        as a failover server and brought back into operation where
        its partner is not yet available.  In this case, the newly
        commissioned failover server will not operate until its
        partner comes online  -- but it has operational responsibilities
        as a DHCP server nonetheless.  To properly handle this
        situation, a server SHOULD be configurable in such a way
        as to move directly into PARTNER-DOWN state after the startup
        period expires if it has been unable to contact its partner
        during the startup period.</t>

        <t>Step 2:</t>

	<t>Implementations will differ in the ways that they deal
	with the state machine for failover endpoint states.  In
	many cases, state transitions will occur when communications
	goes from "OK" to failed, or from failed to "OK", and some
	implementations will implement a portion of their state
	machine processing based on these changes.</t>
	
	<t>In these cases, during startup, if the previous state
	is one where communications was "OK", then set the previous
	state to the state that is the result of the communications
	failed state transition when in that state (if such transition
	exists -- some states don't have a communications failed
	state transition, since they allow both communications OK
	and failed).</t>

        <t>Step 3:</t>

        <t>Start the STARTUP state timer.  The time that a server
        remains in the STARTUP state (absent any communications
        with its partner) is implementation dependent but SHOULD
        be short.  It SHOULD be long enough for a TCP connection
        to be created to a heavily loaded partner across a slow
        network.</t>

        <t>Step 4:</t>

        <t>Attempt to create a TCP connection to the failover partner.</t>

        <t>Step 5:</t>

        <t>Wait for "communications OK".</t>

        <t>When and if communications become "okay", clear the STARTUP
        flag, and set the current state to the PREVIOUS-STATE.</t>

        <t>If the partner is in PARTNER-DOWN state, and if the time
        at which it entered PARTNER-DOWN state (as received in the
        start-time-of-state option in the STATE message) is later
        than the last recorded time of operation of this server,
        then set CURRENT-STATE to RECOVER.  If the time at which
        it entered PARTNER-DOWN state is earlier than the last
        recorded time of operation of this server, then set
        CURRENT-STATE to POTENTIAL-CONFLICT.</t>

        <t>Then, transition to the current state and take the
        "communications OK" state transition based on the current
        state of this server and the partner.</t>

        <t>Step 6:</t>

        <t>If the startup time expires the server SHOULD transition
        to the PREVIOUS-STATE.</t>

      </section> <!-- transition-out-of-startup-state -->

    </section> <!-- end of STARTUP state -->

    <section anchor="state-partner-down" title="PARTNER-DOWN State">

    <t>PARTNER-DOWN state is a state either server can enter.  When
    in this state, the server assumes that it is the only server
    operating and serving the client base. If one server is in
    PARTNER-DOWN state, the other server MUST NOT be operating.</t>

    <t>A server can enter PARTNER-DOWN state either as a result of 
    operator intervention (when an operator determines that the server's
    partner is, indeed, down), or as a result of an optional auto-partner-down
    capability where PARTNER-DOWN state is entered automatically after
    a server has been in COMMUNICATIONS-INTERRUPTED state for a pre-determined
    period of time.</t>

      <section anchor="operation-in-partner-down-state" title="Operation in PARTNER-DOWN State">

        <t>The server MUST be responsive in PARTNER-DOWN state, regardless
	if it is primary or secondary.</t>

        <t>It will allow renewal of all outstanding leases on resources.
        For those resources for which the server is
        using proportional allocation, it will allocate resources
        from its own pool, and after a fixed period of time (the
        MCLT interval) has elapsed from entry into PARTNER-DOWN
        state, it may allocate IP addresses from the set of all
        available pools. Server SHOULD fully deplete its own pool,
	before starting allocations from its downed partner's pool.</t>

        <t>Any resource tagged as available for allocation by the
        other server (at entry to PARTNER-DOWN state) MUST NOT be
        allocated to a new client until the MCLT
        beyond the entry into PARTNER-DOWN state has elapsed.</t>

        <t>A server in PARTNER-DOWN state MUST NOT allocate a resource
        to a DHCP client different from that to which it was
        allocated at the entrance to PARTNER-DOWN state until the
        MCLT beyond the maximum of the following
        times: client expiration time, most recently transmitted
        potential-expiration-time, most recently received ack of
        potential-expiration-time from the partner, and most recently
        acked potential-expiration-time to the partner.  <!-- tomek:
        commented out as don't have section about BNDUPD message yet.
        See section 7.1.5 for details. --> If this time would be earlier
        than the current time plus the maximum-client-lead-time, then
        the time the server entered PARTNER-DOWN state plus the
        maximum-client-lead-time is used.</t>

        <t>The server is not restricted by the MCLT when offering
        lease times while in PARTNER-DOWN state.</t>

        <t>In the unlikely case when there are two servers operating
        in a PARTNER-DOWN state, there is a chance of duplicate leases
        assigned. This leads to a POTENTIAL-CONFLICT (unresponsive)
        state when they re-establish contact. The duplicate lease
        issue can be postponed to a large extent by the server granting
        new leases first from its own pool. Therefore the server operating
        in PARTNER-DOWN state MUST use its own pool first for new
        leases before assigning any leases from its downed partner pool.
        </t>

      </section> <!-- operation-in-partner-down-state -->

      <section anchor="transition-out-of-partner-down-state" title="Transition Out of PARTNER-DOWN State">

        <t>When a server in PARTNER-DOWN state succeeds in establishing
        a connection to its partner, its actions are conditional
        on the state and flags received in the STATE message from
        the other server as part of the process of establishing the
        connection.</t>

        <t>If the STARTUP bit is set in the server-flags option of
        a received STATE message, a server in PARTNER-DOWN state
        MUST NOT take any state transitions based on reestablishing
        communications. Essentially, if a server is in PARTNER-DOWN
        state, it ignores all STATE messages from its partner that
        have the STARTUP bit set in the server-flags option of the
        STATE message.</t>

        <t>If the STARTUP bit is not set in the server-flags option
        of a STATE message received from its partner, then a server
        in PARTNER-DOWN state takes the following actions based on
        the state of the partner as received in a STATE message
        (either immediately after establishing communications or
        at any time later when a new state is received)</t>

        <t><list style="symbols">

        <t>If the partner is in: [ NORMAL, COMMUNICATIONS-INTERRUPTED, PARTNER-DOWN,
        POTENTIAL-CONFLICT, RESOLUTION-INTERRUPTED, or CONFLICT-DONE ]
        state, then transition to POTENTIAL-CONFLICT state</t>

        <t>If the partner is in: [ RECOVER, RECOVER-WAIT ] state stay in PARTNER-DOWN state</t>

        <t>If the partner is in: [ RECOVER-DONE ] state transition into NORMAL state</t>

        </list></t>

      </section> <!-- transition-out-of-partner-down-state -->

    </section> <!-- end of partner-down state -->

    <section anchor="state-recover" title="RECOVER State">

      <t>This state indicates that the server has no information
      in its stable storage or that it is re-integrating with a
      server in PARTNER-DOWN state after it has been down.  A server
      in this state MUST attempt to refresh its stable storage from
      the other server.</t>

      <section anchor="operation-in-recover-state" title="Operation in RECOVER State">

        <t>The server MUST NOT be responsive in RECOVER state.</t>

        <t>A server in RECOVER state will attempt to reestablish
        communications with the other server.</t>

      </section> <!-- operation-in-recover-state -->

      <section anchor="transition-out-of-recover-state" title="Transition Out of RECOVER State">

        <t>If the other server is in POTENTIAL-CONFLICT,
        RESOLUTION-INTERRUPTED, or CONFLICT-DONE state when
        communications are reestablished, then the server in RECOVER
        state will move to POTENTIAL-CONFLICT state itself.</t>

        <t>If the other server is in any other state, then the
        server in RECOVER state will request an update of missing
        binding information by sending an UPDREQ message.  If the
        server has determined that it has lost its stable storage
        because it has no record of ever having talked to its
        partner, while its partner does have a record of communicating
        with it, it MUST send an UPDREQALL message, otherwise it
        MUST send an UPDREQ message.</t>

        <t>It will wait for an UPDDONE message, and upon receipt
        of that message it will transition to RECOVER-WAIT state.</t>

        <t>If communications fails during the reception of the
        results of the UPDREQ or UPDREQALL message, the server will
        remain in RECOVER state, and will re-issue the UPDREQ or
        UPDREQALL when communications are re-established.</t>

        <t>If an UPDDONE message isn't received within an implementation
        dependent amount of time, and no BNDUPD messages are being
        received, the connection SHOULD be dropped.</t>

        <figure anchor="figure-transition-out-of-recover-state" title="Transition out of RECOVER state">
        <artwork><![CDATA[
                A                                        B
              Server                                  Server

                |                                        |
             RECOVER                               PARTNER-DOWN
                |                                        |
                | >--UPDREQ-------------------->         |
                |                                        |
                |        <---------------------BNDUPD--< |
                | >--BNDACK-------------------->         |
               ...                                      ...
                |                                        |
                |        <---------------------BNDUPD--< |
                | >--BNDACK-------------------->         |
                |                                        |
                |        <--------------------UPDDONE--< |
                |                                        |
           RECOVER-WAIT                                  |
                |                                        |
                | >--STATE-(RECOVER-WAIT)------>         |
                |                                        |
                |                                        |
       Wait MCLT from last known                         |
          time of failover operation                     |
                |                                        |
           RECOVER-DONE                                  |
                |                                        |
                | >--STATE-(RECOVER-DONE)------>         |
                |                                     NORMAL
                |        <-------------(NORMAL)-STATE--< |
             NORMAL                                      |
                | >---- State-(NORMAL)--------------->   |
                |                                        |
                |                                        |
        ]]></artwork></figure>


        <t>If at any time while a server is in RECOVER state
        communications fails, the server will stay in RECOVER state.
        When communications are restored, it will restart the process
        of transitioning out of RECOVER state.</t>

      </section> <!-- transition-out-of-recover-state -->

    </section> <!-- end of recover state -->

    <section anchor="state-recover-wait" title="RECOVER-WAIT State">

      <t>This state indicates that the server has sent an UPDREQ
      or UPDREQALL and has received the UPDDONE message indicating
      that it has received all outstanding binding update information.
      In the RECOVER-WAIT state the server will wait for the MCLT
      in order to ensure that any processing that this server might
      have done prior to losing its stable storage will not cause
      future difficulties.</t>

      <section anchor="operation-in-recover-wait-state" title="Operation in RECOVER-WAIT State">

        <t>The server MUST NOT be responsive in RECOVER-WAIT state.</t>

      </section> <!-- operation-in-recover-wait-state -->

      <section anchor="transition-out-of-recover-wait-state" title="Transition Out of RECOVER-WAIT State">

        <t>Upon entry to RECOVER-WAIT state the server MUST start
        a timer whose expiration is set to a time equal to the time
        the server went down (if known) or the time the server
        started (if the down-time is unknown) plus the
        maximum-client-lead-time.  When this timer expires, the
        server will transition into RECOVER-DONE state.</t>

        <t>This is to allow any IP addresses that were allocated
        by this server prior to loss of its client binding information
        in stable storage to contact the other server or to time
        out.</t>

        <t>If this is the first time this server has run failover
        -- as determined by the information received from the
        partner, not necessarily only as determined by this server's
        stable storage (as that may have been lost), then the waiting
        time discussed above may be skipped, and the server MAY
        transition immediately to RECOVER-DONE state.</t>

        <t>If the server has never before run failover, then there
        is no need to wait in this state -- but, again, to determine
        if this server has run failover it is vital that the
        information provided by the partner be utilized, since the
        stable storage of this server may have been lost.</t>

        <t>If communications fails while a server is in RECOVER-WAIT
        state, it has no effect on the operation of this state.
        The server SHOULD continue to operate its timer, and if the
        timer expires during the period where communications with
        the other server have failed, then the server SHOULD
        transition to RECOVER-DONE state.  This is rare -- failover
        state transitions are not usually made while communications
        are interrupted, but in this case there is no reason to
        inhibit the timer.</t>

      </section> <!-- transition-out-of-recover-wait-state -->

    </section> <!-- recover-wait state -->

    <section anchor="state-recover-done" title="RECOVER-DONE State">

      <t>This state exists to allow an interlocked transition for
      one server from RECOVER state and another server from
      PARTNER-DOWN or COMMUNICATIONS-INTERRUPTED state into NORMAL
      state.</t>

      <section anchor="operation-in-recover-done-state" title="Operation in RECOVER-DONE State">

        <t>A server in RECOVER-DONE state SHOULD be unresponsive, but MAY 
	respond to RENEW requests but MUST only change the state of resources
	that appear in the RENEW request.  It MUST NOT allocate any additional
	resources when in RECOVER-DONE state.</t>

      </section> <!-- operation-in-recover-done-state -->

      <section anchor="transition-out-of-recover-done-state"
               title="Transition Out of RECOVER-DONE State">

        <t>When a server in RECOVER-DONE state determines that its
        partner server has entered NORMAL or RECOVER-DONE state,
        then it will transition into NORMAL state.</t>

        <t>If communication fails while in RECOVER-DONE state, a
        server will stay in RECOVER-DONE state.</t>

      </section> <!-- transition-out-of-recover-done-state -->

    </section> <!-- recover-done state -->

    <section anchor="state-normal" title="NORMAL State">
      <t>NORMAL state is the state used by a server when it is communicating
      with the other server, and any required resynchronization has been
      performed. While some bindings database synchronization is performed
      in NORMAL state, potential conflicts are resolved prior to entry into
      NORMAL state as is binding database data loss.</t>

      <t>When entering NORMAL state, a server will send to the other server
      all currently unacknowledged binding updates as BNDUPD messages.</t>

      <t>When the above process is complete, if the server entering NORMAL
      state is a secondary server, then it will request resources (addresses
      and/or prefixes) for allocation using the POOLREQ message.</t>

      <section anchor="operation-in-normal-state"
               title="Operation in NORMAL State">

      <t>Primary server is responsive in NORMAL state. Secondary is
      unresponsive in NORMAL state.</t>

        <t>When in NORMAL state a primary server will operate in the following manner:
      <list style="hanging">
        <t hangText="Lease time calculations"> <vspace/>

        As discussed in 
	<xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>, the
        lease interval given to a DHCP client can never be more than the
        MCLT greater than the most recently received 
	potential-expiration-time from the failover partner or the current time,
        whichever is later.
        <vspace blankLines="1"/>
        As long as a server adheres to this constraint, the specifics of
        the lease interval that it gives to a DHCP client or the value
        of the potential-expiration-time sent to its failover partner
        are implementation dependent.</t>

        <t hangText="Lazy update of partner server"> <vspace/>

        After sending a REPLY that includes a lease update to a client,
        the server servicing a DHCP client request attempts to update
        its partner with the new binding information.</t> 

        <t hangText="Reallocation of resources between clients"> <vspace/>

        Whenever a client binding is released or expires, a BNDUPD
        message must be sent to the partner, setting the binding
        state to RELEASED or EXPIRED.  However, until a BNDACK is
        received for this message, the resource cannot be allocated
        to another client.  It cannot be allocated to the same client
        again if a BNDUPD was sent, otherwise it can. See <xref
        target="reallocation"/> for details.
        </t>
      </list>
      </t>

      <t>In NORMAL state, each server receives binding updates from
      its partner server in BNDUPD messages. It records these in its
      client binding database in stable storage and then sends a
      corresponding BNDACK message to its partner server.</t>

      </section> <!-- operation-in-normal-state -->
      <section anchor="transition-out-of-normal-state"
               title="Transition Out of NORMAL State">
        <t>If an external command is received by a server in NORMAL
        state informing it that its partner is down, then transition
        into PARTNER- DOWN state.  Generally, this would be an unusual
        situation, where some external agency knew the partner server
        was down prior to the failover server discovering it on its
	own.</t>  
        <!-- Does it make sense? That is at least strange - server maintain
        connection with its parner and suddenly operator states that that
        partner is down. -->

        <t>If a server in NORMAL state fails to receive acks to messages sent to
        its partner for an implementation dependent period of time, it MAY
        move into COMMUNICATIONS-INTERRUPTED state.  This situation might
        occur if the partner server was capable of maintaining the TCP connection 
	between the server and also capable of sending a CONTACT message 
	periodically, but was (for some reason) incapable of processing 
	BNDUPD messages.</t>

        <t>If the communications is determined to not be "ok" (as
        defined in <xref target="reachability"/>), then transition
        into COMMUNICATIONS-INTERRUPTED state.</t>

        <t>If a server in NORMAL state receives any messages from its partner
        where the partner has changed state from that expected by the server
        in NORMAL state, then the server should transition into
        COMMUNICATIONS-INTERRUPTED state and take the appropriate state transition 
	from there.  For example, it would be expected for the partner
        to transition from POTENTIAL-CONFLICT into NORMAL state, but not for
        the partner to transition from NORMAL into POTENTIAL-CONFLICT state.</t>

        <t><!-- we don't need PAUSED If a server in NORMAL state
        receives any messages from its partner where the PARTNER has
        changed into PAUSED state, the server should transition into
        COMMUNICATIONS-INTERRUPTED state. -->If a server in NORMAL
        state receives a DISCONNECT message from its partner, the server should transition
        into COMMUNICATIONS-INTERRUPTED state.</t>
      </section> <!-- transition-out-of-normal-state -->
    </section> <!-- normal state -->

    <section anchor="state-comm-interrrupted"
             title="COMMUNICATIONS-INTERRUPTED State">
      <t>A server goes into COMMUNICATIONS-INTERRUPTED state whenever it is
      unable to communicate with its partner. Primary and secondary
      servers cycle automatically (without administrative intervention)
      between NORMAL and COMMUNICATIONS-INTERRUPTED state as the network
      connection between them fails and recovers, or as the partner server
      cycles between operational and non-operational.  No duplicate resource
      allocation can occur while the servers cycle between these
      states.</t>

      <t>When a server enters COMMUNICATIONS-INTERRUPTED state, if it has been
      configured to support an automatic transition out of COMMUNICATIONS-
      INTERRUPTED state and into PARTNER-DOWN state (i.e., a auto-partner-down
      has been configured), then a timer MUST be started
      for the length of the configured auto-partner-down period.</t>
      <!-- tomek: Issue 15: do we want auto-partner-down timer? -->

      <t>A server transitioning into the COMMUNICATIONS-INTERRUPTED
      state from the NORMAL state SHOULD raise some alarm condition to
      alert administrative staff to a potential problem in the DHCP
      subsystem.</t>

      <section anchor="operation-in-comm-interrupted-state"
               title="Operation in COMMUNICATIONS-INTERRUPTED State">

        <t>In this state a server MUST respond to all DHCP client
        requests.  When allocating new leases, each server allocates
        from its own pool, where the primary MUST allocate only FREE
        resources, and the secondary MUST
        allocate only FREE_BACKUP resources.  When
        responding to RENEW messages, each server will allow continued
        renewal of a DHCP client's current lease on a resource
        irrespective of whether that lease was given out by the
        receiving server or not, although the renewal period MUST NOT
        exceed the maximum client lead time (MCLT) beyond the latest
        of: 1) the potential valid lifetime already acknowledged by
        the other server, or 2) now, or 3) the potential valid lifetime 
	received from the partner server.</t>

        <t>However, since the server cannot communicate with its
        partner in this state, the acknowledged potential valid
        lifetime will not be updated in any new bindings.  This is
        likely to eventually cause the actual valid lifetimes to
	converge to the MCLT (unless this is greater than
        the desired-client-lease-time).</t>

        <t>The server should continue to try to establish a connection
        with its partner.</t>

      </section> <!-- operation-in-comm-interrrupted-state -->
      <section anchor="transition-out-of-comm-interrrupted-state"
               title="Transition Out of COMMUNICATIONS-INTERRUPTED State">

        <t>If the safe period timer expires while a server is in the
        COMMUNICATIONS-INTERRUPTED state, it will transition immediately into
        PARTNER-DOWN state.</t>

        <t>If an external command is received by a server in COMMUNICATIONS-
        INTERRUPTED state informing it that its partner is down, it will
        transition immediately into PARTNER-DOWN state.</t>

        <t>If communications is restored with the other server, then the server
        in COMMUNICATIONS-INTERRUPTED state will transition into another
        state based on the state of the partner:

        <list style="symbols">
          <t>NORMAL or COMMUNICATIONS-INTERRUPTED: Transition into the
          NORMAL state.</t>
          <!-- The partner SHOULD NOT be in NORMAL state here, since upon res-
          toration of communications it MUST have created a new TCP con-
          nection which would have forced it into COMMUNICATIONS-
          INTERRUPTED state.  Still, we should account for every state
          just in case. -->

          <t>RECOVER: Stay in COMMUNICATIONS-INTERRUPTED state.</t>

          <t>RECOVER-DONE: Transition into NORMAL state.</t>

          <t>PARTNER-DOWN, POTENTIAL-CONFLICT, CONFLICT-DONE, or
          RESOLUTION-INTERRUPTED: Transition into POTENTIAL-CONFLICT
          state.</t>

        </list></t>

        <t>The following figure illustrates the transition from NORMAL
        to COMMUNICATIONS-INTERRUPTED state and then back to NORMAL
        state again.</t>

        <!-- this title is too long. That should be a caption field -->
        <figure anchor="state-change-example" title="Transition from NORMAL to
         COMMUNICATIONS-INTERRUPTED and back (example with 2 addresses
         allocated to secondary)">
          <artwork><![CDATA[
   Primary                                Secondary
    Server                                  Server

    NORMAL                                  NORMAL
      | >--CONTACT------------------->         |
      |        <--------------------CONTACT--< |
      |         [TCP connection broken]        |
 COMMUNICATIONS          :              COMMUNICATIONS
   INTERRUPTED           :                INTERRUPTED
      |      [attempt new TCP connection]      |
      |         [connection succeeds]          |
      |                                        |
      | >--CONNECT------------------->         |
      |        <-----------------CONNECTACK--< |
      |                                     NORMAL
      |        <-------------------STATE-----< |
    NORMAL                                     |
      | >--STATE--------------------->         |
      |
      | >--BNDUPD-------------------->         |
      |        <---------------------BNDACK--< |
      |                                        |
      |        <---------------------BNDUPD--< |
      | >------BNDACK---------------->         |
     ...                                      ...
      |                                        |
      |        <--------------------POOLREQ--< |
      | >--POOLRESP------------------>         |
      |                                        |
      | >--BNDUPD-(#1)--------------->         |
      |        <---------------------BNDACK--< |
      |                                        |
      | >--BNDUPD-(#2)--------------->         |
      |        <---------------------BNDACK--< |
      |                                        |]]></artwork></figure>



      </section> <!-- transition-out-of-comm-interrrupted-state -->
    </section> <!-- comm-interrrupted state -->

    <section anchor="state-potential-conflict" title="POTENTIAL-CONFLICT State">
      <t>This state indicates that the two servers are attempting to
      reintegrate with each other, but at least one of them was
      running in a state that did not guarantee automatic
      reintegration would be possible.  In POTENTIAL-CONFLICT state
      the servers may determine that the same resource has been
      offered and accepted by two different clients.</t>

      <t>It is a goal of this protocol to minimize the possibility that
      POTENTIAL-CONFLICT state is ever entered.</t>

      <t>When a primary server enters POTENTIAL-CONFLICT state it should
      request that the secondary send it all updates of which it is
      currently unaware by sending an UPDREQ message to the secondary
      server.</t>

      <t>A secondary server entering POTENTIAL-CONFLICT state will wait for
      the primary to send it an UPDREQ message.</t>

      <section anchor="operation-in-potential-conflict-state"
               title="Operation in POTENTIAL-CONFLICT State">
        <t>Any server in POTENTIAL-CONFLICT state MUST NOT process any
        incoming DHCP requests.</t>
      </section> <!-- operation-in-potential-conflict-state -->
      <section anchor="transition-out-of-potential-conflict-state"
               title="Transition Out of POTENTIAL-CONFLICT State">

        <t>If communications fails with the partner while in
        POTENTIAL-CONFLICT state, then the server will transition to
        RESOLUTION-INTERRUPTED state.</t>

        <t>Whenever either server receives an UPDDONE message from its
        partner while in POTENTIAL-CONFLICT state, it MUST transition
        to a new state.  The primary MUST transition to CONFLICT-DONE
        state, and the secondary MUST transition to NORMAL state.
        This will cause the primary server to leave POTENTIAL-CONFLICT
        state prior to the secondary, since the primary sends an
        UPDREQ message and receives an UPDDONE before the secondary
        sends an UPDREQ message and receives its UPDDONE message.</t>

        <t>When a secondary server receives an indication that the primary
        server has made a transition from POTENTIAL-CONFLICT to CONFLICT-DONE
        state, it SHOULD send an UPDREQ message to the primary server.</t>

<figure anchor="out-of-potential-conflict"
        title="Transition out of POTENTIAL-CONFLICT">
    <artwork><![CDATA[
    Primary                                Secondary
    Server                                  Server

      |                                        |
POTENTIAL-CONFLICT                    POTENTIAL-CONFLICT
      |                                        |
      | >--UPDREQ-------------------->         |
      |                                        |
      |        <---------------------BNDUPD--< |
      | >--BNDACK-------------------->         |
     ...                                      ...
      |                                        |
      |        <---------------------BNDUPD--< |
      | >--BNDACK-------------------->         |
      |                                        |
      |        <--------------------UPDDONE--< |
CONFLICT-DONE                                  |
      | >--STATE--(CONFLICT-DONE)---->         |
      |        <---------------------UPDREQ--< |
      |                                        |
      | >--BNDUPD-------------------->         |
      |        <---------------------BNDACK--< |
     ...                                      ...
      | >--BNDUPD-------------------->         |
      |        <---------------------BNDACK--< |
      |                                        |
      | >--UPDDONE------------------->         |
      |                                     NORMAL
      |        <------------STATE--(NORMAL)--< |
   NORMAL                                      |
      | >--STATE--(NORMAL)----------->         |
      |                                        |
      |        <--------------------POOLREQ--< |
      | >------POOLRESP-------------->         |
      |                                        |]]></artwork></figure>



      </section> <!-- transition-out-of-potential-conflict-state -->
    </section> <!-- potential-conflict state -->

    <section anchor="state-resolution-interrupted" title="RESOLUTION-INTERRUPTED State">
      <t>This state indicates that the two servers were attempting to
      reintegrate with each other in POTENTIAL-CONFLICT state, but
      communications failed prior to completion of re-integration.</t>

      <t>The RESOLUTION-INTERRUPTED state exists because
      servers are not responsive in POTENTIAL-CONFLICT state, and
      if one server drops out of service while both servers
      are in POTENTIAL-CONFLICT state, the server that remains
      in service will not be able to process DHCP client requests and
      there will be no DHCP service available.  The RESOLUTION-INTERRUPTED
      state is the state that a server moves to if its partner
      disappears while it is in POTENTIAL-CONFLICT state.</t>

      <t>When a server enters RESOLUTION-INTERRUPTED state it SHOULD raise an
      alarm condition to alert administrative staff of a problem in the
      DHCP subsystem.</t>

      <section anchor="operation-in-resolution-interrupted-state"
               title="Operation in RESOLUTION-INTERRUPTED State">
        <t>In this state a server MUST respond to all DHCP client
        requests. When allocating new resources, each server SHOULD 
	allocate from its own pool (if
        that can be determined), where the primary SHOULD allocate
        only FREE resources, and the secondary SHOULD allocate only
        FREE_BACKUP resources. When responding to renewal requests, each
        server will allow continued renewal of a DHCP client's current
        lease independent of whether that lease was given out by the
        receiving server or not, although the renewal period MUST NOT
        exceed the maximum client lead time (MCLT) beyond the latest
        of: 1) the potential valid lifetime already acknowledged by
        the other server or 2) now or 3) potential valid lifetime 
	received from the partner server.</t>

        <t>However, since the server cannot communicate with its
        partner in this state, the acknowledged potential valid
        lifetime will not be updated in any new bindings.</t>
      </section> <!--
        operation-in-resolution-interrupted-state -->
      <section anchor="transition-out-of-resolution-interrupted-state"
               title="Transition Out of RESOLUTION-INTERRUPTED State">

        <t>If an external command is received by a server in
        RESOLUTION-INTERRUPTED state informing it that its partner is
        down, it will transition immediately into PARTNER-DOWN
        state.</t>

        <t>If communications is restored with the other server, then
        the server in RESOLUTION-INTERRUPTED state will transition
        into POTENTIAL-CONFLICT state.</t>

      </section> <!-- transition-out-of-resolution-interrupted-state -->
    </section> <!-- resolution-interrupted state -->

    <section anchor="state-conflict-done" title="CONFLICT-DONE State">
      <t>This state indicates that during the process where the two
      servers are attempting to re-integrate with each other, the
      primary server has received all of the updates from the
      secondary server.  It makes a transition into CONFLICT-DONE state
      in order that it may be totally responsive to the client load.
      There is no operational difference between CONFLICT-DONE and
      NORMAL for primary as in both states it responds to all
      clients' requests. The distinction between CONFLICT-DONE and
      NORMAL states will be more apparent when load balancing 
      extension will be defined. <!--,
      as opposed to NORMAL state where it would be in a "balanced"
      responsive state, running the load balancing algorithm.--></t>

      <!-- issue 7  Kim: I believe we discussed this, and decided
      to leave CONFLICT-DONE in the state machine, so that when
      load-balancing is supported we won't have to rev the state
      machine.

      Yes, we did:  Tomek said this in some email on Sept 7, 2012:

	I'd like to comment on some decisions made regarding load
	balancing, before someone raises it again. v4 failover
	standardization failed, because the draft was too large and
	there was nobody willing to review it. That's why we try
	to succeed with v6 failover by splitting it to smaller
	chunks. That's why this failover covers the absolute minimum,
	i.e. active-passive only with load balancing being out of
	scope. You may notice that some of the states (RECOVER-DONE
	and CONFLICT-DONE) are really useful only for load balancing.
	We decided to keep them in to make extension to LB much
	simpler - the state machine will be operating in the same
	manner with and without LB. Obviously, there are many folks
	interested in load balancing. We are, too, but we want it
	to be an extension, defined in separate draft.
      
      Tomek: Ok, I've changed the wording slightly to not explicitly
      say that server does load balancing, as it is not officially
      defined yet. -->

      <section anchor="operation-in-conflict-done-state"
               title="Operation in CONFLICT-DONE State">
        <t>A primary server in CONFLICT-DONE state is fully responsive
        to all DHCP clients (similar to the situation in
        COMMUNICATIONS-INTERRUPTED state).</t>

        <t>If communications fails, remain in CONFLICT-DONE state.  If
        communications becomes OK, remain in CONFLICT-DONE state until
        the conditions for transition out become satisfied.</t>
      </section> <!-- operation-in-conflict-done-state -->
      <section anchor="transition-out-of-conflict-done-state"
               title="Transition Out of CONFLICT-DONE State">
        <t>If communications fails with the partner while in
        CONFLICT-DONE state, then the server will remain in
        CONFLICT-DONE state.</t>

        <t>When a primary server determines that the secondary
        server has made a transition into NORMAL state, the primary
        server will also transition into NORMAL state.</t>
      </section> <!-- transition-out-of-conflict-done-state -->
    </section> <!-- conflict-done state -->

  </section> <!-- endpoint states -->


  <section anchor="DDNS" title="Dynamic DNS Considerations">

    <t>DHCP servers (and clients) can use DNS Dynamic Updates as
    described in <xref target="RFC2136">RFC 2136</xref> to maintain
    DNS name-mappings as they maintain DHCP leases.  Many different
    administrative models for DHCP-DNS integration are possible.
    Descriptions of several of these models, and guidelines that
    DHCP servers and clients should follow in carrying them out,
    are laid out in <xref target="RFC4704">RFC 4704</xref>.</t>

    <t>The nature of the failover protocol introduces some issues
    concerning dynamic DNS (DDNS) updates that are not part of non-failover
    environments.  This section describes these issues, and defines
    the information which failover partners should exchange in order
    to ensure consistent behavior.  The presence of this section
    should not be interpreted as requiring an implementation of
    the DHCPv6 failover protocol to also support DDNS updates.</t>

    <t>The purpose of this discussion is to clarify the areas where
    the failover and DHCP-DDNS protocols intersect for the benefit
    of implementations which support both protocols, not to introduce
    a new requirement into the DHCPv6 failover protocol.  Thus, a
    DHCPv6 server which implements the failover protocol MAY also
    support dynamic DNS updates, but if it does support dynamic DNS
    updates it SHOULD utilize the techniques described here in order
    to correctly distribute them between the failover partners.
    See <xref target="RFC4704">RFC 4704</xref> as well as <xref
    target="RFC4703">RFC 4703</xref> for information on how DHCPv6
    servers deal with potential conflicts when updating DNS even
    without failover.</t>

    <t>From the standpoint of the failover protocol, there is no
    reason why a server which is utilizing the DDNS protocol to
    update a DNS server should not be a partner with a server which
    is not utilizing the DDNS protocol to update a DNS server.
    However, a server which is not able to support DDNS or is not
    configured to support DDNS SHOULD output a warning message when
    it receives BNDUPD messages which indicate that its failover
    partner is configured to support the DDNS protocol to update a
    DNS server.  An implementation MAY consider this an error and
    refuse to operate, or it MAY choose to operate anyway, having
    warned the administrator of the problem in some way.</t>

    <section anchor="failover-ddns"
       title="Relationship between failover and dynamic DNS update">

	<t>The failover protocol describes the conditions under
	which each failover server may renew a lease to its current
	DHCP client, and describes the conditions under which it
	may grant a lease to a new DHCP client.  An analogous set
	of conditions determines when a failover server should
	initiate a DDNS update, and when it should attempt to remove
	records from the DNS. The failover protocol's conditions
	are based on the desired external behavior: avoiding duplicate
	address and prefix assignments; allowing clients to continue
	using leases which they obtained from one failover partner
	even if they can only communicate with the other partner;
	allowing the secondary DHCP server to grant new leases even
	if it is unable to communicate with the primary server.
	The desired external DDNS behavior for DHCP failover servers
	is similar to that described above for the failover protocol
	itself:</t>

	<t><list style="numbers">
	    <t>Allow timely DDNS updates from the server which
	    grants a lease to a client. Recognize that there is
	    often a DDNS update lifecycle which parallels the DHCP
	    lease lifecycle. This is likely to include the addition
	    of records when the lease is granted, and the removal
	    of DNS records when the leased resource is subsequently
	    made available for allocation to a different client.</t>

	    <t>Communicate enough information between the two
	    failover servers to allow one to complete the DDNS
	    update 'lifecycle' even if the other server originally
	    granted the lease.</t>

	    <t>Avoid redundant or overlapping DDNS updates, where
	    both failover servers are attempting to perform DDNS
	    updates for the same lease-client binding.</t>
	    
	    <t>Avoid situations where one partner is attempting to
	    add RRs related to a lease binding while the other
	    partner is attempting to remove RRs related to the same
	    lease binding.</t>
	</list></t>

	<t>While DHCP servers configured for DDNS typically perform
	these operations on both the AAAA and the PTR resource records, 
	this is not required.  It is entirely possible that a DHCP server
	could be configured to only update the DNS with PTR records, and 
	the DHCPv6 clients could be responsible for updating the DNS with
	their own AAAA records.  In this case, the discussions here would
	apply only to the PTR records.</t>

    </section>

    <section anchor="useofddns" 
       title="Exchanging DDNS Information">

	<t>In order for either server to be able to complete a DDNS
	update, or to remove DNS records which were added by its
	partner, both servers need to know the FQDN associated with
	the lease-client binding.  In addition, to properly handle
	DDNS updates, additional information is required.  All of
	the following information needs to be transmitted between
	the failover partners:</t>

	<t><list style="numbers">
	    <t>The FQDN that the client requested be associated
	    with the resource.  If the client doesn't request a
	    particular FQDN and one is synthesized by the failover
	    server or if the failover server is configured to replace
	    a client requested FQDN with a different FQDN, then
	    the server generated value would be used. </t>

	    <t>The FQDN that was actually placed in the DNS for
	    this lease. It may differ from the client requested
	    FQDN due to some form of disambiguation or other DHCP
	    server configuration (as described above).</t>
	    
	    <t>The status of and DDNS operations in progress or
	    completed.</t>

	    <t>Information sufficient to allow the failover partner
	    to remove the FQDN from the DNS should that become
	    necessary.</t>
	</list></t>

	<t>These data items are the minimum necessary set to reliably
	allow two failover partners to successfully share the
	responsibility to keep the DNS up to date with the resources
	allocated to clients.</t>

	<t>This information would typically be included in BNDUPD
	messages sent from one failover partner to the other.
	Failover servers MAY choose not to include this information
	in BNDUPD messages if there has been no change in the status
	of any DDNS update related to the lease.</t>

	<t>The partner server receiving BNDUPD messages containing
	the DDNS information SHOULD compare the status information
	and the FQDN with the current DDNS information it has
	associated with the lease binding, and update its notion
	of the DDNS status accordingly.</t>

	<t>Some implementations will instead choose to send a BNDUPD
	without waiting for the DDNS update to complete, and then
	will send a second BNDUPD once the DDNS update is complete.
	Other implementations will delay sending the partner a
	BNDUPD until the DDNS update has been acknowledged by the
	DNS server, or until some time-limit has elapsed, in order
	to avoid sending a second BNDUPD.</t>

	<t>The FQDN option contains the FQDN that will be associated
	with the AAAA RR (if the server is performing an AAAA RR update
	for the client).  The PTR RR can be generated automatically from
	the IP address or prefix value. The FQDN may be composed
	in any of several ways, depending on server configuration
	and the information provided by the client in its DHCP
	messages. The client may supply a hostname which it would
	like the server to use in forming the FQDN, or it may supply
	the entire FQDN. The server may be configured to attempt
	to use the information the client supplies, it may be
	configured with an FQDN to use for the client, or it may
	be configured to synthesize an FQDN.</t>

	<t>Since the server interacting with the client may not have completed the
	DDNS update at the time it sends the first BNDUPD about the
	lease binding, there may be cases where the FQDN in later
	BNDUPD messages does not match the FQDN included in earlier
	messages.  For example, the responsive server may be
	configured to handle situations where two or more DHCP
	client FQDNs are identical by modifying the most-specific
	label in the FQDNs of some of the clients in an attempt to
	generate unique FQDNs for them (a process sometimes called
	"disambiguation").  Alternatively, at sites which use some
	or all of the information which clients supply to form the
	FQDN, it's possible that a client's configuration may be
	changed so that it begins to supply new data.  The 
	server interacting with the client may react by removing the DNS records which it
	originally added for the client, and replacing them with
	records that refer to the client's new FQDN. In such cases,
	the server SHOULD include the actual FQDN that
	was used in subsequent DDNS options in any BNDUPD messages exchanged between
	the failover partners.  This server
	SHOULD include relevant information in its BNDUPD messages.
	This information may be necessary in order to allow the
	non-responsive partner to detect client configuration changes
	that change the hostname or FQDN data which the client
	includes in its DHCP requests.</t>

    </section>

    <section anchor="addingrr" 
       title="Adding RRs to the DNS">

	<t>A failover server which is going to perform DDNS updates
	SHOULD initiate the DDNS update when it grants a new lease
	to a client. The server which did not grant the lease SHOULD NOT
	initiate
	a DDNS update when it receives the BNDUPD after the lease
	has been granted. The failover protocol ensures that only
	one of the partners will grant a lease to any individual
	client, so it follows that this requirement will prevent
	both partners from initiating updates simultaneously. The
	server initiating the update SHOULD follow the protocol in
	<xref target="RFC4704">RFC 4704</xref>.  The server may be
	configured to perform a AAAA RR update on behalf of its
	clients, or not. Ordinarily, a failover server will not
	initiate DDNS updates when it renews leases. In two cases,
	however, a failover server MAY initiate a DDNS update when
	it renews a lease to its existing client:</t>

	<t><list style="numbers">
	    <t>When the lease was granted before the server was
	    configured to perform DDNS updates, the server MAY be
	    configured to perform updates when it next renews
	    existing leases.  The server which granted the lease
	    is the server which should initiate the DDNS update.</t>

	    <t>If a server is in PARTNER-DOWN state, it can conclude
	    that its partner is no longer attempting to perform an
	    update for the existing client. If the remaining server
	    has not recorded that an update for the binding has
	    been successfully completed, the server MAY initiate a
	    DDNS update.  It MAY initiate this update immediately
	    upon entry to PARTNER-DOWN state, it may perform this
	    in the background, or it MAY initiate this update upon
	    next hearing from the DHCP client.</t>
	</list></t>

    </section>

    <section anchor="deletingrr" 
       title="Deleting RRs from the DNS">

	<t>The failover server which makes a resource FREE* SHOULD
	initiate any DDNS deletes, if it has recorded that DNS
	records were added on behalf of the client.</t>

	<t>A server not in PARTNER-DOWN state "makes a resource
	FREE" when it initiates a BNDUPD with a binding-status of
	FREE, FREE_BACKUP, EXPIRED, or RELEASED.  Its partner
	confirms this status by acking that BNDUPD, and upon receipt
	of the BNDACK the server has "made the resource FREE".
	Conversely, a server in PARTNER-DOWN state "makes a resource
	FREE" when it sets the binding-status to FREE, since in
	PARTNER-DOWN state no communications is required with the
	partner.</t>

	<t>It is at this point that it should initiate the DDNS
	operations to delete RRs from the DDNS. Its partner SHOULD
	NOT initiate DDNS deletes for DNS records related to the
	lease binding as part of sending the BNDACK message.   The
	partner MAY have issued BNDUPD messages with a binding-status
	of FREE, EXPIRED, or RELEASED previously, but the other
	server will have rejected these BNDUPD messages.</t>

	<t>The failover protocol ensures that only one of the two
	partner servers will be able to make a resource FREE*. The
	server making the resource FREE may be doing so while it
	is in NORMAL communication with its partner, or it may be
	in PARTNER-DOWN state. If a server is in PARTNER-DOWN state,
	it may be performing DDNS deletes for RRs which its partner
	added originally. This allows a single remaining partner
	server to assume responsibility for all of the DDNS activity
	which the two servers were undertaking.</t>

	<t>Another implication of this approach is that no DDNS RR
	deletes will be performed while either server is in
	COMMUNICATIONS-INTERRUPTED state, since no resource are
	moved into the FREE* state during that period.</t>
    </section>

    <section anchor="nameassignment"
      title="Name Assignment with No Update of DNS">

	<t>In some cases, a DHCP server is configured to return a name
	to the DHCPv6 client but not enter that name into the DNS.  
	This is typically a name that it has discovered
	or generated from information it has received from the client.
	In this case this name information SHOULD be communicated to the
	failover partner, if only to ensure that they will return the same
	name in the event the partner becomes the server to which the 
	DHCPv6 client begins to interact.</t>

    </section>

  </section>

  <section anchor="reserve" title="Reservations and failover">
    <!-- issue 10 
    TODO: Describe how lease reservation works with failover. See
    Section 5.13 in <xref target="dhcpv4-failover"/>.

    Done 10/16/12 Kim
    -->

    <t>Some DHCP servers support a capability to offer specific preconfigured 
    resources to DHCP clients.  These are real DHCP
    clients, they do the entire DHCP protocol, but these servers always
    offer the client a specific pre-configured resource, and they
    offer that resource to no other clients.  Such a capability has
    several names, but it is sometimes called a "reservation", in that
    the resource is reserved for a particular DHCP client.</t>

    <t>In a situation where there are two DHCP servers serving the same prefix
    without using failover, the two DHCP server's need to have disjoint 
    resource pools, but identical reservations for the DHCP
    clients.</t>

    <t>In a failover context, both servers need to be configured
    with the proper reservations in an identical manner, but if we
    stop there problems can occur around the edge conditions where
    reservations are made for resource that has already been leased
    to a different client.  Different servers handle this conflict
    in different ways, but the goal of the failover protocol is to
    allow correct operation with any server's approach to the normal
    processing of the DHCP protocol.</t>

    <t>The general solution with regards to reservations is as follows.
    Whenever a reserved resource becomes FREE (i.e., when first configured 
    or whenever a client frees it or it expires or is reset), the
    primary server MUST show that resource as FREE (and thus available
    for its own allocation) and it MUST send it to the secondary server
    in a BNDUPD with a flag set showing that it is reserved and with a
    status of FREE_BACKUP.</t>

    <t>Note that this implies that a reserved resource goes through
    the normal state changes from FREE to ACTIVE (and possibly back
    to FREE).  The failover protocol supports this approach to
    reservations, i.e., where the resource undergoes the normal
    state changes of any resource, but it can only be offered to
    the client for which it is reserved.</t>

    <t>From the above, it follows that a reservation solely on the
    secondary will not necessarily allow the secondary to offer
    that address to client to whom it is reserved.  The reservation
    must also appear on the primary as well for the secondary to
    be able to offer the resource to the client to which it is
    reserved.</t>

    <t>When the reservation on a resource is cancelled, if the resource 
    is currently FREE and the server is the primary, or FREE_BACKUP and the
    server is the secondary, the server MUST send a BNDUPD to the other
    server with the binding-status FREE and an indication that the
    resource is no longer reserved.</t>

    <!-- 
    TODO: Should we try to pin down the form of "indication that
    the resource is (or is not) reserved"?
    -->

  </section>

  <!-- tomek: this is definitely material for protocol draft, not the design
  draft -->
  <!--
  <section anchor="protocol-skeleton" title="Protocol entities">
    <t>Discussion: It is unclear if following sections belong to
    design or protocol draft. It is currently kept here as a
    scratchbook with list of things that will have to be defined
    eventually. Whether or not it will stay in this document or will be moved to
    the protocol spec document is TBD.</t>

    <section anchor="options" title="Failover Protocol">
      <t>This section enumerates list of options that will be defined in
      failover protocol specification. Rough description of purpose and
      content for each option is specified. Exact on wire format will be
      defined in protocol specification.</t>
      <t><list style="numbers">
        <t>OPTION_FO_TIMESTAMP - convey information about timestamp. It
        is used by time skew measurement algorithm (see <xref
        target="time-skew"/>).</t>
      </list></t>
    </section>

    <section anchor="defines" title="Protocol constants">
      <t>This section enumerates various constants that have to be defined
      in actual protocol specification.</t>
      <t><list style="numbers">
        <t>TIME_SKEW_PKTS_AVG - number of packets that are used to calculate
        average time skew between partners. See (see <xref
        target="time-skew"/>).</t>
      </list></t>
    </section>

  </section> -->

  <section title="Security Considerations">
    <t>DHCPv6 failover is an extension of a standard DHCPv6 protocol, so all
    security considerations from <xref target="RFC3315" />, Section 23 and
    <xref target="RFC3633" />, Section 15 related to the server apply.</t>

    <t>As traffic exchange between clients and server is not encrypted,
    an attacker that penetrated the network and is able to intercept traffic,
    will not gain any additional information by also sniffing communication
    between partners.</t>

    <t>An attacker that is able to impersonate one partner can efficiently
    perform a denial of service attack on the remaining uncompromised server.
    Several techniques may be used: pretending that conflict resolution
    is required, requesting rebalance, claiming that a valid lease was released
    or declined etc. For that reason the communication between servers
    SHOULD support failover connections over TLS, as explained in 
    <xref target="create-connections" />. Such secure connections SHOULD
    be optional and configurable by the administrator.</t>

    <t>A server MUST NOT operate in PARTNER-DOWN if its partner is up.
    Network administrators are expected to switch the remaining active server
    to PARTNER-DOWN state only if they is sure that its partner server
    is indeed down. Failing to obey this requirement will result in both
    servers likely assigning duplicate leases to different clients. Implementers
    should take that into consideration if they decide to implement
    the auto-partner-down timer-based transition to PARTNER-DOWN state.</t>

    <t>Running a network protected by DHCPv6 failover requires more resources
    than running without it. In particular some of the resources are
    allocated to the secondary server and they are not usable in a normal
    (i.e. non failures) operation immediately, though over time they will
    be rebalanced and end up on the server that needs them. While limiting 
    this pool may be preferable from resource utilization perspective, 
    it must be a reasonably large pool, so the secondary may take over once 
    the primary becomes unavailable.</t>

  </section>

  <section title="IANA Considerations">

   <t>
   IANA is requested to assign values for the following new DHCPv6
   Message types in the registry maintained in 
   http://www.iana.org/assignments/dhcpv6-parameters:
   </t>

    <t>
    <list style="symbols">
      <t>BNDUPD (TBD1)</t>

      <t>BNDACK (TBD2)</t> 
      
      <t>POOLREQ (TBD3)</t>

      <t>POOLRESP (TBD4)</t> 

      <t>UPDREQ (TBD5)</t> 

      <t>UPDREQALL (TBD6)</t> 

      <t>UPDDONE (TBD7)</t> 

      <t>CONNECT (TBD8)</t> 

      <t>CONNECTACK (TBD9)</t> 
      
      <t>DISCONNECT (TBD10)</t> 
      
      <t>STATE (TBD11)</t> 

      <t>CONTACT (TBD12)</t> 
    </list>
    </t>


  </section>

  <section title="Acknowledgements">
    <t>This document extensively uses concepts, definitions and other
    parts of <xref target="dhcpv4-failover"/> document.  Authors would
    like to thank Shawn Routher, Greg Rabil, Bernie Volz and Marcin Siodelski
    for their significant involvement and contributions. Authors would like to
    thank VithalPrasad Gaitonde, Krzysztof Gierlowski, Krzysztof Nowicki and
    Michal Hoeft for their insightful comments.</t>

    <t>This work has been partially supported by Department of
    Computer Communications (a division of Gdansk University of
    Technology) and the Polish Ministry of Science and Higher
    Education under the European Regional Development Fund, Grant
    No. POIG.01.01.02-00-045/09-00 (Future Internet Engineering
    Project).</t>
  </section>

</middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.2136'?>
      <?rfc include='reference.RFC.3315'?>
      <?rfc include='reference.RFC.3633'?>
      <?rfc include='reference.RFC.4703'?>
      <?rfc include='reference.RFC.4704'?>
      <?rfc include='reference.RFC.5007'?>
      <?rfc include='reference.RFC.5460'?>
      <?rfc include='reference.RFC.7031'?>
    </references>
    <references title="Informative References">
      <?rfc include='reference.I-D.ietf-dhc-dhcpv6-failover-requirements'?>
      <?rfc include='reference.I-D.ietf-dhc-dhcpv6-failover-design.xml'?>
      <?rfc include='reference.I-D.ietf-dhc-dhcpv6-load-balancing.xml'?>
      <reference anchor="dhcpv4-failover">
        <front>
          <title>DHCP Failover Protocol</title> <author fullname="Ralph
          Droms" initials="R." surname="Droms">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Kim Kinnear" initials="K."
          surname="Kinnear">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Mark Stapp" initials="M."
          surname="Stapp">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Bernie Volz" initials="B."
          surname="Volz">
            <organization>Ericsson</organization>
          </author> <author fullname="Steve Gonczi" initials="S."
          surname="Gonczi">
            <organization>Relicore</organization>
          </author> <author fullname="Greg Rabil" initials="G."
          surname="Rabil">
            <organization>Lucent Technologies</organization>
          </author> <author fullname="Michael Dooley" initials="M."
          surname="Dooley">
            <organization>Diamond IP Technologies</organization>
          </author> <author fullname="Arun Kapur" initials="A."
          surname="Kapur">
            <organization>K5 Networks</organization>
          </author> <date month="March" year='2003'/>
        </front> <seriesInfo name="Internet-Draft"
        value="draft-ietf-dhc-failover-12"/>
      </reference> 

    </references>
  </back>
</rfc>
