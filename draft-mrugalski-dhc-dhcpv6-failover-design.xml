<?xml version='1.0' ?>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>

<?rfc compact="yes"?> <?rfc subcompact="no"?>

<?rfc symrefs="yes"?>

<!DOCTYPE rfc SYSTEM 'rfc2629bis.dtd' [
]>
<rfc ipr="trust200902" category="std"
     docName="draft-mrugalski-dhc-dhcpv6-failover-design-00">
  <front>
    <title abbrev="DHCPv6 Failover Design">DHCPv6 Failover Design</title>

    <author fullname="Tomasz Mrugalski" initials="T." surname="Mrugalski">
      <organization abbrev="ISC">Internet Systems Consortium, Inc.
      </organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <phone>+1 650 423 1345</phone>
        <email>tomasz.mrugalski@gmail.com</email>
      </address>
    </author>
    <author fullname="Kim Kinnear" initials="K." surname="Kinnear">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1414 Massachusetts Ave.</street>
          <city>Boxborough</city>
          <region>Massachusetts</region>
          <code>01719</code>
          <country>USA</country>
        </postal>
        <phone>+1 (978) 936-0000</phone>
        <email>kkinnear@cisco.com</email>
      </address>
    </author>

    <date day="5" month="March" year="2012"/>

    <area>Internet</area>
    <workgroup>Dynamic Host Configuration (DHC)</workgroup>
    <keyword>DHCPv6</keyword>
    <keyword>Failover</keyword>

    <abstract>
      <t>DHCPv6 defined in <xref target="RFC3315"/> does not offer
      server redundancy. This document defines a design for DHCPv6
      failover, a mechanism for running two servers on the same
      network with capability for either server to take over clients' 
      leases in case of server failure or network partition. 
      This is a DHCPv6 Failover design document, it is not protocol 
      specification document. It is a second document in a 
      planned series of three documents. DHCPv6 failover requirements 
      are specified in <xref target="requirements"/>. 
      A protocol specification document is planned to follow this document.</t>
    </abstract>
  </front>

  <middle>
    <section title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Glossary">
      <t>This is a supplemental glossary that combined with
      definitions in Section 3 <xref target="requirements"/>.

      <list style="symbols">

	<t>Failover endpoint - The failover protocol allows for
	there to be a unique failover 'endpoint' per partner per
	role per relationship (where role is primary or secondary
	and the relationship is defined by the relationship-name).
	This failover endpoint can take actions and hold unique
	states.  Typically, there is a one failover endpoint per
	partner (server), although there may be more.  'Server' and
	'failover endpoint' are synonymous only if the server
	participates in only one failover relationship. However,
	for the sake of simplicity 'Server' is used throughout the
	document to refer to a failover endpoint unless to do so
	would be confusing.</t>
	
        <t>Failover transmission - all messages exchanged between
        partners.</t>

	<t>Independent Allocation - a prefix allocation algorithm
	to split the available pool of resources between the primary
	and secondary servers that is particularly well suited for
	vast pools (i.e. when available resources are not expected
	to deplete). See <xref target="alloc-separated"/> for
	details.</t>

        <t>Primary Server</t>

	<t>Proportional Allocation - a prefix allocation algorithm
	to split the available free leases between the primary and
	secondary servers that is particularly well suited for more
	limited resources.  See <xref target="alloc-classic"/> for
	details.</t>

        <t>Resource - an IPv6 address or a IPv6
        prefix.</t>

        <t>Secondary Server</t>

	<t>Server - A DHCPv6 server that implements DHCPv6 failover.
	'Server' and 'failover endpoint' as synonymous only if
	server participates in only one failover relationship. </t>


      </list>
      </t>
    </section>

    <section title="Goals">
      <t>The failover protocol design provides a means for cooperating
      DHCPv6 servers to work together to provide a DHCPv6 service
      with availability that is increased beyond that which could
      be provided by a single DHCPv6 server operating alone.  It
      is designed to protect DHCPv6 clients against server unreachability,
      including server failure and network partition. It is possible
      to deploy exactly two servers that are able to continue
      providing a lease on an IPv6 address or on an IPv6 prefix
      without the DHCPv6 client experiencing lease expiration or a
      reassignment of a lease to a different IPv6 address in the event
      of failure by one or the other of the two servers.</t>

      <t>This protocol defines active-passive mode, sometimes also
      called hot standby model. This means that during normal
      operation one server is active (i.e. actively responds to
      clients' requests) while the second is passive (i.e. it does
      receive clients' requests, but does not respond to them and only
      maintains a copy of lease database and is ready to take over
      incoming queries in case of primary server
      failure). Active-active mode (i.e. both servers actively
      handling clients' requests) is currently not supported for the
      sake of simplicity. Such mode may be defined as an exension at a
      later time.</t>

      <t>The failover protocol is designed to provide lease stability for
      leases with lease times beyond a short period.
      Due to the additional overhead required, failover is not
      suitable for leases shorter than 30 seconds. The DHCPv6 Failover
      protocol MUST NOT be used for leases shorter than 30 seconds.</t>

      <cref source="tomek">Otherwise we would spawn a nice packet storm
      between partners. Even though 30 seconds it reasonable minimum, we
      may also add something about recommendations. Something like: Lease
      lifetime of at least 30 minutes SHOULD be used if possible.</cref>

      <t>This design attempts to fulfill all DHCPv6 failover requirements
      defined in <xref target="requirements"/>.</t>

      <section title="Additional Requirements">
        <t>The following requirements are not related to failover
        mechanism in general, but rather to this particular design.

        <list style="numbers">
          <t>Minimize Asymmetry - while there are two distinct roles
          in failover (primary and secondary server), the 
          differences between those two roles should be as small as
          possible.   This will yield a simpler design as well as
	  a simpler implementation of that design.</t>
        </list>
        </t>
      </section>

    </section>

<section title="Protocol Overview">

  <t>The DHCPv6 Failover Protocol is defined as a communication
  between failover partners with all associated algorithms and
  mechanisms.  Failover communication is conducted over a TCP
  connection established between the partners. The protocol reuses
  the framing format specified in Section 5.1 of <xref
  target="RFC5460">DHCPv6 Bulk Leasequery</xref>, but uses different
  message types. Additional failover-specific message types will
  be defined. All information is sent over the connection as typical
  DHCPv6 Options, following format defined in Section 22.1 of <xref
  target="RFC3315"/>.</t>

  <t>After initialization, the primary server establishes a TCP connection
  with its partner. The primary server sends a CONNECT message with initial
  parameters. Secondary server responds with CONNECTACK.</t>

  <t>Depending on the failover state of each partner, they MUST
  initiate one of the binding update procedures. Each server MAY
  send an UPDREQ message to request its partner to send all updates
  that have not been sent yet (this case applies when partner has
  an existing database and wants to update it). Alternatively, a
  server MAY choose to send an UPDREQALL message to request a full
  lease database transmission including all leases (this case applies
  in case of booting up new server after installation, corruption
  or complete loss of database, or other catastrophic failure).</t>

  <t>Servers exchange lease information by using BNDUPD messages.
  Depending on local and remote state of a lease, a server may
  either accept or reject the update. Reception of lease update
  information is confirmed by responding with BNDACK message with
  appropriate status. The majority of the messages sent over a
  failover TCP connection consists of BNDUPD and BNDACK messages.</t>

  <t>A subset of available resources (addresses or prefixes) is
  reserved for secondary server use. This is required for handling
  a case where both servers are able to communicate with clients,
  but unable to communicate with each other. After initial connection
  is established, the secondary server requests a pool of available
  addresses by sending a POOLREQ message. The primary server assigns
  a pool to the secondary by transmitting a POOLRESP message and
  then sending a series of BNDUPD messages. The secondary server
  may initiate such pool request at any time when maintaining
  communication with primary server.</t>

  <t>Failover servers use a lazy update mechanism to update their
  failover partner about changes to their lease state database.
  After a server performs any modifications to its lease state
  database (assign a new lease, extend an existing one, release or
  expire a lease), it sends its response to the client's request
  first (performing the "regular" DHCPv6 operation) and then informs
  its failover partner using a BNDUPD message.  This BNDUPD message
  SHOULD be sent soon after the response is sent to the DHCPv6
  client, but there is no specific requirement of a minimum time
  in which to do so.</t>

  <t>The major problem with lazy update mechanism is the case when
  the server crashes after sending response to client, but before
  sending the lazy update to its partner (or when communication
  between partners is interrupted). To solve this problem, concept
  known as the Maximum Client Lead Time (MCLT) (initially designed
  for DHCPv4 failover) is used.  The MCLT is the maximum amount of
  time that one server can extend a lease for a client's binding
  beyond the time known by its failover partner. See <xref
  target="mclt"/> for detailed desciption how MCLT affects assigned
  lease times.</t>

  <t>Servers verify each others availability by periodically
  exchanging CONTACT messages. See <xref target="reachability"/> for
  discussion about detecting partner's unreachability.</t>

  <t>A server that is being shut down transmits a DISCONNECT message, closes
  the connection with its failover partner and stops operation. A Server SHOULD transmit
  any pending lease updates before transmitting DISCONNECT message.</t>

  <section anchor="normal-overview" title="NORMAL State Overview">
    <t>During normal operation when two partners are communicating,
    both remain in NORMAL state. All incoming requests are processed
    by the primary server and the secondary server receives appropriate
    updates.  While operating in NORMAL state server a must switch
    to COMMUNICATIONS-INTERRUPTED if communication with its partner
    is severed. If its partner closes connection using DISCONNECT
    message, server moves immediately to either COMMUNICATIONS-INTERRUPTED
    state or to PARTNER-DOWN state, as configured by the operator.</t>
  </section>

  <!-- COMMUNICATION interrupted -->
  <section anchor="comm-inter-overview" title="COMMUNICATION-INTERRUPTED State Overview">
    <t>When a server discovers that its partner is not reachable,
    it switches into COMMUNICATIONS-INTERRUPTED state. In that state
    a server MUST NOT extend any lease time more than the MCLT
    beyond the lease time known by its failover partner.  A server
    will extend leases that it previously assigned using the regular
    RENEW mechanism as clients will send their communications to
    this server (using a multicasted RENEW message with server's
    DUID or using unicasted RENEW message if configured). A server
    MUST also extend leases assigned by its partner. This is
    accomplished by replying to clients' REBIND messages. Again, a
    server MUST NOT extend a lease by more than configured MCLT
    value beyond the time known by its partner.  While in
    COMMUNICATIONS-INTERRUPTED state, each server MUST assign new
    leases only from its own pool.  If a server is operating in
    COMMUNICATION-INTERRUPTED state and establishes connection with
    its partner (either by successfully completing periodic connection
    attempt or receiving an incoming connection from its partner),
    the server moves either into RECOVERING state or NORMAL state,
    depending on the state that its failover partner server is in.
    When a server moves into NORMAL state, it automatically sends
    all updated lease information to its failover partner.  A server
    may be also administratively switched to PARTNER-DOWN state
    from COMMUNICATIONS-INTERRUPTED state.</t>
  </section>

  <!-- PARTNER-DOWN -->
  <section anchor="partner-down-overview" title="PARTNER-DOWN State Overview">
    <t>While in PARTNER-DOWN state, server has a guarantee that its
    partner is not serving any leases. In such a case, it MUST extend
    existing leases that it knows about and may assign new leases
    from its own pool or the pool assigned to its partner. Since
    it knows that its partner is not extending any leases and does
    not assign new leases, it may extend leases by times longer
    than MCLT. It MUST NOT reallocate any existing IP address to a
    new client until that lease has expired and the server has
    waited the MCLT beyond the lease's expiration. This mode of
    operation is similar to the operation of a stand-alone DHCPv6
    server and it does not offer any redundancy. In this state
    server SHOULD periodically attempt to connect to its failover
    partner. Once connection with its partner is established, the
    partner will swith to RECOVERING state.  After the partner
    finishes its recovery and moves to RECOVER-DONE state, both
    servers will move to NORMAL state.</t>
  </section>

  <!-- RECOVERING -->
  <section anchor="recovering-overview" title="RECOVERING State Overview">
    <t>This transitional state represents a state, where two servers
    established connection, but one server needs to be updated with
    information prior to resuming normal operation.  Upon entering
    the state, both servers transmit UPDREQ or UPDREQALL (depending
    on state of its local lease database). Once all lease information
    is exchanges, the recovering server moves to RECOVER-DONE state
    and then both servers switch to NORMAL state. While in RECOVER
    state, a server is not allowed to respond to clients.</t>
  </section>
</section>


<section title="Connection Management">
  <section title="Creating Connections">
    <t>Every server implementing the failover protocol SHOULD attempt to
    connect to all of its partners periodically, where the period is
    implementation dependent and SHOULD be configurable.  In the event
    that a connection has been rejected by a CONNECTACK message with a
    reject-reason option contained in it or a DISCONNECT message, a
    server SHOULD reduce the frequency with which it attempts to connect
    to that server but it SHOULD continue to attempt to connect
    periodically.</t>

    <t>When a connection attempt succeeds, if the server generating the
    connection attempt is a primary server for that relationship, then
    it MUST send a CONNECT message down the connection.  If it is not
    a primary server for the relationship, then it MUST just drop the
    connection and wait for the primary server to connect to it.</t>

    <t>When a connection attempt is received, the only information that
    the receiving server has is the IP address of the partner initiating
    a connection.  It also knows whether it has the primary role for
    any failover relationships with the connecting server.  If it has
    any relationships for which it is a primary server, it should
    initiate a connection of its own to the partner server, one for
    each primary relationship it has with that server.</t>

    <t>If it has any relationships with the connecting server for which
    it is a seconary server, it should just await the CONNECT message
    to determine which relationship this connection is to serve.</t>

    <t>If it has no secondary relationships with the connecting server, it
    SHOULD drop the connection.</t>

    <t>To summarize -- a primary server MUST use a connection that it has
    initiated in order to send a CONNECT message.  Every server that
    is a secondary server in a relationship attempts to create a
    connection to the server which is primary in the relationship, but
    that connection is only used to stimulate the primary server into
    recognizing that the secondary server is ready for operation.  The
    reason behind this is that the secondary server has no way to
    communicate to the primary server which relationship a connection
    is designed to serve.</t>

    <t>A server which has multiple secondary relationships with a primary
    server SHOULD only send one stimulus connection attempt to the
    primary server.</t>

    <t>Once a connection is established, the primary server MUST send
    a CONNECT message across the connection.  A secondary server MUST
    wait for the CONNECT message from a primary server.  If the
    secondary server doesn't receive a CONNECT message from the
    primary server in an installation dependent amount of time, it MAY
    drop the connection and send another stimulus connection attempt
    to the primary server.</t>

    <t>Every CONNECT message includes a TLS-request option, and if the
    CONNECTACK message does not reject the CONNECT message and the
    TLS-reply option says TLS MUST be used, then the servers will
    immediately enter into TLS negotiation.</t>

    <t>Once TLS negotiation is complete, the primary server MUST
    resend the CONNECT message on the newly secured TLS connection and
    then wait for the CONNECTACK message in response.  The TLS-request
    and TLS-reply options MUST NOT appear in either this second
    CONNECT or its associated CONNECTACK message as they had in the
    first messages.</t>

    <t>The second message sent over a new connection (either a bare
    TCP connection or a connection utilizing TLS) is a STATE message.
    Upon the receipt of this message, the receiver can consider
    communications up.</t>

    <t>A secondary server MUST NOT respond to the closing of a TCP
    connection with a blind attempt to reconnect -- there may be
    another TCP connection to the same failover partner already in
    use.</t>

  </section>

  <section title="Endpoint Identification">
    <t>The proper operation of the failover protocol requires more than
    the transmission of messages between one server and the other.  Each
    endpoint might seem to be a single DHCPv6 server, but in fact there
    are situations where additional flexibility in configuration
    is useful.  A failover endpoint is always associated with a set
    of DHCPv6 prefixes that are configured on the DHCPv6 server where
    the endpoint appears.  A DHCPv6 prefix MUST NOT be associated with
    more than one failover endpoint.</t>

    <t>The failover protocol SHOULD be configured with one failover
    relationship between each pair of failover servers. In this
    case there is one failover endpoint for that relationship on
    each failover partner.  This failover relationship MUST have a
    unique name.</t>

    <t>There is typically little need for addtional relationships between
    any two servers but there MAY be more than one failover relationship
    between two servers -- however each MUST have a unique relationship
    name.</t>

    <t>Any failover endpoint can take actions and hold unique states.</t>

    <t>This document frequently describes the behavior of the protocol in
    terms of primary and secondary servers, not primary and secondary
    failover endpoints.  However, it is important to remember that every
    'server' described in this document is in reality a failover endpoint
    that resides in a particular process, and that several failover
    end-points may reside in the same server process.</t>

    <t>It is not the case that there is a unique failover endpoint for
    each prefix that participates in a failover relationship.  On one
    server, there is (typically) one failover endpoint per partner,
    regardless of how many prefixes are managed by that combination of
    partner and role.  Conversely, on a particular server, any given
    prefix will be associated with exactly one failover endpoint.</t>

    <t>When a connection is received from the partner, the unique failover
    endpoint to which the message is directed is determined solely by
    the IP address of the partner, the relationship-name, and the role
    of the receiving server.</t>

  </section>
</section>

<section title="Resource Allocation">
  <t>Currently there are two allocation algorithms defined for
  resources (addresses or prefixes). Additional allocation schemes
  may be defined as future extensions.</t>

  <list style="numbers">
    <t>Proportional Allocation - This allocation algorithm is a
    direct application of algorithm defined in <xref target="dhcpv4-failover"/> 
    to DHCPv6. Available resources are
    split between primary and secondary server. Released resources
    are always returned to primary server.  Primary and secondary
    servers may initiate a rebalancing procedure, when disparity
    between resources available to each server reaches a preconfigured
    threshold. Only resources that are not leased to any clients
    are "owned" by one of the servers. This algorithm is particularly
    well suited for scenarios where amount of available resources
    is limited, as may be the case for prefix delegation. See <xref
    target="alloc-classic"/> for details.</t>

    <t>Independent Allocation - This allocation algorithm assumes
    that available resources are split between primary and secondary
    servers as well.  In this case, however, resources are assigned
    to a specific server for all time, regardless if they are
    available or currently used. This algorithm is much simpler
    than proportional allocation, because resource imbalance doesn't
    have to be checked and there is no rebalancing for independent
    allocation. This algorithm is particularly well suited for
    scenarios where the there is an abundance of available resources
    which is typically the case for DHCPv6 address
    allocation.  See <xref target="alloc-separated"/> for details.</t>
  </list>

  <section anchor="alloc-classic" title="Proportional Allocation">

    <t>In this allocation scheme, each server has its own pool of
    available resources.  Note that a resource is not "owned" by a
    particular server throughout its entire lifetime.  Only a resource
    which is available is "owned" by a particular server -- once it
    has been leased to a client, it is not owned by either failover
    partner.  When it finally becomes available again, it will be
    owned initially by the primary server, and it may or may not be
    allocated to the secondary server by the primary server.</t>

    <t>So, the flow of a resource is as follows: initially a resource
    is owned by the primary server.  It may be allocated to the
    secondary server if it is available, and then it is owned by the
    secondary server.  Either server can allocate available resources
    which they own to clients, in which case they cease
    to own them.  When the client releases the resource or the
    lease on it expires, it will again become available and will be
    owned by the primary.</t>

    <t>A resource will not become owned by the server which allocated
    it initially when it is released or the lease expires because, in
    general, that server will have had to replenish its pool of
    available resources well in advance of any likely lease
    expirations.  Thus, having a particular resource cycle back to the
    secondary might well put the secondary more out of balance with
    respect to the primary instead of enhancing the balance of
    available addresses or prefixes between them.</t>

    <t>TODO: Need to rework this v4-specific vocabulary to v6, once we
    decide how things will look like in v6.</t>

    <t>When they are used, these proportional pools are used for
    allocation when in every state but PARTNER-DOWN state.  In
    PARTNER-DOWN state a failover server can allocate from either
    pool.  This allocation and maintenance of these address pools
    is an area of some sensitivity, since the goal is to maintain
    a more or less constant ratio of available addresses between
    the two servers.</t>

    <t>TODO: Reuse rest of the description from section 5.4 from <xref
    target="dhcpv4-failover"/> here.</t>

  </section>

  <section anchor="alloc-separated" title="Independent Allocation">
    <t>In this allocation scheme, available resources are split
    between servers. Available resources are split between the primary and
    secondary servers as part of initial connection establishment. Once
    resources are allocated to each server, there is no need to
    reassign them.  This algorithm is simpler than proportional
    allocation since it requires no less initial communicagtion and does not
    require a rebalancing mechanism, but it assumes
    that the pool assigned to each server will never deplete. That is
    often a reasonable assumption for IPv6 addresses (e.g. servers are
    often assigned a /64 pool that contains many more addresses than existing
    electronic devices on Earth). This allocation mechanism SHOULD be
    used for IPv6 addresses, unless configured address pool is small
    or is otherwise administratively limited.</t>

    <t>Once each server is assigned a resource pool during initial
    connection establishment, it may allocate assigned resources to
    clients. Once a client release a resource or its lease is expired,
    the returned resource returns to pool for the same server. Resources
    never changes servers.</t>

    <t>During COMMUNICATION-INTERRUPTED events, a partner MAY continue
    extending existing leases when requested by clients. A healthy
    partner MUST NOT lease resources that were assigned to its downed
    partner and later released by a client unless it is in PARTNER-DOWN state.
    </t>
  </section>

  <section title="Determining Allocation Approach">

    <section title="IPv6 Addresses">
    </section>

    <section title="IPv6 Prefixes">
    </section>
  </section> <!-- determining allocation approach -->
</section> <!-- address allocation -->

  <section title="Failover Mechanisms">
    <t>This section lays out an overview of the communication between
    partners and other mechanisms required for failover operation. As
    this is a design document, not a protocol specification, 
    high level ideas are presented without implementation
    specific details (e.g. lack of on-wire formats). Implementation details
    will be specified in a separate draft.</t>
    <section anchor="time-skew" title="Time Skew">
      <t>Partners exchange information about known lease states. To
      reliably compare a known lease state with an update received from a
      partner, servers must be able to reliably compare the times stored
      in the known lease state with the times received in the update.
      Although a simple approach would be to require both partners to use
      synchronized time, e.g. by using NTP, such a service may become
      unavailable in some scenarios that failover expects to cover, e.g.
      network partition. Therefore a mechanism to measure and track
      relative time differences between servers is necessary. To do so,
      each message MUST contain FO_TIMESTAMP option that contains the
      timestamp of the transmission in the time context of the transmitter.
      The transmitting server MUST set this as close to the
      actual transmission as possible. The receiving partner MUST store its
      own timestamp of reception event as close to the actual reception as
      possible. The received timestamp information is then compared with local timestamp.</t>

      <t>To account for packet delay variation (jitter), the measured
      difference is not used directly, but rather the moving average of last
      TIME_SKEW_PKTS_AVG packets time difference is calculated. This averaged
      value is referred to as the time skew. Note that the time skew algorithm
      allows cooperation between clients with completely desynchronized
      clocks as well as those whose desynchronization itself is not constant.</t>
    </section>
    <section title="Time expression">
      <t>Timestamps are expressed as number of seconds since midnight
      (UTC), January 1, 2000, modulo 2^32. Note: that is the same
      approach as used in creation of DUID-LLT (see Section 9.2 of <xref
      target="RFC3315"/>).</t>
      <t>Time differences are expressed in seconds and are signed.</t>
    </section>

    <section anchor="lazy-updates" title="Lazy updates">
      <t>Lazy update refers to the requirement placed on a server
      implementing a failover protocol to update its failover partner
      whenever the binding database changes.  A failover protocol
      which didn't support lazy update would require the failover
      partner update to complete before a DHCPv6 server could respond
      to a DHCPv6 client request. The lazy update mechanism allows a server
      to allocate a new or extend an existing lease and then update its
      failover partner as time permits.</t>
      <t>Although the lazy update mechanism does not introduce additional
      delays in server response times, it introduces other
      difficulties.  The key problem with lazy update is that when a
      server fails after updating a client with a particular lease
      time and before updating its partner, the partner will believe
      that a lease has expired even though the client still retains a
      valid lease on that address or prefix.</t>
    </section>

    <section anchor="mclt" title="MCLT concept">
      <t>In order to handle problem introduced by lazy updates (see
      <xref target="lazy-updates"/>), a period of time known as the
      "Maximum Client Lead Time" (MCLT) is defined and must be known
      to both the primary and secondary servers.  Proper use of this
      time interval places an upper bound on the difference allowed
      between the lease time provided to a DHCPv6 client by a server and
      the lease time known by that server's failover partner.</t>

      <t>The MCLT is typically much less than the lease time that a
      server has been configured to offer a client, and so some
      strategy must exist to allow a server to offer the configured
      lease time to a client.  During a lazy update the updating
      server typically updates its partner with a potential expiration
      time which is longer than the lease time previously given to the
      client and which is longer than the lease time that the server
      has been configured to give a client.  This allows that server
      to give a longer lease time to the client the next time the
      client renews its lease, since the time that it will give to the
      client will not exceed the MCLT beyond the potential expiration
      time acknowledged by its partner.</t>

      <t>The fundamental relationship on which much of The correctness
      of this protocol depends is that the lease expiration time
      known to a DHCPv6 client MUST NOT under any circumstances be
      more than the maximum client lead time (MCLT) greater than the
      potential expiration time known to a server's partner.</t>

      <t>The remainder of this section makes the above fundamental
      relationship more explicit.</t>

      <t>This protocol requires a DHCPv6 server to deal with several
      different lease intervals and places specific restrictions on
      their relationships. The purpose of these restrictions is to
      allow the other server in the pair to be able to make certain
      assumptions in the absence of an ability to communicate between
      servers.</t>

      <t>The different times are:
      <list style="hanging">
        <t hangText="desired valid lifetime:">
          <vspace/>
          The desired valid lifetime is the lease interval that a DHCPv6
          server would like to give to a DHCPv6 client in the absence of
          any restrictions imposed by the failover protocol.  Its
          determination is outside of the scope of this
          protocol. Typically this is the result of external
          configuration of a DHCPv6 server.
        </t>
        <t hangText="actual valid lifetime:">
          <vspace/>
          The actual valid lifetime is the lease interval that a DHCPv6 server
          gives out to a DHCPv6 client.
          It may be shorter than the desired valid lifetime (as explained below).
        </t>
        <t hangText="potential valid lifetime:">
          <vspace/>
          The potential valid lifetime is the potential lease expiration interval the
          local server tells to its partner in a BNDUPD message.
        </t>
        <t hangText="acknowledged potential valid lifetime:">
          <vspace/>
          The acknowledged potential valid lifetime is the potential lease
          interval the partner server has most recently acknowledged in 
          a BNDACK message.
        </t>
      </list>
      </t>

   <section title="MCLT example">
     <t>The following example demonstrates the MCLT concept in practice. The
     values used are arbitrarily chosen are and not a recommendation for
     actual values. The MCLT in this case is 1 hour.  The desired valid
     lifetime is 3 days, and its renewal time is half the valid lifetime.</t>

     <t>When a server makes an offer for a new lease on an IP address to a
     DHCPv6 client, it determines the desired valid lifetime (in this
     case, 3 days).  It then examines the acknowledged potential valid 
     lifetime (which in this case is zero) and determines the remainder
     of the time left to run, which is also zero.  To this it adds the
     MCLT.  Since the actual valid lifetime cannot be allowed to exceed
     the remainder of the current acknowledged potential valid lifetime 
     plus the MCLT, the offer made to the client is for the remainder
     of the current acknowledged potential valid lifetime (i.e., zero)
     plus the MCLT.  Thus, the actual valid lifetime is 1 hour.</t>

     <t>Once the server has sent the REPLY to the DHCPv6 client, it
     will update its failover partner with the lease information. 
     However, the desired potential valid lifetime will be composed of one
     half of the current actual valid lifetime added to the desired
     valid lifetime. Thus, the failover partner is updated with a
     BNDUPD with a potential valid lifetime of 3 days + 1/2 hour.</t>

     <t>When the primary server receives a BNDACK to its update of the
     secondary server's (partner's) potential valid lifetime, it records
     that as the acknowledged potential valid lifetime.  A server MUST
     NOT send a BNDACK in response to a BNDUPD message until it is sure
     that the information in the BNDUPD message has been updated in its
     lease database.  Thus, the primary server in this case can be sure
     that the secondary server has recorded the potential lease
     interval in its stable storage when the primary server receives a
     BNDACK message from the secondary server.</t>

     <t>When the DHCPv6 client attempts to renew at T1 (approximately one
     half an hour from the start of the lease), the primary server
     again determines the desired valid lifetime, which is still 3
     days.  It then compares this with the remaining acknowledged
     potential valid lifetime (3 days + 1/2 hour) and adjusts for the
     time passed since the secondary was last updated (1/2 hour).  Thus
     the time remaining of the acknowledged potential valid interval is
     3 days.  Adding the MCLT to this yields 3 days plus 1 hour, which
     is more than the desired valid lifetime of 3 days.  So the client
     is renewed for the desired valid lifetime -- 3 days.</t>

     <t>When the primary DHCPv6 server updates the secondary DHCPv6 server
     after the DHCPv6 client's renewal REPLY is complete, it will calculate
     the desired potential valid lifetime as the T1 fraction of the
     actual client valid lifetime (1/2 of 3 days this time = 1.5 days).
     To this it will add the desired client valid lifetime of 3 days,
     yielding a total desired potential valid lifetime of 4.5
     days.  In this way, the primary attempts to have the secondary
     always "lead" the client in its understanding of the client's
     valid lifetime so as to be able to always offer the client the
     desired client valid lifetime.</t>

     <t>Once the initial actual client valid lifetime of the MCLT is past,
     the protocol operates effectively like the DHCPv6 protocol does
     today in its behavior concerning valid lifetimes. However, the
     guarantee that the actual client valid lifetime will never exceed
     the remaining acknowledged partner server potential valid lifetime by more
     than the MCLT allows full recovery from a variety of failures.</t>
   </section>

 </section>

 <section anchor="reachability" title="Unreachability detection">
   <t>Each partner maintains an FO_SEND timer for each partner
   connection. The FO_SEND timer is reset every time any message is
   transmitted.  If the timer reaches the FO_SEND_MAX value, a CONTACT
   message is transmitted and timer is reset. The CONTACT message may be
   transmitted at any time.</t>

   <t>Discussion: Perhaps it would be more reasonable to use
   echo-reply approach, rather than periodic transmissions?</t>
 </section>

    <section title="Sending Data">
      <t>Each server updates its failover partner about recent changes in lease states.
      Each update must include following information:
      <list style="numbers">
        <t>resource type - non-temporary address or a prefix</t>
        <t>resource information - actual address or prefix</t>
        <t>valid life time requested by client</t>
        <t>IAID - Identity Association used by client, while obtaining
        this lease. (Note1: one client may use many IAID
        simulatenously. Note2: IAID for IA, TA and PD are orthogonal
        number spaces.)</t>
        <t>valid life time sent to client</t>
	<t>potential valid life time</t>
        <t>preferred life time sent to client</t>
        <t>CLTT - Client Last Transaction Time, a timestamp
        of the last received transmission from a client</t>
        <t>assigned FQDN names, if any (optional)</t>
      </list>
      Discussion: Do we need T1 as well? Something like next expected
      client transmission?</t>
      <t>Q: Maybe we could reuse IA_NA and IA_PD options here? Yes.</t>
      <t>Q: Do we care about preferred lifetime? (presumably no).  Certainly not 
      what was requested by the client.</t>
      <t>Q: Do we care about IAID? (presumably yes) Yes.</t>

    <section title="Required Data">
    </section>

    <section title="Optional Data">
    </section>
  </section> <!-- sending data -->

  <section title="Receiving Data">

    <section title="Conflict Resolution">
      <t>TODO: This is just a loose collection of notes. This section
      will probably need to be rewritten as a a flowchart of some kind.</t>

      <t>The server receiving a lease update from its partner must evaluate
      the received lease information to see if it is consistent with already known state and
      decide which information - previously known or just received -
      is "better". The server should take into consideration the following
      aspects: if the lease is already assigned to specific client,
      who had contact with client recently, start time of the lease, etc.
      </t>
      <t>The lease update may be accepted or rejected. 
      Rejection SHOULD NOT change the flag in a lease that says that
      it should be transmitted to the failover partner.  If this flag
      is set, then it should be transmitted, but if it is not already
      set, the rejection of a lease state update SHOULD NOT trigger
      an automatic update of the failover partner sending the rejected
      update.  The potential for update storms is too great, and in
      the unusual case where the servers simply can't agree, that
      disagreement is better than an update storm.
      </t>
      <t>
	Discussion: There will definitely be different types of
	update rejections. For example, this will allow a server
	to treat differently a case when receiving a new lease that
	it previously haven't seen than a case when partner sents
	old version of a lease for which a newer state is known.
      </t>

    </section>

    <section title="Acknowledging Reception">
    </section>

  </section> <!-- receiving data -->
</section> <!-- partner update -->

  <section anchor="states" title="Endpoint States">
    <t>The following sections contain detailed description of all
    possible states of failover endpoint.</t>
    <section anchor="state-init" title="State Machine Initialization">
      <t>TODO</t>
    </section>

    <section anchor="state-normal" title="NORMAL State Operation">
      <t>TODO</t>
    </section>

    <section anchor="state-comm-inter" title="COMMUNICATION-INTERRUPTED State Operation">
      <t>TODO</t>
    </section>

    <section anchor="state-partner-down" title="PARTNER-DOWN State Operation">
      <t>TODO</t>
    </section>

    <section anchor="state-recovering" title="RECOVERING State Operation">
      <t>TODO</t>
    </section>

    <section title="State Transitions">
      <t>TODO</t>
    </section>
  </section>

  <!--
  <section title="Failure recovery">
    <t>Discussion: although following sections may be somewhat
    redundant, given desciptions in <xref target="states"/>, but
    it should be described here for clarity.</t>

    <section title="Partner-down event recovery">
    </section>
    <section title="Network partition event recovery">
    </section>
  </section>-->

  <section title="Proposed extensions">
    <t>The following section discusses possible extensions to the proposed
    failover mechanism. Listed extensions must be sufficiently simple to
    not further complicate failover protocol. Any proposals that are
    considered complex will be defined as stand-alone extensions in
    separate documents.</t>

    <section title="Active-active mode">
      <t>A very simple way to achieve active-active mode is to remove
      the restriction that seconary server MUST NOT respond to SOLICIT
      and REQUEST messages. Instead it could respond, but MUST have
      lower preference than primary server. Clients discovering
      available servers will receive ADVERTISE messages from both
      servers, but are expected to select the primary server as it has
      higher preference value configured. The following REQUEST message
      will be directed to primary server.</t>

    <t>Discussion: Do DHCPv6 clients actually do this?  DHCPv4 clients
    were rumored to wait for a "while" to accept the best offer, but
    to a first approximation, they all take the first offer they
    receive that is even acceptable.</t>

      <t>The benefit of this approach, compared to the "basic"
      active--passive solution is that there is no delay between
      primary failure and the moment when secondary starts serving
      requests.</t>
      <t>Discussion: The possibility of setting both servers preference to
      an equal value could theoretically work as a crude attempt to
      provide load balancing. It wouldn't do much good on its own, as
      one (faster) server could be chosen more frequently (assuming
      that with equal preference sets clients will pick first
      responding server, which is not mandated by DHCPv6).  We could
      design a simple mechanism of dynamically updating preference
      depending on usage of available resources. This concept hasn't
      been investigated in detail yet.</t>
    </section>
  </section>

  <section anchor="DDNS" title="Dynamic DNS Considerations">
    <t>TODO: Descibe DNS Updates challenges in failover environment.
    It is nicely described in Section 5.12 of <xref
    target="dhcpv4-failover"/>.</t>
  </section>

  <section anchor="reserve" title="Reservations and failover">
    <t>TODO: Describe how lease reservation works with failover. See
    Section 5.13 in <xref target="dhcpv4-failover"/>.</t>
  </section>

  <section anchor="protocol-skeleton" title="Protocol entities">
    <t>Discussion: It is unclear if following sections belong to
    design or protocol draft. It is currently kept here as a
    scratchbook with list of things that will have to be defined
    eventually. Whether or not it will stay in this document or will be moved to
    the protocol spec document is TBD.</t>

    <section anchor="options" title="Failover Protocol">
      <t>This section enumerates list of options that will be defined in
      failover protocol specification. Rough description of purpose and
      content for each option is specified. Exact on wire format will be
      defined in protocol specification.</t>
      <t><list style="numbers">
        <t>OPTION_FO_TIMESTAMP - convey information about timestamp. It
        is used by time skew measurement algorithm (see <xref
        target="time-skew"/>).</t>
      </list></t>
    </section>

    <section anchor="defines" title="Protocol constants">
      <t>This section enumerates various constants that have to be defined
      in actual protocol specification.</t>
      <t><list style="numbers">
        <t>TIME_SKEW_PKTS_AVG - number of packets that are used to calculate
        average time skew between partners. See (see <xref
        target="time-skew"/>).</t>
      </list></t>
    </section>

  </section>

  <section title="Open questions">
    <t>This is scratchbook. This section will be removed once questions are answered.</t>
    <t>Q: Do we want to support temporary addresses? I think not. They
    are short-lived by definition, so clients should not mind getting new temporary
    addresses.</t>
    <t>Q: Do we want to support CGA-registered addresses? There is currently
    work in DHC WG about this, but I haven't looked at it yet. If that is complicated,
    we may not define it here, but rather as an extension. [If it moves forward, we need
    to support it.]</t>
  </section>

  <section title="Security Considerations">
    <t>TODO: Security considerations section will contain loose notes
    and will be transformed into consistent text once the core design
    solidifies.</t>
  </section>

  <section title="IANA Considerations">
    <t>IANA is not requested to perform any actions at this time.</t>
  </section>

  <section title="Acknowledgements">
    <t>This document extensively uses concepts, definitions and other
    parts of <xref target="dhcpv4-failover"/> document.  Authors would
    like to thank Shawn Routher, Greg Rabil, and Bernie Volz for their
    significant involvement and contributions.</t>

    <t>This work has been partially supported by Department of
    Computer Communications (a division of Gdansk University of
    Technology) and the Polish Ministry of Science and Higher
    Education under the European Regional Development Fund, Grant
    No. POIG.01.01.02-00-045/09-00 (Future Internet Engineering
    Project).</t>
  </section>
</middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.2131'?>
      <?rfc include='reference.RFC.3074'?>
      <?rfc include='reference.RFC.3315'?>
      <?rfc include='reference.RFC.3633'?>
      <?rfc include='reference.RFC.4704'?>
      <?rfc include="reference.RFC.5460"?>
    </references> <references title="Informative References">

    <!-- <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dhc-dhcpv6-failover-requirements.xml'?> -->
    <reference anchor="requirements">
      <front>
        <title>DHCPv6 Failover Requirements</title>
        <author initials="T" surname="Mrugalski" fullname="Tomasz Mrugalski">
          <organization abbrv="ISC">Internet Systems Consortium</organization>
        </author>
        <author initials="K" surname="Kinnear" fullname="Kim Kinnear">
          <organization abbrev="Cisco">Cisco Systems</organization>
        </author>
        <date month="October" day="18" year="2011"/>
      </front>
      <seriesInfo name="Internet-Draft" value="draft-ietf-dhc-dhcpv6-failover-requirements-00"/>
      <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-dhc-dhcpv6-failover-requirements-00.txt"/>
    </reference>

      <reference anchor="dhcpv4-failover">
        <front>
          <title>DHCP Failover Protocol</title> <author fullname="Ralph
          Droms" initials="R." surname="Droms">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Kim Kinnear" initials="K."
          surname="Kinnear">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Mark Stapp" initials="M."
          surname="Stapp">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Bernie Volz" initials="B."
          surname="Volz">
            <organization>Ericsson</organization>
          </author> <author fullname="Steve Gonczi" initials="S."
          surname="Gonczi">
            <organization>Relicore</organization>
          </author> <author fullname="Greg Rabil" initials="G."
          surname="Rabil">
            <organization>Lucent Technologies</organization>
          </author> <author fullname="Michael Dooley" initials="M."
          surname="Dooley">
            <organization>Diamond IP Technologies</organization>
          </author> <author fullname="Arun Kapur" initials="A."
          surname="Kapur">
            <organization>K5 Networks</organization>
          </author> <date month="March" year='2003'/>
        </front> <seriesInfo name="Internet-Draft"
        value="draft-ietf-dhc-failover-12"/>
      </reference> <?rfc
      include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2136'?>
      <?rfc
      include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dhc-dhcpv6-redundancy-consider.xml'?>

    </references>
  </back>
</rfc>
