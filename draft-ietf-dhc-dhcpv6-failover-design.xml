<?xml version='1.0' ?>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>

<?rfc compact="yes"?> <?rfc subcompact="no"?>

<?rfc symrefs="yes"?>

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' [
]>
<rfc ipr="trust200902" category="info"
     docName="draft-ietf-dhc-dhcpv6-failover-design-05">
  <front>
    <title abbrev="DHCPv6 Failover Design">DHCPv6 Failover Design</title>

    <author fullname="Tomasz Mrugalski" initials="T." surname="Mrugalski">
      <organization abbrev="ISC">Internet Systems Consortium, Inc.
      </organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>USA</country>
        </postal>
        <phone>+1 650 423 1345</phone>
        <email>tomasz.mrugalski@gmail.com</email>
      </address>
    </author>
    <author fullname="Kim Kinnear" initials="K." surname="Kinnear">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1414 Massachusetts Ave.</street>
          <city>Boxborough</city>
          <region>Massachusetts</region>
          <code>01719</code>
          <country>USA</country>
        </postal>
        <phone>+1 (978) 936-0000</phone>
        <email>kkinnear@cisco.com</email>
      </address>
    </author>

    <date />

    <area>Internet</area>
    <workgroup>Dynamic Host Configuration (DHC)</workgroup>
    <keyword>DHCPv6</keyword>
    <keyword>Failover</keyword>

    <abstract>
      <t>DHCPv6 defined in <xref target="RFC3315"/> does not offer
      server redundancy. This document defines a design for DHCPv6
      failover, a mechanism for running two servers on the same
      network with capability for either server to take over clients'
      leases in case of server failure or network partition.  This is
      a DHCPv6 Failover design document, it is not a protocol
      specification document. It is a second document in a planned
      series of three documents. DHCPv6 failover requirements are
      specified in <xref
      target="RFC7031"/>.  
      A protocol specification document is
      available <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Glossary">
      <t>This is a supplemental glossary that should be combined with
      definitions in Section 3 of
      <xref target="RFC7031"/>.

      <list style="symbols">

        <t>auto-partner-down - a capability where a failover server
	will move from COMMUNICATIONS-INTERRUPTED state to 
	PARTNER-DOWN state automatically, without operator intervention.</t>

	<t>DDNS - Dynamic DNS.  Typically used as an acronym referring to
	dynamic update of the DNS.</t> 

	<t>Failover endpoint - The failover protocol allows for
	there to be a unique failover 'endpoint' for each failover
	relationship in which a failover server participates.  The
	failover relationship is defined by a relationship name,
	and includes the failover partner IP address, the role this
	server takes with respect to that partner (primary or
	secondary), and the prefixes associated with that relationship.
	Note that a single prefix can only be associated with a
	single failover relationship.  This failover endpoint can
	take actions and hold unique states.  Typically, there is
	one failover endpoint per partner (server), although there
	may be more.  'Server' and 'failover endpoint' are synonymous
	only if the server participates in only one failover
	relationship. However, for the sake of simplicity 'Server'
	is used throughout the document to refer to a failover
	endpoint unless to do so would be confusing.</t>

        <t>Failover communication - all messages exchanged between
        partners.</t>

        <t>Independent Allocation - an allocation algorithm
        that splits the available pool of resources between the primary
        and secondary servers that is particularly well suited for
        vast pools (i.e. when available resources are not expected
        to deplete). See <xref target="alloc-separated"/> for
        details.</t>

	<t>Lease - an association of a DHCPv6 client with an IPv6 
	address or delegated prefix.</t>

        <t>Partner - name of the other DHCPv6 server that participates
        in failover relationship. When the role (primary or secondary)
        is not important, the other server is referred to as a "failover
        partner" or simply partner.</t>

        <t>Primary Server - First out of two DHCPv6 servers that participate
        in a failover relationship. In active-passive mode this is the
        server that handles most of the client traffic. Its failover partner
        is referred to as secondary server. </t>

        <t>Proportional Allocation - an allocation algorithm
        that splits the available resources between
        the primary and secondary servers and maintains proportions between
	available resources on both. It is particularly well suited for more
        limited resources.  See <xref target="alloc-classic"/> for
        details.</t>

	<t>Resource - Any type of resource that is managed by
	DHCPv6. Currently there are three types of such resources
	defined: a non-temporary IPv6 address, a temporary IPv6 address,	 
	and an IPv6 prefix. Other resource types may
	be defined in the future.</t>

        <t>Responsive - A server that is responsive, will respond to
        DHCPv6 client requests.</t>

        <t>Secondary Server - Second of two DHCPv6 servers that participate
        in a failover relationship. Its failover partner is referred to as
        the primary server. In active-passive mode this server (the secondary)
	typically does not handle client traffic and acts as a backup.</t>

        <t>Server - A DHCPv6 server that implements DHCPv6 failover.
        'Server' and 'failover endpoint' are synonymous only if the
        server participates in only one failover relationship. </t>

        <t>Unresponsive - A server that is unresponsive will not
        respond to DHCPv6 client requests.</t>

      </list>
      </t>
    </section>


    <!-- 
    TODO: 

    FO_SEND and friends are missing.

    Lots of options to do.
    -->



    <section title="Introduction">
      <t>The failover protocol design provides a means for cooperating
      DHCPv6 servers to work together to provide a DHCPv6 service
      with availability that is increased beyond that which could
      be provided by a single DHCPv6 server operating alone.  It
      is designed to protect DHCPv6 clients against server unreachability,
      including server failure and network partition. It is possible
      to deploy exactly two servers that are able to continue
      providing a lease on an IPv6 address <xref target="RFC3315"/>
      or on an IPv6 prefix <xref target="RFC3633"/>
      without the DHCPv6 client experiencing lease expiration or a
      reassignment of a lease to a different IPv6 address (or prefix) 
      in the event of failure by one or the other of the two servers.</t>

      <t>This protocol defines active-passive mode, sometimes also
      called a hot standby model. This means that during normal
      operation one server is active (i.e. actively responds to
      clients' requests) while the second is passive (i.e. it does
      receive clients' requests, but does not respond to them and only
      maintains a copy of lease database and is ready to take over
      incoming queries in case of primary server
      failure). Active-active mode (i.e. both servers actively
      handling clients' requests) is currently not supported for the
      sake of simplicity. Such a mode is likely to be defined as an
      extension at a later time and will probably be based on <xref
      target="I-D.ietf-dhc-dhcpv6-load-balancing" />.</t>

      <t>The failover protocol is designed to provide lease stability
      for leases with lease times beyond a short period.  Due in part to the
      additional overhead required as well as requirements to handle
      time skew between failover partners (See <xref target="time-skew"/>),
      failover is not suitable for leases shorter than 30 seconds. 
      The DHCPv6 Failover protocol MUST NOT be used for leases shorter 
      than 30 seconds.</t>

      <t>This design attempts to fulfill all DHCPv6 failover requirements
      defined in <xref target="RFC7031"/>.</t>

      <section title="Design Requirements">
        <t>The following requirements are not related to failover the
        mechanism in general, but rather to this particular design.

        <list style="numbers">
          <t>Minimize Asymmetry - while there are two distinct roles
          in failover (primary and secondary server), the
          differences between those two roles should be as small as
          possible.   This will yield a simpler design as well as
          a simpler implementation of that design.</t>
        </list>
        </t>
      </section>

      <section title="Features out of Scope: Load Balancing">
	<t>While it is tempting to extend DHCPv6 failover mechanism
	to also offer load balancing, as DHCPv4 failover did, this
	design does not do that. Here is the reasoning for this
	decision. In general case (not related to failover) load
	balancing solutions are used when each server is not able
	to handle total incoming traffic.  However, by the very
	definition, DHCPv6 failover is supposed to assume service
	availability despite failure of one server. That leads to the
	conclusion that each server must be able to handle all of the
	traffic. Therefore in properly provisioned setup, load
	balancing is not needed.</t>

        <t>It is likely that active-active mode that is essentially
        a load balancing will be defined as an extension in the
        near future.</t>
      </section> <!-- features out of Scope -->

    </section> 

<section title="Protocol Overview">

  <t>The DHCPv6 Failover Protocol is defined as a communication between failover
  partners with all associated algorithms and mechanisms.  Failover
  communication is conducted over a TCP connection established between the
  partners. The protocol reuses the framing format specified in Section 5.1 of
  <xref target="RFC5460">DHCPv6 Bulk Leasequery</xref>, but uses different
  message types. New failover-specific message types are listed in <xref
  target="msg-list" />. All information is sent over the connection as typical
  DHCPv6 messages that convey DHCPv6 options, following the format defined in
  Section 22.1 of <xref target="RFC3315"/>.</t>

  <t>After initialization, the primary server establishes a TCP connection
  with its partner. The primary server sends a CONNECT message with initial
  parameters. Secondary server responds with CONNECTACK.</t>

  <t> If the primary server cannot immediately establish a connection with
  its partner, it will continue to attempt to establish a connection. 
  </t>

  <t>Depending on the failover state of each partner, they MUST
  initiate one of the binding update procedures. Each server MAY
  send an UPDREQ message to request its partner to send all updates
  that have not been sent yet (this case applies when the partner has
  an existing database and wants to update it). Alternatively, a
  server MAY choose to send an UPDREQALL message to request a full
  lease database transmission including all leases (this case applies
  in case of booting up a new server after installation, corruption
  or complete loss of database, or other catastrophic failure).</t>

  <t>Servers exchange lease information by using BNDUPD messages.
  Depending on the local and remote state of a lease, a server may
  either accept or reject the update. Reception of lease update
  information is confirmed by responding with a BNDACK message with
  appropriate status. The majority of the messages sent over a
  failover TCP connection consists of BNDUPD and BNDACK messages.</t>

  <t>A subset of available resources (addresses or prefixes) is
  reserved for secondary server use. This is required for handling
  a case where both servers are able to communicate with clients,
  but unable to communicate with each other. After the initial
  connection is established, the secondary server requests a pool
  of available addresses or prefixes by sending a POOLREQ message.
  The primary server assigns addresses or prefixes to the secondary
  by sending a series of BNDUPD messages.  When this process is
  complete, the primary server sends a POOLRESP message to the
  secondary server.  The secondary server may initiate such pool
  request at any time when in communication with primary server.</t>

  <t>Failover servers use a lazy update mechanism to update their
  failover partner about changes to their lease state database.
  After a server performs any modifications to its lease state
  database (assign a new lease, extend, release or expire existing
  lease), it sends its response to the client's request
  first (performing the "regular" DHCPv6 operation) and then informs
  its failover partner using a BNDUPD message. This BNDUPD message
  SHOULD be sent soon after the response is sent to the DHCPv6
  client, but there is no specific requirement of a minimum time
  in which to do so.</t>

  <t>The major problem with a lazy update mechanism is when
  the server crashes after sending a response to client, but before
  sending the lazy update to its partner (or when communication
  between partners is interrupted). To solve this problem, the concept
  known as the Maximum Client Lead Time (initially designed
  for DHCPv4 failover) is used.  The MCLT is the maximum amount of
  time that one server can extend a lease for a client's binding
  beyond the time known by its failover partner. See <xref
  target="mclt"/> for a detailed description how the MCLT affects assigned
  lifetimes.</t>

  <t>Servers verify each others availability by periodically
  exchanging CONTACT messages. 
  </t>

  <t>A server that is being shut down transmits a DISCONNECT message,
  closes the connection with its failover partner and stops
  operation. A Server SHOULD transmit any pending lease updates before
  transmitting DISCONNECT message.</t>

  <section anchor="states-overview" title="Failover State Machine Overview">
    <t>The following section provides a simplified description of all
    states. For the sake of clarity and simplicity, it omits important
    details. For a complete description, see <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
    In case of a disagreement between the simplified here and the complete description,
    please follow the complete description in <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
    </t>

    <t>Each server MUST be in one of the well defines states.
    Depending on its current state a server may be either responsive
    (responds to clients' queries) or unresponsive (clients' queries
    are ignored).</t>

    <t>A server starts its operation in the short-lived STARTUP state. A
    server determines its partner reachability and state and sets its
    own state based on that determination.  It typically
    returns back to the state it was in before shutdown, though the 
    details can be complicated.  
    </t>

    <t>During typical operation when servers maintain communication,
    both are in NORMAL state. In that state only the primary responds to
    clients' requests. The secondary server is unresponsive.</t>

    <t>If a server discovers that its partner is no longer reachable,
    it goes to COMMUNICATIONS-INTERRUPTED state. A server must be
    extra cautious as it can't distinguish if its partner is down
    or just communication between servers is interrupted. Since
    communication between partners is not possible, a server must
    act on the assumption that its partner is up.  A failover server
    must follow a defined procedure, in particular, it MUST NOT
    extend any lease more than the MCLT beyond its partner's knowledge
    of the lease expiration time.  This imposes an additional burden
    on the server, in that clients will return to the server for
    lease renewals more frequently than they would otherwise.
    Therefore it is not recommended to operate for prolonged periods
    in this state.  Once communication is reestablished, a server may
    go into NORMAL, POTENTIAL-CONFLICT or PARTNER-DOWN state. It
    may also stay in COMMUNICATIONS-INTERRUPTED state if certain
    conditions are met.</t>

    <t>Once a server is switched into PARTNER-DOWN (when auto-partner-down
    is used or as a result of administrative action), it can extend
    leases, regardless of the original server that initially granted
    the lease. In that state server handles leases from its own
    pool, but once its own pool is depleted is also able to serve
    pool from its downed partner. Some MCLT restrictions no longer
    apply, but the MCLT still affects whether or not a particular
    lease can be given to a different client.  
    Operation
    in this mode is less demanding for the server that remains
    operational, than in COMMUNICATIONS-INTERRUPTED state, but
    PARTNER-DOWN does not offer any kind of redundancy.  Even when
    in PARTNER-DOWN state, a failover server continues to attempt
    to connect with its failover partner.</t>

    <t>A server switches into RECOVER state when any of a variety 
    of conditions are encountered:
    <list style="symbols">
      <t>When a backup server contacts its failover partner for the
      first time.</t>
      <t>When either server discovers that its failover partner has
      contacted it before but it has no local record of this contact.
      If the record of previous contact is held in the lease-state
      database, then this situation implies that the server has lost
      its lease state database.</t>
      <t>When its failover partner is in PARTNER-DOWN state.</t>
    </list>
    Any of these conditions signal that the server 
    needs to refresh its lease-state database from its partner. Once this
    operation is complete, it switches to RECOVER-WAIT and later
    to RECOVER-DONE.  
    </t>

    <t>Once servers reestablish connection, they discover each others'
    state. Depending on the conditions, they may return to NORMAL or
    move to POTENTINAL-CONFLICT if the partner is in a state that doesn't
    allow a simple re-integration of the server's lease state databases.
    It is a goal of this protocol to minimize the possibility
    that POTENTIAL-CONFLICT state is ever entered. Servers running in
    POTENTIAL-CONFLICT do not respond to clients' requests and work only on
    resolving potential conflicts. Once outstanding lease updates are
    exchanged, servers move to CONFLICT-DONE or NORMAL states.</t>

    <t>Servers that are recovering from potential conflicts and loose
    communication, switch to RESOLUTION-INTERRUPTED.</t>

    <t>A server that is being shut down sends a DISCONNECT message.
    See <xref target="msg-list"/>.  
    A server that receives a DISCONNECT message
    moves into COMMUNICATIONS-INTERRUPTED state.</t>

  </section>

  <section anchor="msg-list" title="Messages">
    <t>The failover protocol is centered around the message exchanges used by
    one server to update its partner and respond to received updates.
    It should be noted that no specific formats or message type values are
    assigned in this document. Appropriate implementation details are specified
    in <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
    The following list enumerates these messages at a high level:</t>
    <t>
    <list style="symbols">
      <t>BNDUPD - The binding update message is used to send the binding lease
      changes to the partner. One message may contain one or more lease
      updates. The partner is expected to respond with a BNDACK message.</t>
      <t>BNDACK - The binding acknowledgement is used for confirmation of the
      received BNDUPD message. It may contain a positive or negative response
      (e.g. due to detected lease conflict).</t>
      
      <t>POOLREQ - The Pool Request message is used by one server (typically
      secondary) to request allocation of resources (addresses or prefixes) from
      its partner. The partner responds with POOLRESP.</t>

      <t>POOLRESP - The Pool Response message is used by one server
      (typically primary) to indicate that it has responded to its
      partner's request for resources allocation.  </t>

      <t>UPDREQ - The update request message is used by one server to request
      that its partner send all binding database changes that have not been
      sent and confirmed already. Requested partner is expected to respond
      with zero or more BNDUPD messages, followed by UPDDONE that signals
      end of updates.</t>

      <t>UPDREQALL - The update request all is used by one server to request
      that all binding database information be sent in order to recover from a
      total loss of its binding database by the requesting server. Requested
      server responds with zero or more BNDUPD messages, followed by UPDDONE
      that signal end of updates.</t>

      <t>UPDDONE - The update done message is used by the server
      responding to an UPDREQ or UPDREQALL to indicate that all
      requested updates have been sent by the responding server and
      acked by the requesting server.</t>

      <t>CONNECT - The connect message is used by the primary server to
      establish a high level connection with the other server, and to transmit
      several important configuration data items between the servers. The
      partner is expected to confirm by responding with CONNECTACK message.</t>

      <t>CONNECTACK - The connect acknowledgement message is used by the
      secondary server to respond to a CONNECT message from the primary
      server.</t>
      <!-- tomek: do we want to make this bi-directional? I think it should work
           both ways, not only primary connecting to secondary, but in the
           opposite direction as well. -->
      
      <t>DISCONNECT - The disconnect message is used by either server when
      closing a connection and shutting down. No response is required for this
      message.</t>
      <!-- tomek: v4 doesn't have any DISCONNECTACK. Why? Perhaps we should add
           it. Servers that use failover are not pocket devices that must shut
           down in 0.001 seconds to conserve energy. It is ok to prolong the
           shutdown sequence by a second or two. It is reasonable to assume that
           some implementations will abort graceful shutdown if there is no
           response from the partner. Of course, such implementations would need
           some form of forced shutdown knob. -->
      
      <t>STATE - The state message is used by either server to inform its
      partner about a change of failover state. In some cases it may be used
      to also inform the partner about current state, e.g. after connection
      is established in COMMUNICATIONS-INTERRUPTED or PARTNER-DOWN states.</t>
      <!-- tomek: again, why is there no STATEACK message? -->

      <t>CONTACT - The contact message is used by either server to ensure that
      the other server continues to see the connection as operational.  It
      MUST be transmitted periodically over every established connection if
      other message traffic is not flowing, and it MAY be sent at any time.</t>
      <!-- tomek: what about link failing in only one direction, e.g. uplink
      broken? Perhaps there should be some way to acknowledge CONTACT? -->
    </list>
    </t>

  </section>
</section>


<section title="Connection Management Overview">

    <t>Every primary server implementing the failover protocol
    MUST attempt to connect to all of its partners periodically,
    where the period is implementation dependent and SHOULD be
    configurable. 
    </t>

    <t>Every secondary server implementing the failover protocol
    MUST listen for connection attempts from the primary server.
    </t>

    <t>When a connection attempt succeeds, the primary server which
    has initiated the connection attempt MUST send a CONNECT message
    down the connection.  A secondary server SHOULD respond with
    a CONNECTACK message indicating its acceptance or rejection of
    the attempt to connect</t>


  <section title="Endpoint Identification">
    <t>The proper operation of the failover protocol requires more than
    the transmission of messages between one server and the other.  Each
    endpoint might seem to be a single DHCPv6 server, but in fact there
    are situations where additional flexibility in configuration
    is useful.  A failover endpoint is always associated with a set
    of DHCPv6 prefixes that are configured on the DHCPv6 server where
    the endpoint appears.  A DHCPv6 prefix MUST NOT be associated with
    more than one failover endpoint.</t>

    <t>The failover protocol SHOULD be configured with one failover
    relationship between each pair of failover servers. In this
    case there is one failover endpoint for that relationship on
    each failover partner.  This failover relationship MUST have a
    unique name.</t>

    <t>There is typically little need for additional relationships between
    any two servers but there MAY be more than one failover relationship
    between two servers -- however each MUST have a unique relationship
    name.</t>

    <t>Any failover endpoint can take actions and hold unique states.</t>

    <t>This document frequently describes the behavior of the protocol in
    terms of primary and secondary servers, not primary and secondary
    failover endpoints.  However, it is important to remember that every
    'server' described in this document is in reality a failover endpoint
    that resides in a particular process, and that several failover
    end-points may reside in the same server process.</t>

    <t>It is not the case that there is a unique failover endpoint for
    each prefix that participates in a failover relationship.  On one
    server, there is (typically) one failover endpoint per partner,
    regardless of how many prefixes are managed by that combination of
    partner and role.  Conversely, on a particular server, any given
    prefix will be associated with exactly one failover endpoint.</t>

    <t>When a connection is received from the partner, the unique failover
    endpoint to which the message is directed is determined solely by
    the IP address of the partner, the relationship-name, and the role
    of the receiving server.</t>

  </section>
</section>

<section title="Resource Allocation">
  <t>Currently there are two allocation algorithms defined for
  resources (addresses or prefixes). Additional allocation schemes
  may be defined as future extensions.</t>

  <t>
  <list style="numbers">
    <t>Proportional Allocation - This allocation algorithm is a
    direct application of the algorithm defined in <xref target="dhcpv4-failover"/>
    to DHCPv6. Remaining available resources are split between the primary and
    secondary servers in a configured proportion. Released resources
    are always returned to the primary server.  Primary and secondary
    servers may initiate a rebalancing procedure when disparity
    between resources available to each server reaches a preconfigured
    threshold. Only resources that are not leased to any clients
    are "owned" by one of the servers. This algorithm is particularly
    well suited for scenarios where amount of available resources
    is limited, as may be the case with prefix delegation. See <xref
    target="alloc-classic"/> for details.</t>

    <t>Independent Allocation - 
    This allocation algorithm also assumes that available resources 
    are split between primary and secondary servers.
    In this case, however, resources are assigned
    to a specific server for all time, regardless if they are
    available or currently used. This algorithm is much simpler
    than proportional allocation, because resource imbalance doesn't
    have to be checked and there is no rebalancing for independent
    allocation. This algorithm is particularly well suited for
    scenarios where the there is an abundance of available resources
    which is typically the case for DHCPv6 address
    allocation.  See <xref target="alloc-separated"/> for details.</t>
  </list>
  </t>

  <section anchor="alloc-classic" title="Proportional Allocation">

    <t>In this allocation scheme, each server has its own pool of
    available resources. Remaining available resources are split between the
    primary and secondary servers in a configured proportion.
    Note that a resource is not "owned" by a
    particular server throughout its entire lifetime.  Only a resource
    which is available is "owned" by a particular server -- once it
    has been leased to a client, it is not owned by either failover
    partner.  When it finally becomes available again, it will be
    owned initially by the primary server, and it may or may not be
    allocated to the secondary server by the primary server.</t>

    <t>The flow of a resource is as follows: initially a resource
    is owned by the primary server.  It may be allocated to the
    secondary server if it is available, and then it is owned by the
    secondary server.  Either server can allocate available resources
    which they own to clients, in which case they cease
    to own them.  When the client releases the resource or the
    lease on it expires, it will again become available and will be
    owned by the primary.</t>

    <!-- tomek: if we are told that the text is too long, this paragraph
    is explanatory and does not really add any specific value. Let's
    keep it for now, though. -->
    <t>A resource will not become owned by the server which allocated
    it initially when it is released or the lease expires because, in
    general, that server will have had to replenish its pool of
    available resources well in advance of any likely lease
    expirations.  Thus, having a particular resource cycle back to the
    secondary might well put the secondary more out of balance with
    respect to the primary instead of enhancing the balance of
    available addresses or prefixes between them.</t>

    <!-- issue 1: Done
	 tomek: the vocabulary seems ok to me. There are no explicit
	 references to addresses, but rather resources (address or prefix).
    <t>TODO: Need to rework this v4-specific vocabulary to v6, once we
    decide how things will look like in v6.</t> -->

    <t>Pools governed by proportional allocation are used for
    allocation when the server is in all states, except PARTNER-DOWN.
    In PARTNER-DOWN state the healthy partner can allocate from
    either pool (both its own, and its partner's after some time
    constraints have elapsed). This allocation and maintenance of
    these address pools is an area of some sensitivity, since the
    goal is to maintain a more or less constant ratio of available
    addresses between the two servers.</t>

    <!-- issue 2
    TODO: Reuse rest of the description from section 5.4 from <xref
    target="dhcpv4-failover"/> here.

    Done 10/16/12 Kim
    -->

    <t>The initial allocation when the servers first integrate is
    triggered by the POOLREQ message from the secondary to the
    primary.  This is followed (at some point) by the POOLRESP
    message where the primary tells the secondary that it received
    and processed the POOLREQ message.  The primary sends the
    allocated resources to the secondary via BNDUPD messages.  The
    POOLRESP message may be sent before, during, or at the completion
    of the BNDUPD message exchanges that were triggered by the
    POOLREQ message.  The POOLREQ/POOLRESP message exchange is a
    trigger to the primary to perform a scan of its database and
    to ensure that the secondary has enough resources (based on
    some configured ratio).</t>

    <t>The primary server SHOULD examine some or all of its database
    from time to time to determine if resources should be shifted
    between the primary and secondary (in either direction).  The
    POOLREQ/POOLRESP message exchange allows the secondary server
    to explicitly request that the primary server examine the
    entirety of its database to ensure that the secondary has the
    appropriate resources available.</t>

    <t>Servers frequently have several kinds of resources available
    on a particular network segment.  The failover protocol assumes
    that both primary and secondary servers are configured in such
    a way that each knows the type and number of resources on every
    network segment participating in the failover protocol.  The
    primary server is responsible for allocating the secondary
    server the correct proportion of available resources of each
    kind.</t> 

    <t>The resources are delegated to the secondary using the BNDUPD
    message with a state of FREE_BACKUP, which indicates the resource
    is now available for allocation by the secondary.  Once the
    message is sent, the primary MUST NOT use these resources for
    allocation to DHCPv6 clients.</t>

    <t>Available resources can be delegated back to the primary server
    in certain cases. BNDUPD will contain state FREE for leases that
    were previously in FREE_BACKUP state.</t>

    <t>The POOLREQ/POOLRESP message exchange initiated by the
    secondary is valid at any time both partners remain in contact,
    and the primary server SHOULD,
    whenever it receives the POOLREQ message, scan its database of
    prefixes and determine if the secondary needs more resources
    from any of the prefixes. </t>

    <t>In order to support a reasonably dynamic balance of the
    resources between the failover partners, the primary server
    needs to do additional work to ensure that the secondary server
    has as many resources as it needs (but that it doesn't have
    more than it needs).</t>

    <t>The primary server SHOULD examine the balance of available
    resources between the primary and secondary for a particular
    prefix whenever the number of available resources for either
    the primary or secondary changes by more than a configured
    limit.  The primary server SHOULD adjust the available resource
    balance as required to ensure the configured resource balance,
    excepting that the primary server SHOULD employ some threshold
    mechanism to such a balance adjustment in order to minimize the
    overhead of maintaining this balance.</t>

    <t>An example of a threshold approach is: do not attempt to
    re-balance the prefixes on the primary and secondary until the
    out of balance value exceeds a configured value.</t>

    <t>The primary server can, at any time, send an available
    resource to the secondary using a BNDUPD with the state FREE_BACKUP.
    The primary server can attempt to take an available resource
    away from the secondary by sending a BNDUPD with the state FREE.
    If the secondary accepts the BNDUPD, then the resource is now available
    to the primary and not available to the secondary.  Of course,
    the secondary MUST reject that BNDUPD if it has already used
    that resource for a DHCP client.</t>
  </section>

  <section anchor="alloc-separated" title="Independent Allocation">
    <t>In this allocation scheme, available resources are permanently (until
    server configuration changes) split
    between servers. Available resources are split between the primary and
    secondary servers as part of initial connection establishment. Once
    resources are allocated to each server, there is no need to
    reassign them. The resource allocation is algorithmic in nature,
    and does not require a message exchange for each resource allocated.
    This algorithm is simpler than proportional
    allocation since it does not require a rebalancing mechanism. It assumes
    that the pool assigned to each server will never deplete. That is
    often a reasonable assumption for IPv6 addresses (e.g. servers are
    often assigned a /64 pool that contains many more addresses than existing
    electronic devices on Earth). This allocation mechanism SHOULD be
    used for IPv6 addresses, unless the configured address pool is small
    or is otherwise administratively limited.</t>

    <t>Once each server is assigned a resource pool during initial
    connection establishment, it may allocate assigned resources to
    clients. Once a client releases a resource or its lease is expired,
    the returned resource returns to the pool for the server that leased it.
    Resources never changes servers.</t>

    <t>Resources using the independent allocation approach are ignored
    when a server processes a POOLREQ message.</t>

    <t>During COMMUNICATION-INTERRUPTED events, a partner MAY
    continue extending existing leases when requested by clients.
    A healthy partner MUST NOT lease resources that were assigned
    to its downed partner and later released by a client unless it
    is in PARTNER-DOWN state.  When it is in PARTNER-DOWN state, a
    server SHOULD use its own pool first and then it MAY start
    making new assignments from its downed partner's pool. As the
    assumption is that independent allocation should be used only
    when available resources are vast and not expected to be fully
    used at any given time, it is very unlikely that the server
    will ever need to use its downed partner pools. This makes a
    recovery even after prolonged down-time much easier.  </t>
  </section>

  <section title="Choosing Allocation Algorithm">

    <t>All implementations SHOULD support both the proportional
    allocation algorithm and the independent allocation algorithm.
    The specific requirements for support (i.e., which algorithm(s)
    MUST be supported), and the assignment of a specific algorithm
    to a specific allocation domain, is documented in
    <xref target="I-D.ietf-dhc-dhcpv6-failover-design"/>.
    </t>

    <t>The proportional allocation mechanism is more flexible as
    it can dynamically rebalance available resources between servers.
    That balance creates an additional burden for the servers and
    generates more traffic between servers. The proportional algorithm
    can be considered more efficient at managing available resources,
    compared to the independent algorithm. That is an important
    aspect when working in a network that is nearing address and/or
    prefix depletion.</t>

    <t>Independent allocation can be used when the number of available resources
    are large and there is no realistic danger of running out of resources.
    Use of the independent allocation makes communication between partners simpler.
    It also makes recovery easier and potential conflict less likely to appear.</t>

    <t>Typically independent allocation is used for IPv6 addresses, because even
    for /64 pools a server will never run out of addresses to assign, so there
    is no need to rebalance. For the prefix delegation mechanism, available
    resources are typically much smaller, so there is a danger of running out of
    prefixes. Therefore typically proportional allocation will be used for
    prefix delegations. Independent allocation still may be used, but the
    implication must be well understood. For example in a network that delegates
    /64 prefixes out of a /48 prefix (so there can be up to 65536 prefixes
    delegated) and a 1000 requesting routers, it is safe to use independent
    allocation.</t>

    <t>It should be stressed that the independent allocation algorithm SHOULD NOT
    be used when the number of resources is limited and there is a realistic danger of
    depleting resources. If this recommendation is violated, it may lead to a case
    when one server denies clients due to pool depletion despite the fact that the
    other partner still has many resources available.</t>

    <t>With independent allocation it is very unlikely for a remaining healthy
    server to allocate resources from its unavailable partner's pool. That makes
    recovery easier and any potential conflicts are less likely to appear.</t>

    <!-- issue 10
    <t>TODO: Write this section! </t>
    tomek: done! 2012-10-22
    -->
  </section> <!-- determining allocation approach -->
</section> <!-- address allocation -->

<section title="Information model">

  <t>In most DHCP servers a resource (an IP address or a prefix) can
  take on several different binding-status values, sometimes also
  called lease states.  While no two DHCP server implementations probably have
  exactly the same possible binding-status values, <xref target="RFC3315"/>
  enforces some commonality among the general semantics of the
  binding-status values used by various DHCP server implementations.</t>

  <t> In order to transmit binding database updates between one server
  and another using the failover protocol, some common denominator
  binding-status values must be defined.  It is not expected that
  these values correspond with any actual implementation of the DHCP
  protocol in a DHCP server, but rather that the binding-status
  values defined in this document should be a common denominator of
  those in use by many DHCP server implementations. <!-- [tomek: That's
  basically an expanded repetion of the last sentence:] It is a goal of
  this protocol that any DHCP server can map the various IP address
  binding-status values that it uses internally into these failover IP
  address binding-status values on transmission of binding database
  updates to its partner, and likewise that it can map any failover IP
  address binding-status values it received in a binding update into
  its internal IP address binding-status values. --></t>

  <t>The lease binding-status values defined for the failover protocol
  are listed below. Unless otherwise noted below, there MAY be client
  information associated with each of these binding-status value.</t>

  <t>
  <list style="hanging">
    <t hangText="ACTIVE"> -- The lease is assigned to a client. Client
    identification data MUST appear.</t>
    <t hangText="EXPIRED"> -- indicates that a client's binding on a
    given lease has expired. When the partner acks the BNDUPD of an
    expired lease, the server sets its internal state to FREE*. Client
    identification SHOULD appear.</t>
    <t hangText="RELEASED"> -- indicates that a client sent in RELEASE
    message. When the partner acks the BNDUPD of a released lease,
    the server sets its internal state to FREE*. Client identification
    SHOULD appear.</t>

    <t hangText="FREE*"> -- Once a lease is expired or released, its
    state becomes FREE*. Depending on which algorithm and which pool
    was used to allocate a given lease, FREE* may either mean FREE or
    FREE_BACKUP. Implementations do not have to implement this FREE*
    state, but may choose to switch to the destination state directly.
    For a clarity of representation, this transitional FREE* state is
    treated as a separate state. </t>

    <t hangText="FREE"> -- Is used when a DHCP server needs to
    communicate that a resource is unused by any client, but it
    was not just released, expired or reset by a network administrator.
    When the partner acks the BNDUPD of a FREE lease, the server
    marks the lease as available for assignment by the primary server.
    Note that on a secondary server running in PARTNER-DOWN state, after
    waiting the MCLT, the resource MAY be allocated to a client by the
    secondary server. Client identification MAY appear and indicates
    the last client to have used this resource as a hint.</t>

    <!-- tomek: this was called BACKUP in v4, but it was confusing for
	 users. FREE_BACKUP is  -->
    <t hangText="FREE_BACKUP"> -- indicates that this resource can
    be allocated by the secondary server to a client at any time. Note
    that the primary server running in PARTNER-DOWN state, after waiting
    the MCLT, the resource MAY be allocated to a client by the primary
    server if proportional algorithm was used. Client identification
    MAY appear and indicates the last client to have used this resource 
    as a hint.</t>

    <t hangText="ABANDONED"> -- indicates that a lease is considered
    unusable by the DHCP system. The primary reason for entering
    such state is reception of DECLINE message for said lease. Client 
    identification MAY appear.</t>

    <t hangText="RESET"> -- indicates that this resource was made
    available by operator command. This is a distinct state so that
    the reason that the resource became FREE can be determined.
    Client identification MAY appear.</t>

  </list>
  </t>

  <t>The lease state machine has been presented in <xref
  target="lease-state-machine"/>. Most states are stationary, i.e. the lease
  stays in a given state until external event triggers transition to another
  state. The only transitive state is FREE*. Once it is reached, the state
  machine immediately transitions to either FREE or FREE_BACKUP state.</t>

  <figure anchor="lease-state-machine" title="Lease State Machine" align="center">
    <artwork><![CDATA[
                +---------+
 /------------->|  ACTIVE |<--------------\
 |              +---------+               |
 |                |  |  |                 |
 |       /--(8)--/  (3)  \--(9)-\         |
 |      |            |           |        |
 |      V            V           V        |
 |  +-------+   +--------+   +---------+  |
 |  |EXPIRED|   |RELEASED|   |ABANDONED|  |
 |  +-------+   +--------+   +---------+  |
 |      |            |            |       |
 |      |            |           (10)     |
 |      |            |            V       |
 |      |            |       +---------+  |
 |      |            |       |  RESET  |  |
 |      |            |       +---------+  |
 |      |            |            |       |
 |       \--(4)--\  (4)  /--(4)--/        |
 |                |  |  |                 |
(1)               V  V  V                (2)
 |              /---------\               |
 |              |  FREE*  |               |
 |              \---------/               |
 |                 |   |                  |
 |         /-(5)--/     \-(6)-\           |
 |        |                    |          |
 |        V                    V          |
 |    +-------+         +-----------+     |
 \----|  FREE |<--(7)-->|FREE_BACKUP|-----/
      +-------+         +-----------+]]>
</artwork><postamble>FREE* transition</postamble></figure>

<t>Transitions between states are results of the following events:

<list style="empty">
  <t>1. Primary server allocates a lease.</t>

  <t>2. Secondary server allocates a lease.</t>

  <t>3. Client sends RELEASE and the lease is released.</t>

  <t>4. Partner acknowledges state change. This transition MAY also occur if the
  server is in PARTNER-DOWN state and the MCLT has passed since the entry in
  RELEASED, EXPIRED, or RESET states.</t>

  <t>5. The lease belongs to a pool that is governed by the proportional
  allocation, or independent allocation is used and this lease belongs to primary
  server pool.</t>

  <t>6. The lease belongs to a pool that is governed by the independent
  allocation and the lease belongs to the secondary server.</t>

  <t>7. Pool rebalance event occurs (POOLREQ/POOLRESP messages are
  exchanged). Addresses (or prefixes) belonging to the primary
  server can be assigned to the secondary server pool (transition
  from FREE to FREE_BACKUP) or vice versa.  </t>

  <t>8. The lease has expired.<!-- tomek: v4 draft metioned optional grace period
  here.  I decided to simplify things here and not mention it. Is it ok? kim: yes --></t>

  <t>9. DECLINE message is received or a lease is deemed
   unusable for other reasons.</t>

  <t>10. An administrative action is taken to recover an abandoned lease back to
  usable state. This transition MAY occur due to an implementation specific
  handling on ABANDONED resource. One possible example of such use is a
  Neighbor Discovery or ICMPv6 Echo check if the address is still in use.</t>
</list>
</t>

  <t>The resource that is no longer in use (due to expiration or release),
  becomes FREE*. Depending of what allocation algorithm is used, the resource
  that is no longer is use, returns to primary (FREE) or secondary pool
  (FREE_BACKUP). The conditions for specific transitions are depicted in
  <xref target="free-transition"/>.</t>

  <figure anchor="free-transition" title="FREE* State Transitions" align="center">
    <artwork><![CDATA[
+----------------+---------+-----------+
| \Resource owner|         |           |
|  \----------\  | Primary | Secondary |
|Algorithm     \ |         |           |
+----------------+---------+-----------+
| Proportional   | FREE    |  FREE     | 
| Independent    | FREE    |FREE_BACKUP|
+----------------+---------+-----------+]]>
</artwork></figure>

  <!-- issue 3 
  TODO: In case of Active-Passive model, while a majority of the
  addresses are owned by the primary server, the secondary server will
  need a portion of the addresses to serve new clients while operating in
  communication-interrupted state and also in partner down state before
  it can take over the entire address pool (expiry of MCLT). The
  concept of a percentage of pool reserved for secondary should be
  described here.
  
  Done 10/16/12 Kim
  -->

    <t>In case of servers operating in active-passive mode, while
    a majority of the resources are owned by the primary server,
    the secondary server will need a portion of the resources to
    serve new clients while operating in COMMUNICATION-INTERRUPTED
    state and also in PARTNER-DOWN state before it can take over
    the entire address pool (after the expiry of MCLT).</t>
    
    <t>The secondary server cannot simply take over the entire
    resource pool immediately, since it could also be that
    both servers are able to communicate with DHCP clients,
    but unable to communicate with each other.</t>

    <t>The size of the resource pool allocated to the secondary is
    specified as a percentage of the currently available resources.
    Thus, as the number of available resources changes on the primary
    server, the number of resources available to the secondary
    server MUST also change, although the frequency of the changes
    made to the secondary server's pool of address resources SHOULD
    be low enough to not use significant processing power or network
    bandwidth.</t>

    <t>
    The required size of this private pool allocated to the secondary
    server is based only on the arrival rate of new DHCP clients
    and the length of expected downtime of the primary server, and
    is not directly influenced by the total number of DHCP clients
    supported by the server pair.</t>

</section>

<section title="Failover Mechanisms">

    <t>This section lays out an overview of the communication between
    partners and other mechanisms required for failover operation. As
    this is a design document, not a protocol specification,
    high level ideas are presented without implementation
    specific details (e.g. on-wire protocol formats).</t>
    <section anchor="time-skew" title="Time Skew">
      <t>Partners exchange information about known lease states. To
      reliably compare a known lease state with an update received from a
      partner, servers must be able to reliably compare the times stored
      in the known lease state with the times received in the update.
      Although a simple approach would be to require both partners to use
      synchronized time, e.g. by using NTP, such a service may not always
      be available in some scenarios that failover expects to cover.
      Therefore a mechanism to measure and track
      relative time differences between servers is necessary. To do so,
      each message MUST contain information about the time 
      of the transmission in the time context of the transmitter.
      The transmitting server MUST set this as close to the
      actual transmission as possible.  Transmission here is when
      data is added to the send queue of the socket (or the equivalent),
      as the application may not know about the time of the actual
      transmission of the "wire".   The receiving partner MUST store its
      own timestamp of reception as close to the actual reception as
      possible. The received timestamp information is then compared with local timestamp.</t>

      <t>To account for packet delay variation (jitter), the measured
      difference is not used directly, but rather the moving average of last
      TIME_SKEW_PKTS_AVG packets time difference is calculated. This averaged
      value is referred to as the time skew. Note that the time skew algorithm
      allows cooperation between servers with completely desynchronized
      clocks as well as those whose desynchronization itself is not constant.</t>

    </section>

    <section anchor="lazy-updates" title="Lazy updates">
      <t>Lazy update refers to the requirement placed on a server implementing a
      failover protocol to update its failover partner whenever the binding
      database changes.  A failover protocol which didn't support lazy update
      would require the failover partner update to complete before a DHCPv6
      server could respond to a DHCPv6 client request. Such approach is often
      referred to as 'lockstep' and is the opposite of lazy updates. The lazy
      update mechanism allows a server to allocate a new or extend an existing
      lease and then update its failover partner as time permits.</t>

      <t>Although the lazy update mechanism does not introduce additional
      delays in server response times, it introduces other
      difficulties.  The key problem with lazy update is that when a
      server fails after updating a client with a particular lease
      time and before updating its partner, the partner will believe
      that a lease has expired even though the client still retains a
      valid lease on that address or prefix.  It is also possible that
      the partner will have no record at all of the lease of the resource
      to the client.</t>
    </section>

    <section anchor="mclt" title="MCLT concept">
      <t>In order to handle problem introduced by lazy updates (see
      <xref target="lazy-updates"/>), a period of time known as the
      "Maximum Client Lead Time" (MCLT) is defined and must be known
      to both the primary and secondary servers.  Proper use of this
      time interval places an upper bound on the difference allowed
      between the lease time provided to a DHCPv6 client by a server and
      the lease time known by that server's failover partner.</t>

      <t>The MCLT is typically much less than the lease time that a
      server has been configured to offer a client, and so some
      strategy must exist to allow a server to offer the configured
      lease time to a client.  During a lazy update the updating
      server typically updates its partner with a potential expiration
      time which is longer than the lease time previously given to the
      client and which is longer than the lease time that the server
      has been configured to give a client.  This allows that server
      to give a longer lease time to the client the next time the
      client renews its lease, since the time that it will give to the
      client will not exceed the MCLT beyond the potential expiration
      time acknowledged by its partner.</t>

      <t>The fundamental relationship on which much of the correctness
      of this protocol depends is that the lease expiration time
      known to a DHCPv6 client MUST NOT be greater by more than the MCLT
      beyond the potential expiration time known to that server's
      failover partner.</t>

      <t>The remainder of this section makes the above fundamental
      relationship more explicit.</t>

      <t>This protocol requires a DHCPv6 server to deal with several
      different lease intervals and places specific restrictions on
      their relationships. The purpose of these restrictions is to
      allow the other server in the pair to be able to make certain
      assumptions in the absence of an ability to communicate between
      servers.</t>

      <t>The different times are:
      <list style="hanging">
        <t hangText="desired valid lifetime:">
          <vspace/>
          The desired valid lifetime is the lease interval that a DHCPv6
          server would like to give to a DHCPv6 client in the absence of
          any restrictions imposed by the failover protocol.  Its
          determination is outside of the scope of this
          protocol. Typically this is the result of external
          configuration of a DHCPv6 server.
        </t>
        <t hangText="actual valid lifetime:">
          <vspace/>
          The actual valid lifetime is the lease interval that a DHCPv6 server
          gives out to a DHCPv6 client.
          It may be shorter than the desired valid lifetime (as explained below).
        </t>
        <t hangText="potential valid lifetime:">
          <vspace/>
          The potential valid lifetime is the potential lease expiration interval the
          local server tells to its partner in a BNDUPD message.
        </t>
        <t hangText="acknowledged potential valid lifetime:">
          <vspace/>
          The acknowledged potential valid lifetime is the potential lease
          interval the partner server has most recently acknowledged in
          a BNDACK message.
        </t>
      </list>
      </t>

   <section title="MCLT example">
     <t>The following example demonstrates the MCLT concept in practice. The
     values used are arbitrarily chosen are and not a recommendation for
     actual values. The MCLT in this case is 1 hour.  The desired valid
     lifetime is 3 days, and its renewal time is half the valid lifetime.</t>

     <t>When a server makes an offer for a new lease on an IP address to a
     DHCPv6 client, it determines the desired valid lifetime (in this
     case, 3 days).  It then examines the acknowledged potential valid
     lifetime (which in this case is zero) and determines the remainder
     of the time left to run, which is also zero.  It adds the
     MCLT to this value.  Since the actual valid lifetime cannot be allowed to exceed
     the remainder of the current acknowledged potential valid lifetime
     plus the MCLT, the offer made to the client is for the remainder
     of the current acknowledged potential valid lifetime (i.e. zero)
     plus the MCLT.  Thus, the actual valid lifetime is 1 hour (the MCLT).</t>

     <t>Once the server has sent the REPLY to the DHCPv6 client, it
     will update its failover partner with the lease information.
     However, the desired potential valid lifetime will be composed of one
     half of the current actual valid lifetime added to the desired
     valid lifetime. Thus, the failover partner is updated with a
     BNDUPD with a potential valid lifetime of 1/2 hour + 3 days.</t>

     <t>When the primary server receives a BNDACK to its update of
     the secondary server's (partner's) potential valid lifetime,
     it records that as the acknowledged potential valid lifetime.
     A server MUST NOT send a BNDACK in response to a BNDUPD message
     until it is sure that the information in the BNDUPD message
     has been updated in its lease database.  See <xref
     target="acknowledging-reception"/>.  Thus, the primary server
     in this case can be sure that the secondary server has recorded
     the potential lease interval in its stable storage when the
     primary server receives a BNDACK message from the secondary
     server.</t>

     <t>When the DHCPv6 client attempts to renew at T1 (approximately one
     half an hour from the start of the lease), the primary server
     again determines the desired valid lifetime, which is still 3
     days.  It then compares this with the original acknowledged
     potential valid lifetime (1/2 hour + 3 days) and adjusts for the
     time passed since the secondary was last updated (1/2 hour).  Thus
     the time remaining of the acknowledged potential valid interval is
     3 days.  Adding the MCLT to this yields 3 days plus 1 hour, which
     is more than the desired valid lifetime of 3 days.  So the client
     is renewed for the desired valid lifetime -- 3 days.</t>

     <t>When the primary DHCPv6 server updates the secondary DHCPv6 server
     after the DHCPv6 client's renewal REPLY is complete, it will calculate
     the desired potential valid lifetime as the T1 fraction of the
     actual client valid lifetime (1/2 of 3 days this time = 1.5 days).
     To this it will add the desired client valid lifetime of 3 days,
     yielding a total desired potential valid lifetime of 4.5
     days.  In this way, the primary attempts to have the secondary
     always "lead" the client in its understanding of the client's
     valid lifetime so as to be able to always offer the client the
     desired client valid lifetime.</t>

     <t>Once the initial actual client valid lifetime of the MCLT is past,
     the protocol operates effectively like the DHCPv6 protocol does
     today in its behavior concerning valid lifetimes. However, the
     guarantee that the actual client valid lifetime will never exceed
     the remaining acknowledged partner server potential valid lifetime by more
     than the MCLT allows full recovery from a variety of failures.</t>
   </section>

 </section>

 <section anchor="reachability" title="Unreachability detection">
   <t>Implementers are advised to keep in mind that the timer based
   CONTACT message mechanism is not perfect and may not detect some
   failures. In particular, if the partner is using one interface to
   reach clients ("downlink") and another to reach its partner ("uplink"),
   it is possible that communication with the clients will break,
   yet the mechanism will still claim full reachability. For that reason
   it is beneficial to share the same interface for client traffic
   and communication with the failover partner. That approach may
   have drawbacks in some network topologies.</t>
 </section>

  <section anchor="reallocation" title="Re-allocating Leases">
    <!-- issue 4 
    TODO: Describe controlled re-allocation of released/expired
    leases to different clients.

    Done 10/16/12 Kim
    -->
    <!-- see section 5.2.2 in v4 failover -->

    <t>When in PARTNER-DOWN state there is a waiting period after
    which a resource can be re-allocated to another client.  For
    resources which are available when the server enters PARTNER-DOWN
    state, the period is the MCLT from the entry into PARTNER-DOWN
    state.  For resources which are not available when the server
    enters PARTNER-DOWN state, the period is the MCLT after the
    later of the following times: the potential valid lifetime, the
    most recently transmitted potential valid lifetime, the most
    recently received acknowledged potential valid lifetime, and
    the most recently transmitted acknowledged potential valid
    lifetime.  If this time would be earlier than the current time
    plus the MCLT, then the time the server entered PARTNER-DOWN
    state plus the maximum-client-lead-time is used.</t>

    <!-- I don't think we want to discuss these paragraphs from the
     v4 draft.  Experience shows that nobody wants to live with MCLT
     restrictions in PARTNER-DOWN state.

    Two options exist for lease times given out while in PARTNER-DOWN
    state, with different ramifications flowing from each.

    If the server wishes the Failover protocol to protect it from loss of
    stable storage in PARTNER-DOWN state, then it should ensure that the
    MCLT based lease time restrictions in section 5.1 are maintained,
    even in PARTNER-DOWN state.

    If the server wishes to forego the protection of the Failover proto-
    col in the event of loss of stable storage, then it need recognize no
    restrictions on actual client lease times while in PARTNER-DOWN
    state.

    -->

    <t>In any other state, a server cannot reallocate a resource from one
    client to another without first notifying its partner (through a
    BNDUPD message) and receiving acknowledgement (through a BNDACK message) 
    that its partner is aware that that first client is not using
    the resource.</t>

    <t>This could be modeled in the following way.  Though this specific
    implementation is in no way required, it may serve to better illustrate 
    the concept.</t>

    <t>An "available" resource on a server may be allocated to any client.
    A resource which was leased to a client and which expired or was
    released by that client would take on a new state, EXPIRED or
    RELEASED respectively.  The partner server would then be notified
    that this resource was EXPIRED or RELEASED through a BNDUPD.  When
    the sending server received the BNDACK for that resource showing it
    was FREE, it would move the resource from EXPIRED or RELEASED to
    FREE, and it would be available for allocation by the primary server
    to any clients.</t>

    <t>A server MAY reallocate a resource in the EXPIRED or RELEASED
    state to the same client with no restrictions provided it has not
    sent a BNDUPD message to its partner.  This situation would exist if
    the lease expired or was released after the transition into
    PARTNER-DOWN state, for instance.</t>

  </section>

  <section anchor="send-bndupd" title="Sending Binding Update">

    <t>This and the following section is written as though every
    BNDUPD message contains only a single binding update transaction
    in order to reduce the complexity of the discussion.  Servers
    MAY generate messages with multiple binding update transactions
    in them, and their partner servers MAY process these messages.
    Before multiple binding update transactions are to be sent and
    processed over a failover connection, their use MUST be negotiated
    during the CONNECT and CONNECTACK connection establishment
    processing.</t>

    <!-- tomek: here's the table from v4-failover-12, section 7.1:

                                        binding-status            BACKUP
                                                                  RESET
                                                                  ABANDONED
   Option                        ACTIVE     EXPIRED    RELEASED   FREE
   ======                        ======     =======    ========   ====
   assigned-IP-address (3)       MUST       MUST       MUST       MUST
   IP-flags                      MUST(4)    MUST(4)    MUST(4)    MUST(4)
   binding-status                MUST       MUST       MUST       MUST
   client-identifier             MAY        MAY        MAY        MAY(2)
   client-hardware-address       MUST       MUST       MUST       MAY(2)
   lease-expiration-time         MUST       MUST NOT   MUST NOT   MUST NOT
   potential-expiration-time     MUST       MUST NOT   MUST NOT   MUST NOT
   start-time-of-state           SHOULD     SHOULD     SHOULD     SHOULD
   client-last-trans.-time       MUST       SHOULD     MUST       MAY
   DDNS(1)                       SHOULD     SHOULD     SHOULD     SHOULD
   client-request-options        SHOULD     SHOULD NOT SHOULD     SHOULD NOT
   client-reply-options          SHOULD     SHOULD NOT SHOULD NOT SHOULD NOT

   (1) MUST if server is performing dynamic DNS for this IP address, else
       MUST NOT.
   (2) MUST NOT if binding-status is ABANDONED.
   (3) assigned-IP-address MUST be the first option for an IP address
   (4) IP-flags option MUST appear if any flags are non-zero, else it
       MAY appear. -->

    <t>Each server updates its failover partner about recent changes in lease
    states.  Each update MUST include at least the following information:
    <list style="numbers">
      <t>resource type - non-temporary address or a prefix. Resource type can
      be indicated by the container that conveys the actual resource (e.g. an IA_NA
      option indicates non-temporary IPv6 address);</t>
      <t>resource information - the actual address or prefix. That is conveyed
      using the appropriate option, e.g. an IAADDR for an address or an IAPREFIX for
      a prefix;</t>
      <t>valid life time sent to client*;</t>
      <t>IAID - Identity Association used by the client, while obtaining
      a given lease. (Note1: one client may use many IAIDs
      simultaneously. Note2: IAID for IA, TA and PD are orthogonal
      number spaces.)*;</t>
      <t>Next Expected Client Transmission (renewal time) - time interval since Client Last
      Transmission Time, when a response from a client is expected*; <!--
      this is a T1 timer. Since we decided to use IA_NA/IA_PD anyway, we
      will just set it properly --></t>
      <t>potential valid life time - a lifetime that the server is willing to
      set if there were no MCLT/failover restrictions imposed*;</t>
      <t>preferred life time sent to client - the actual value sent back to
      the client*;</t>
      <t>CLTT - Client Last Transaction Time, a timestamp of the last received
      transmission from a client*;</t>
      <t>Client DUID*.</t>
      <t>Resource state.</t>
      <t>start time of state (especially for non-client updates).</t>
    </list>
    </t>
    <t>Items marked with asterisk MUST appear only if the lease is/was associated
    with a client. Otherwise it MUST NOT appear.</t>
    <!-- TODO: point out that in some states client DUID MUST NOT appear -->
    <!-- tomek: we don't really care about preferred lifetime. Since it is
         defined in IAADDR/IAPREFIX options that we will be reusing, we will
         need to send something. We may just send actual preferred lifetime, but
         it won't be useful for anything. -->
    <!-- tomek: we will use IA_NA + IAADDR, IA_PD + IAPREFIX options here
	 with some new additional options:
	 - valid lifetime requested by client
	 - potential valid life time
	 - cltt -->

    <t>The BNDUPD message MAY contain additional information related to the
    updated lease. The additional information MAY include, but is not limited to:
    <list style="numbers">
      <!-- tomek: v4-failover-12 states that FQDN either MUST or MUST NOT
           appear, depending on whether server did or did not DDNS. Perhaps
           putting it in the optional section is not the right place? -->
      <!-- tomek: I'm not sure it tying FQDN to the actual DDNS update is a good
      idea. There's a corner case when FQDN is used only to assign names to
      hosts, without updating DNSes. It is a use case allowed by the standard,
      not sure if it has any practical applications or if it is really used.
      I suggest a different wording: "depending on whether the server did or
      did not send FQDN option to clients" -->
      <t>assigned FQDN name, defined in <xref target="RFC4704"/>;</t>
      <t>Options Requested by the client, i.e. content of the ORO;</t>
      <t>Relay Data option from DHCPv6 Leasequery, see <xref target="RFC5007"/> Section 4.1.2.4</t>
      <t>Any other options the updating partner deems useful.</t>
    </list>
    </t>

    <t>The receiving partner MAY store any additional information received, but it MAY
    choose to ignore it as well. Some information may be useful, so it is a
    good idea to keep or update it. One reason is FQDN information. A server
    SHOULD be prepared to clean up DNS information once the lease expires or is
    released. See <xref target="DDNS"/> for a detailed discussion about
    Dynamic DNS. Another reason the partner may be interested in keeping additional
    data is a better support for leasequery <xref target="RFC5007"/> or bulk
    leasequery <xref target="RFC5460"/>, which features queries based on
    Relay-ID, by link address and by Remote-ID.</t>
  </section> <!-- sending data -->

  <section title="Receiving Binding Update">

    <!-- see v4-failover-12, section 7.1.2 -->
    <t>When a server receives a BNDUPD message, it needs to decide how to
    process the binding update transaction it contains and whether that
    transaction represents a conflict of any sort. The conflict resolution
    process MUST be used on the receipt of every BNDUPD message, not just those
    that are received while in POTENTIAL-CONFLICT state, in order to increase
    the robustness of the protocol.</t>
    
    <t>There are three sorts of conflicts:
    <list style="numbers">
      <t>Two clients, one resource - This is the duplicate resource allocation
      conflict. There two different clients each allocated the same resource. See
      <xref target="conflict-resolution"/>.</t>
      <t>Two resources, one client conflict - This conflict exists when a client
      on one server is associated with a one resource, and on the other server
      with a different resource in the same or related prefix. This does not
      refer to the case where a single client has resources in multiple
      different prefixes or administrative domains (i.e. a mobile client that
      changed its location), but rather the case where on
      the same prefix the client has a lease on one IP address in one server
      and on a different IP address on the other server.
      
      <!-- how to start new paragraph within the same bullet? -->
      <vspace blankLines="1"/>

      This conflict may or may not be a problem for a given DHCP server
      implementation and policy. If implementations and policies allow, both
      resources can be assigned to a given client. In the event that a DHCP
      server requires that a DHCP client have only one outstanding lease of a
      given type, the conflict MUST be resolved by accepting the lease which has
      the latest CLTT.

      <vspace blankLines="1"/>
      It should be further clarified that DHCPv6 protocol makes
      assignments based on a (client DUID, resource type, IAID)
      triplet. The possibility of using different IAIDs was omitted in
      this paragraph for clarity. If one client is assigned multiple
      resources of the same type, but with different IAIDs, there is
      no conflict. Also, IAID values for different resource types are
      orthogonal, i.e. an IA_NA with IAID=1 is different than an IA_PD with
      IAID=1 and there is no conflict.
      </t>

      <t>binding-status conflict - This is normal conflict, where one server is
      updating the other with newer information. See <xref
      target="conflict-resolution"/> for details of how to resolve these
      conflicts.</t>

      <t> configuration conflict -- This kind of conflict stems
      from a differing configuration on one server than on the other
      server.  It may be transient (last until both servers can
      process a new configuration) or it may be chronic.  It cannot
      be resolved by communications over the failover connection,
      but must be resolved (if it is not transient) by administrator
      action to resolve the conflicts.</t>

    </list>
    </t>
  </section>

    <section anchor="conflict-resolution" title="Conflict Resolution">
      <!-- tomek: that paragraph is no longer needed. Following paragraphs
	   based on v4 failover decribe the issue much better -->
      <t>The server receiving a lease update from its partner must evaluate the
      received lease information to see if it is consistent with already known
      state and decide which information - the previously known or that just received -
      is "better". The server should take into consideration the following
      aspects: if the lease is already assigned to a specific client, who had
      contact with client recently, start time of the lease, etc.</t>

      <t>When analyzing a BNDUPD message from a partner server, if there is
      insufficient information in the BNDUPD to process it, then reject the
      BNDUPD with reject-reason "Missing binding information".</t>

      <t>If the resource in the BNDUPD is not a resource associated with
      the failover endpoint which received the BNDUPD message, then reject
      it with reject-reason "Illegal IP address or prefix (not part of any
      address or prefix pool)".</t>
      <!-- issue 12: do we want separate reject-reason for prefixes? -->

      <t>Every BNDUPD message SHOULD contain a client-last-transaction-time
      option, which MUST, if it appears, be the time that the server last
      interacted with the DHCP client.  It MUST NOT be, for instance, the
      time that the lease on an IP address expired.  If there has been no
      interaction with the DHCP client in question (or there is no DHCP
      client presently associated with this resource), then there will be
      no client-last-transaction-time option in the BNDUPD message.</t>

      <t>The list in <xref target="tbl-conflict-resolution"/> presents the conflict
      resolution outcome. To "accept" a BNDUPD means to update the server's
      bindings database with the information contained in the BNDUDP and once
      the update is complete, send a BNDACK message corresponding to the BNDUPD
      message. To "reject" a BNDUPD means to leave the server's binding database
      unchanged and to respond to the BNDUPD with BNDACK with a reject-reason 
      option included.</t>

      <t>When interpreting the information in the following table (<xref
      target="tbl-conflict-resolution"/>), for those rules that are listed with
      "time" -- if a BNDUPD doesn't have a client-last-transaction-time value,
      then it MUST NOT be considered later than the client-last-transaction-time
      in the receiving server's binding.  If the BNDUPD contains a client-last-
      transaction-time value and the receiving server's binding does not, then
      the client-last-transaction-time value in the BNDUPD MUST be considered
      later than the server's.</t>

  <figure anchor="tbl-conflict-resolution" title="Conflict Resolution">
    <artwork><![CDATA[
                          binding-status in received BNDUPD.
binding-status
in receiving                                      FREE        RESET
server           ACTIVE   EXPIRED   RELEASED   FREE_BACKUP  ABANDONED

ACTIVE           accept(5) time(2)   time(1)    time(2)      accept
EXPIRED          time(1)   accept    accept     accept       accept
RELEASED         time(1)   time(1)   accept     accept       accept
FREE/FREE_BACKUP accept    accept    accept     accept       accept
RESET            time(3)   accept    accept     accept       accept
ABANDONED        reject(4) reject(4) reject(4)  reject(4)    accept
]]></artwork></figure>

    <t>time(1): If the client-last-transaction-time in the BNDUPD is later than
    the client-last-transaction-time in the receiving server's binding, accept
    it, else reject it.</t>

    <t>time(2): If the current time is later than the receiving server's
    lease-expiration-time, accept it, else reject it.</t>

    <t>time(3): If the client-last-transaction-time in the BNDUPD is later than
    the start-time-of-state in the receiving server's binding, accept it, else
    reject it.</t>

    <t>(1,2,3): If rejecting, use reject reason "Outdated binding
    information".</t>

    <t>(4): Use reject reason "Less critical binding information".</t>

    <t>(5): If the clients in a BNDUPD message and in a receiving server's
    binding differ, then if the receiving server is a secondary accept it, else
    reject it with a reject reason of "Fatal conflict exists: address in use
    by other client".</t>

    <!-- issue 5: Done. The issue was: This is just a loose collection of
         notes. This section will probably need to be rewritten as a a flowchart
         of some kind. -->

      <t>The lease update may be accepted or rejected.  Rejection SHOULD NOT
      change the flag in a lease that says that it should be transmitted to the
      failover partner.  If this flag is set, then it should be transmitted, but
      if it is not already set, the rejection of a lease state update SHOULD NOT
      trigger an automatic update of the failover partner sending the rejected
      update.  The potential for update storms is too great, and in the unusual
      case where the servers simply can't agree, that disagreement is better
      than an update storm.
      </t>

    <!-- <t>Discussion: There will definitely be different types of update
      rejections. For example, this will allow a server to treat differently a
      case when receiving a new lease that it previously haven't seen than a
      case when partner sents old version of a lease for which a newer state is
      known.</t>-->
    </section>

    <section anchor="acknowledging-reception" title="Acknowledging Reception">

      <t>Upon acceptance of a binding lease, the server MUST notify its partner
      that it updated its database. A server MUST NOT send the BNDACK before its
      database is updated. A BNDACK MUST contain at lease the minimum set of information
      required to unambiguously identify the BNDUPD that triggered the BNDACK.</t>

    </section>

</section> <!-- partner update -->


  <section title="Proposed extensions">
    <t>The following section discusses possible extensions to the proposed
    failover mechanism. Listed extensions must be sufficiently simple to
    not further complicate failover protocol. Any proposals that are
    considered complex will be defined as stand-alone extensions in
    separate documents.</t>

    <section title="Active-active mode">
      <t>A very simple way to achieve active-active mode is to remove
      the restriction that secondary server MUST NOT respond to SOLICIT
      and REQUEST messages. Instead it could respond, but MUST have
      lower preference than primary server. Clients discovering
      available servers will receive ADVERTISE messages from both
      servers, but are expected to select the primary server as it has
      higher preference value configured. The following REQUEST message
      will be directed to primary server.</t>

      <t>The benefit of this approach, compared to the "basic"
      active--passive solution is that there is no delay between
      primary failure and the moment when secondary starts serving
      requests.</t>

      <!-- tomek: with draft-kostur-dhc-loadbv6-01 available, we don't
	   need to reinvent the wheel anymore
      <t>Discussion: The possibility of setting both servers preference to
      an equal value could theoretically work as a crude attempt to
      provide load balancing. It wouldn't do much good on its own, as
      one (faster) server could be chosen more frequently (assuming
      that with equal preference sets clients will pick first
      responding server, which is not mandated by DHCPv6).  We could
      design a simple mechanism of dynamically updating preference
      depending on usage of available resources. This concept hasn't
      been investigated in detail yet.</t> -->
    </section>
  </section>

  <section anchor="DDNS" title="Dynamic DNS Considerations">

    <t>DHCP servers (and clients) can use DNS Dynamic Updates as
    described in <xref target="RFC2136">RFC 2136</xref> to maintain
    DNS name-mappings as they maintain DHCP leases.  Many different
    administrative models for DHCP-DNS integration are possible.
    Descriptions of several of these models, and guidelines that
    DHCP servers and clients should follow in carrying them out,
    are laid out in <xref target="RFC4704">RFC 4704</xref>.</t>

    <t>The nature of the failover protocol introduces some issues
    concerning dynamic DNS (DDNS) updates that are not part of non-failover
    environments.  This section describes these issues, and defines
    the information which failover partners should exchange in order
    to ensure consistent behavior.  The presence of this section
    should not be interpreted as requiring an implementation of
    the DHCPv6 failover protocol to also support DDNS updates.</t>

    <t>The purpose of this discussion is to clarify the areas where
    the failover and DHCP-DDNS protocols intersect for the benefit
    of implementations which support both protocols, not to introduce
    a new requirement into the DHCPv6 failover protocol.  Thus, a
    DHCPv6 server which implements the failover protocol MAY also
    support dynamic DNS updates, but if it does support dynamic DNS
    updates it SHOULD utilize the techniques described here in order
    to correctly distribute them between the failover partners.
    See <xref target="RFC4704">RFC 4704</xref> as well as <xref
    target="RFC4703">RFC 4703</xref> for information on how DHCPv6
    servers deal with potential conflicts when updating DNS even
    without failover.</t>

    <t>From the standpoint of the failover protocol, there is no
    reason why a server which is utilizing the DDNS protocol to
    update a DNS server should not be a partner with a server which
    is not utilizing the DDNS protocol to update a DNS server.
    However, a server which is not able to support DDNS or is not
    configured to support DDNS SHOULD output a warning message when
    it receives BNDUPD messages which indicate that its failover
    partner is configured to support the DDNS protocol to update a
    DNS server.  An implementation MAY consider this an error and
    refuse to operate, or it MAY choose to operate anyway, having
    warned the administrator of the problem in some way.</t>

    <section anchor="failover-ddns"
       title="Relationship between failover and dynamic DNS update">

	<t>The failover protocol describes the conditions under
	which each failover server may renew a lease to its current
	DHCP client, and describes the conditions under which it
	may grant a lease to a new DHCP client.  An analogous set
	of conditions determines when a failover server should
	initiate a DDNS update, and when it should attempt to remove
	records from the DNS. The failover protocol's conditions
	are based on the desired external behavior: avoiding duplicate
	address and prefix assignments; allowing clients to continue
	using leases which they obtained from one failover partner
	even if they can only communicate with the other partner;
	allowing the secondary DHCP server to grant new leases even
	if it is unable to communicate with the primary server.
	The desired external DDNS behavior for DHCP failover servers
	is similar to that described above for the failover protocol
	itself:</t>

	<t><list style="numbers">
	    <t>Allow timely DDNS updates from the server which
	    grants a lease to a client. Recognize that there is
	    often a DDNS update lifecycle which parallels the DHCP
	    lease lifecycle. This is likely to include the addition
	    of records when the lease is granted, and the removal
	    of DNS records when the leased resource is subsequently
	    made available for allocation to a different client.</t>

	    <t>Communicate enough information between the two
	    failover servers to allow one to complete the DDNS
	    update 'lifecycle' even if the other server originally
	    granted the lease.</t>

	    <t>Avoid redundant or overlapping DDNS updates, where
	    both failover servers are attempting to perform DDNS
	    updates for the same lease-client binding.</t>
	    
	    <t>Avoid situations where one partner is attempting to
	    add RRs related to a lease binding while the other
	    partner is attempting to remove RRs related to the same
	    lease binding.</t>
	</list></t>

	<t>While DHCP servers configured for DDNS typically perform
	these operations on both the AAAA and the PTR resource records, 
	this is not required.  It is entirely possible that a DHCP server
	could be configured to only update the DNS with PTR records, and 
	the DHCPv6 clients could be responsible for updating the DNS with
	their own AAAA records.  In this case, the discussions here would
	apply only to the PTR records.</t>

    </section>


  </section>


  <!-- tomek: this is definitely material for protocol draft, not the design
  draft -->
  <!--
  <section anchor="protocol-skeleton" title="Protocol entities">
    <t>Discussion: It is unclear if following sections belong to
    design or protocol draft. It is currently kept here as a
    scratchbook with list of things that will have to be defined
    eventually. Whether or not it will stay in this document or will be moved to
    the protocol spec document is TBD.</t>

    <section anchor="options" title="Failover Protocol">
      <t>This section enumerates list of options that will be defined in
      failover protocol specification. Rough description of purpose and
      content for each option is specified. Exact on wire format will be
      defined in protocol specification.</t>
      <t><list style="numbers">
        <t>OPTION_FO_TIMESTAMP - convey information about timestamp. It
        is used by time skew measurement algorithm (see <xref
        target="time-skew"/>).</t>
      </list></t>
    </section>

    <section anchor="defines" title="Protocol constants">
      <t>This section enumerates various constants that have to be defined
      in actual protocol specification.</t>
      <t><list style="numbers">
        <t>TIME_SKEW_PKTS_AVG - number of packets that are used to calculate
        average time skew between partners. See (see <xref
        target="time-skew"/>).</t>
      </list></t>
    </section>

  </section> -->

  <section title="Security Considerations">
    <t>DHCPv6 failover is an extension of a standard DHCPv6 protocol, so all
    security considerations from <xref target="RFC3315" />, Section 23 and
    <xref target="RFC3633" />, Section 15 related to the server apply.</t>

    <t>As traffic exchange between clients and server is not encrypted,
    an attacker that penetrated the network and is able to intercept traffic,
    will not gain any additional information by also sniffing communication
    between partners.</t>

    <t>An attacker that is able to impersonate one partner can efficiently
    perform a denial of service attack on the remaining uncompromised server.
    Several techniques may be used: pretending that conflict resolution
    is required, requesting rebalance, claiming that a valid lease was released
    or declined etc. For that reason the communication between servers
    SHOULD support failover connections over TLS.  Such secure connections SHOULD
    be optional and configurable by the administrator.</t>

    <t>A server MUST NOT operate in PARTNER-DOWN if its partner is up.
    Network administrators are expected to switch the remaining active server
    to PARTNER-DOWN state only if they is sure that its partner server
    is indeed down. Failing to obey this requirement will result in both
    servers likely assigning duplicate leases to different clients. Implementers
    should take that into consideration if they decide to implement
    the auto-partner-down timer-based transition to PARTNER-DOWN state.</t>

    <t>Running a network protected by DHCPv6 failover requires more resources
    than running without it. In particular some of the resources are
    allocated to the secondary server and they are not usable in a normal
    (i.e. non failures) operation immediately, though over time they will
    be rebalanced and end up on the server that needs them. While limiting 
    this pool may be preferable from resource utilization perspective, 
    it must be a reasonably large pool, so the secondary may take over once 
    the primary becomes unavailable.</t>

  </section>

  <section title="IANA Considerations">
    <t>IANA is not requested to perform any actions at this time.</t>
  </section>

  <section title="Acknowledgements">
    <t>This document extensively uses concepts, definitions and other
    parts of <xref target="dhcpv4-failover"/> document.  Authors would
    like to thank Shawn Routher, Greg Rabil, Bernie Volz and Marcin Siodelski
    for their significant involvement and contributions. Authors would like to
    thank VithalPrasad Gaitonde, Krzysztof Gierlowski, Krzysztof Nowicki and
    Michal Hoeft for their insightful comments.</t>

    <t>This work has been partially supported by Department of
    Computer Communications (a division of Gdansk University of
    Technology) and the Polish Ministry of Science and Higher
    Education under the European Regional Development Fund, Grant
    No. POIG.01.01.02-00-045/09-00 (Future Internet Engineering
    Project).</t>
  </section>

</middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.3315'?>
      <?rfc include='reference.RFC.3633'?>
      <?rfc include='reference.RFC.4703'?>
      <?rfc include='reference.RFC.4704'?>
      <?rfc include='reference.RFC.5007'?>
      <?rfc include='reference.RFC.7031'?>
    </references>
    <references title="Informative References">
      <?rfc include='reference.RFC.5460'?>
      <?rfc include='reference.I-D.ietf-dhc-dhcpv6-failover-design.xml'?>
      <?rfc include='reference.I-D.ietf-dhc-dhcpv6-load-balancing.xml'?>
      <reference anchor="dhcpv4-failover">
        <front>
          <title>DHCP Failover Protocol</title> <author fullname="Ralph
          Droms" initials="R." surname="Droms">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Kim Kinnear" initials="K."
          surname="Kinnear">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Mark Stapp" initials="M."
          surname="Stapp">
            <organization>Cisco Systems</organization>
          </author> <author fullname="Bernie Volz" initials="B."
          surname="Volz">
            <organization>Ericsson</organization>
          </author> <author fullname="Steve Gonczi" initials="S."
          surname="Gonczi">
            <organization>Relicore</organization>
          </author> <author fullname="Greg Rabil" initials="G."
          surname="Rabil">
            <organization>Lucent Technologies</organization>
          </author> <author fullname="Michael Dooley" initials="M."
          surname="Dooley">
            <organization>Diamond IP Technologies</organization>
          </author> <author fullname="Arun Kapur" initials="A."
          surname="Kapur">
            <organization>K5 Networks</organization>
          </author> <date month="March" year='2003'/>
        </front> <seriesInfo name="Internet-Draft"
        value="draft-ietf-dhc-failover-12"/>
      </reference> <?rfc
      include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2136'?>

    </references>
  </back>
</rfc>
